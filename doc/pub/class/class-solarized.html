<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Introduction to classes in Python">
<meta name="keywords" content="constructor (class),UML class diagram,instance (class),user-defined datatype (class),method class),attribute (class),namespace,test function,nose tests,pytest tests,special methods (class),callable objects,test function,closure,Newton's method,wrapper code,integration numerical,symbolic computing,integration symbolic,mutable objects,immutable objects,protected attributes (class),test function,information hiding,private attributes (class),API,application programming interface,protected attributes (class),check an object's type,static typing,weak typing,strong typing,dynamic typing,duck typing,static class attributes,static class variables,static class methods,interval arithmetic">

<title>Introduction to classes in Python</title>


<link href="https://raw.githubusercontent.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="http://www.peterhaschke.com/assets/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>

</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [(' Simple function classes ',
               1,
               'sec:class:functors',
               'sec:class:functors'),
              (' Challenge: functions with parameters ',
               2,
               'sec:class:func1',
               'sec:class:func1'),
              (' Problem ', 3, None, '___sec2'),
              (' A bad solution: global variables ', 3, None, '___sec3'),
              (' Representing a function as a class ',
               2,
               'sec:class:func2',
               'sec:class:func2'),
              (' Implementation ', 3, None, '___sec5'),
              (' Usage and dissection ', 3, None, '___sec6'),
              (' The self  variable ', 3, None, '___sec7'),
              (' Extension of the class ', 3, None, '___sec8'),
              (' Remark ', 3, None, '___sec9'),
              (' Using methods as ordinary functions ', 3, None, '___sec10'),
              (' Doc strings ', 3, None, '___sec11'),
              (' Another function class example ',
               2,
               'sec:class:func3',
               'sec:class:func3'),
              (' Remark ', 3, None, '___sec13'),
              (' Alternative function class implementations ',
               2,
               'sec:class:func2b',
               'sec:class:func2b'),
              (' Making classes without the class construct ',
               2,
               'sec:class:whatis',
               'sec:class:whatis'),
              (' First remark ', 3, None, '___sec16'),
              (' Second remark ', 3, None, '___sec17'),
              (' More examples on classes ',
               1,
               'sec:class:addex',
               'sec:class:addex'),
              (' Bank accounts ',
               2,
               'sec:class:account',
               'sec:class:account'),
              (' Phone book ',
               2,
               'sec:class:phonebook',
               'sec:class:phonebook'),
              (' A circle ', 2, 'sec:class:circle', 'sec:class:circle'),
              (' Verification ', 3, None, '___sec22'),
              (' Remark ', 3, None, '___sec23'),
              (' Special methods ',
               1,
               'sec:class:specialmethods',
               'sec:class:specialmethods'),
              (' The call special method ',
               2,
               'sec:class:call',
               'sec:class:call'),
              (' Example: Automagic differentiation ',
               2,
               'sec:class:autodF',
               'sec:class:autodF'),
              (' Problem ', 3, None, '___sec27'),
              (' Solution ', 3, None, '___sec28'),
              (' Verification ', 3, None, '___sec29'),
              (" Application: Newton's method ", 3, None, '___sec30'),
              (' Example: Automagic integration ',
               2,
               'sec:class:autoint',
               'sec:class:autoint'),
              (' A simple implementation ', 3, None, '___sec32'),
              (' Verification via symbolic computing ', 3, None, '___sec33'),
              (' Remark ', 3, None, '___sec34'),
              (' Turning an instance into a string ',
               2,
               'sec:class:str',
               'sec:class:str'),
              (' Example: Phone book with special methods ',
               2,
               'sec:class:phonebook2',
               'sec:class:phonebook2'),
              (' Remark ', 3, None, '___sec37'),
              (' Adding objects ', 2, 'sec:class:add', 'sec:class:add'),
              (' Example: Class for polynomials ',
               2,
               'sec:class:Polynomial',
               'sec:class:Polynomial'),
              (' Implementation ', 3, None, '___sec40'),
              (' Usage ', 3, None, '___sec41'),
              (' Pretty print of polynomials ', 3, None, '___sec42'),
              (' Verifying the implementation ', 3, None, '___sec43'),
              (' Arithmetic operations and other special methods ',
               2,
               'sec:class:arithmetics',
               'sec:class:arithmetics'),
              (' Special methods for string conversion ',
               2,
               'sec:class:repr',
               'sec:class:repr'),
              (' Recreating objects from strings ', 3, None, '___sec46'),
              (' Example: Class for vectors in the plane ',
               1,
               'sec:class:Vec2D',
               'sec:class:Vec2D'),
              (' Some mathematical operations on vectors ',
               2,
               None,
               '___sec48'),
              (' Implementation ', 2, None, '___sec49'),
              (' Usage ', 2, None, '___sec50'),
              (' Comment ', 3, None, '___sec51'),
              (' Example: Class for complex numbers ', 1, None, '___sec52'),
              (' Implementation ',
               2,
               'sec:class:Complex',
               'sec:class:Complex'),
              (' Illegal operations ',
               2,
               'sec:class:illegalop',
               'sec:class:illegalop'),
              (' Mixing complex and real numbers ',
               2,
               'sec:class:complex:mixed',
               'sec:class:complex:mixed'),
              (' Dynamic, static, strong, weak, and duck typing ',
               2,
               None,
               '___sec56'),
              (" Special methods for ``right'' operands ",
               2,
               'sec:class:complex:rightop',
               'sec:class:complex:rightop'),
              (' Remark ', 3, None, '___sec58'),
              (' Inspecting instances ',
               2,
               'sec:class:inspect',
               'sec:class:inspect'),
              (' Static methods and attributes ',
               1,
               'sec:class:static',
               'sec:class:static'),
              (' Summary ', 1, None, '___sec61'),
              (' Chapter topics ',
               2,
               'sec:class:summary',
               'sec:class:summary'),
              (' Classes ', 3, None, '___sec63'),
              (' Special methods ', 3, None, '___sec64'),
              (' Terminology ', 3, None, '___sec65'),
              (' Example: interval arithmetic ', 2, None, '___sec66'),
              (' Problem ', 3, None, '___sec67'),
              (' Solution ', 3, None, '___sec68'),
              (' Exercises ', 1, None, '___sec69'),
              (' Exercise 1: Make a function class ',
               2,
               'sec:class:ex2',
               'sec:class:ex2'),
              (' Exercise 2: Add an attribute to a class ',
               2,
               'sec:class:ex25q',
               'sec:class:ex25q'),
              (' Exercise 3: Add functionality to a class ',
               2,
               'sec:class:ex25q2',
               'sec:class:ex25q2'),
              (' Exercise 4: Make classes for a rectangle and a triangle ',
               2,
               'sec:class:ex23',
               'sec:class:ex23'),
              (' Exercise 5: Make a class for quadratic functions ',
               2,
               'sec:class:ex11',
               'sec:class:ex11'),
              (' Exercise 6: Make a class for straight lines ',
               2,
               'sec:class:ex25',
               'sec:class:ex25'),
              (' Exercise 7: Flexible handling of function arguments ',
               2,
               'sec:class:ex25b',
               'sec:class:ex25b'),
              (' Exercise 8: Wrap functions in a class ',
               2,
               'sec:class:ex27d',
               'sec:class:ex27d'),
              (' Exercise 9: Flexible handling of function arguments ',
               2,
               'sec:class:ex27e',
               'sec:class:ex27e'),
              (' Exercise 10: Deduce a class implementation ',
               2,
               'sec:class:ex1',
               'sec:class:ex1'),
              (' Exercise 11: Implement special methods in a class ',
               2,
               'sec:class:ex2b2',
               'sec:class:ex2b2'),
              (' Exercise 12: Make a class for summation of series ',
               2,
               'sec:class:ex2b',
               'sec:class:ex2b'),
              (' Exercise 13: Apply a numerical differentiation class ',
               2,
               'sec:class:ex10',
               'sec:class:ex10'),
              (' Exercise 14: Apply symbolic differentiation ',
               2,
               'sec:class:exer:sympy:diff',
               'sec:class:exer:sympy:diff'),
              (' Exercise 15: Implement in-place `+=` and `-=` operators ',
               2,
               'sec:class:ex25qb',
               'sec:class:ex25qb'),
              (' Exercise 16: Implement a class for numerical differentiation ',
               2,
               'sec:class:ex21',
               'sec:class:ex21'),
              (' Exercise 17: Examine a program ',
               2,
               'sec:class:ex21b',
               'sec:class:ex21b'),
              (' Exercise 18: Modify a class for numerical differentiation ',
               2,
               'sec:class:ex23s',
               'sec:class:ex23s'),
              (' Exercise 19: Make a class for the Heaviside function ',
               2,
               'sec:basic:exHclass',
               'sec:basic:exHclass'),
              (' Exercise 20: Make a class for the indicator function ',
               2,
               'sec:basic:exIndclass',
               'sec:basic:exIndclass'),
              (' Exercise 21: Make a class for piecewise constant functions ',
               2,
               'sec:basic:ex:piecewisefunc',
               'sec:basic:ex:piecewisefunc'),
              (' Exercise 22: Speed up repeated integral calculations ',
               2,
               'sec:class:ex13c',
               'sec:class:ex13c'),
              (' Exercise 23: Apply a class for polynomials ',
               2,
               'sec:class:ex5',
               'sec:class:ex5'),
              (' Exercise 24: Find a bug in a class for polynomials ',
               2,
               'sec:class:ex4',
               'sec:class:ex4'),
              (' Exercise 25: Implement subtraction of polynomials ',
               2,
               'sec:class:ex6a',
               'sec:class:ex6a'),
              (' Exercise 26: Test the functionality of pretty print of polynomials ',
               2,
               'sec:class:exer:str',
               'sec:class:exer:str'),
              (' Exercise 27: Vectorize a class for polynomials ',
               2,
               'sec:class:ex7v',
               'sec:class:ex7v'),
              (' Remarks ', 3, None, '___sec97'),
              (' Exercise 28: Use a dict to hold polynomial coefficients ',
               2,
               'sec:class:ex8',
               'sec:class:ex8'),
              (' Exercise 29: Extend class Vec2D to work with lists/tuples ',
               2,
               'sec:class:ex16',
               'sec:class:ex16'),
              (' Exercise 30: Extend class Vec2D to 3D vectors ',
               2,
               'sec:class:ex17b',
               'sec:class:ex17b'),
              (' Exercise 31: Use NumPy arrays in class Vec2D ',
               2,
               'sec:class:ex17',
               'sec:class:ex17'),
              (' Exercise 32: Make classes for students and courses ',
               2,
               'sec:class:ex15',
               'sec:class:ex15'),
              (' Exercise 33: Find local and global extrema of a function ',
               2,
               'sec:plot:ex28',
               'sec:plot:ex28'),
              (' Exercise 34: Find the optimal production for a company ',
               2,
               'sec:class:ex18a',
               'sec:class:ex18a'),
              (' References ', 1, None, '___sec105')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\tp}{\thinspace .}
$$




    
<a name="part0000"></a>
<p>
<!-- begin top navigation -->
<table style="width: 100%"><tr><td>
</td><td>
</td></tr></table>
<!-- end top navigation -->
</p>

<p>
<!-- ------------------- main content ---------------------- -->



<center><h1>Introduction to classes in Python</h1></center>  <!-- document title -->

<p>
<!-- author(s): Hans Petter Langtangen -->

<center>
<b>Hans Petter Langtangen</b> [1, 2]
</center>


<p>
<!-- institution(s) -->

<center>[1] <b>Center for Biomedical Computing, Simula Research Laboratory</b></center>
<center>[2] <b>Department of Informatics, University of Oslo</b></center>
<p>
<center><h4>Aug 31, 2014</h4></center> <!-- date -->

<h2>Table of contents</h2>

<a href="#sec:class:functors"> Simple function classes </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:func1"> Challenge: functions with parameters </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec2"> Problem </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec3"> A bad solution: global variables </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:func2"> Representing a function as a class </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec5"> Implementation </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec6"> Usage and dissection </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec7"> The self  variable </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec8"> Extension of the class </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec9"> Remark </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec10"> Using methods as ordinary functions </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec11"> Doc strings </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:func3"> Another function class example </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec13"> Remark </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:func2b"> Alternative function class implementations </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:whatis"> Making classes without the class construct </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec16"> First remark </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec17"> Second remark </a><br>
<a href="#sec:class:addex"> More examples on classes </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:account"> Bank accounts </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:phonebook"> Phone book </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:circle"> A circle </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec22"> Verification </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec23"> Remark </a><br>
<a href="#sec:class:specialmethods"> Special methods </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:call"> The call special method </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:autodF"> Example: Automagic differentiation </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec27"> Problem </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec28"> Solution </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec29"> Verification </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec30"> Application: Newton's method </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:autoint"> Example: Automagic integration </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec32"> A simple implementation </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec33"> Verification via symbolic computing </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec34"> Remark </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:str"> Turning an instance into a string </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:phonebook2"> Example: Phone book with special methods </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec37"> Remark </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:add"> Adding objects </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:Polynomial"> Example: Class for polynomials </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec40"> Implementation </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec41"> Usage </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec42"> Pretty print of polynomials </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec43"> Verifying the implementation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:arithmetics"> Arithmetic operations and other special methods </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:repr"> Special methods for string conversion </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec46"> Recreating objects from strings </a><br>
<a href="#sec:class:Vec2D"> Example: Class for vectors in the plane </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec48"> Some mathematical operations on vectors </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec49"> Implementation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec50"> Usage </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec51"> Comment </a><br>
<a href="#___sec52"> Example: Class for complex numbers </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:Complex"> Implementation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:illegalop"> Illegal operations </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:complex:mixed"> Mixing complex and real numbers </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec56"> Dynamic, static, strong, weak, and duck typing </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:complex:rightop"> Special methods for &quot;right&quot; operands </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec58"> Remark </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:inspect"> Inspecting instances </a><br>
<a href="#sec:class:static"> Static methods and attributes </a><br>
<a href="#___sec61"> Summary </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:summary"> Chapter topics </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec63"> Classes </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec64"> Special methods </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec65"> Terminology </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec66"> Example: interval arithmetic </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec67"> Problem </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec68"> Solution </a><br>
<a href="#___sec69"> Exercises </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:ex2"> Exercise 1: Make a function class </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:ex25q"> Exercise 2: Add an attribute to a class </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:ex25q2"> Exercise 3: Add functionality to a class </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:ex23"> Exercise 4: Make classes for a rectangle and a triangle </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:ex11"> Exercise 5: Make a class for quadratic functions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:ex25"> Exercise 6: Make a class for straight lines </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:ex25b"> Exercise 7: Flexible handling of function arguments </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:ex27d"> Exercise 8: Wrap functions in a class </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:ex27e"> Exercise 9: Flexible handling of function arguments </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:ex1"> Exercise 10: Deduce a class implementation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:ex2b2"> Exercise 11: Implement special methods in a class </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:ex2b"> Exercise 12: Make a class for summation of series </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:ex10"> Exercise 13: Apply a numerical differentiation class </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:exer:sympy:diff"> Exercise 14: Apply symbolic differentiation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:ex25qb"> Exercise 15: Implement in-place <code>+=</code> and <code>-=</code> operators </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:ex21"> Exercise 16: Implement a class for numerical differentiation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:ex21b"> Exercise 17: Examine a program </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:ex23s"> Exercise 18: Modify a class for numerical differentiation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:basic:exHclass"> Exercise 19: Make a class for the Heaviside function </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:basic:exIndclass"> Exercise 20: Make a class for the indicator function </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:basic:ex:piecewisefunc"> Exercise 21: Make a class for piecewise constant functions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:ex13c"> Exercise 22: Speed up repeated integral calculations </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:ex5"> Exercise 23: Apply a class for polynomials </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:ex4"> Exercise 24: Find a bug in a class for polynomials </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:ex6a"> Exercise 25: Implement subtraction of polynomials </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:exer:str"> Exercise 26: Test the functionality of pretty print of polynomials </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:ex7v"> Exercise 27: Vectorize a class for polynomials </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec97"> Remarks </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:ex8"> Exercise 28: Use a dict to hold polynomial coefficients </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:ex16"> Exercise 29: Extend class Vec2D to work with lists/tuples </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:ex17b"> Exercise 30: Extend class Vec2D to 3D vectors </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:ex17"> Exercise 31: Use NumPy arrays in class Vec2D </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:ex15"> Exercise 32: Make classes for students and courses </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:ex28"> Exercise 33: Find local and global extrema of a function </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:ex18a"> Exercise 34: Find the optimal production for a company </a><br>
<a href="#___sec105"> References </a><br>
</p>
<p>
<!-- Externaldocuments: ../formulas/main_formulas, ../looplist/main_looplist, ../funcif/main_funcif, ../input/main_input, ../plot/main_plot, ../files/main_files, ../random/main_random, ../oo/main_oo, ../diffeq/main_diffeq, ../discalc/main_discalc, ../ode1/main_ode1, ../boxspring/main_boxspring, ../ode2/main_ode2, ../debug/main_debug, ../cython/main_cython, ../tech/main_timing, ../tech/main_varargs, ../tech/main_runpy, ../tech/main_ostasks, ../tech/main_accesspy, ../tech/main_nose -->

<p>
<a name="ch:class"></a>

<p>
A class packs a set of data (variables) together with a set of
functions operating on the data. The goal is to achieve more modular
code by grouping data and functions into manageable (often small)
units. Most of the mathematical computations in this document can easily
be coded without using classes, but in many problems, classes enable
either more elegant solutions or code that is easier to extend at a
later stage.  In the non-mathematical world, where there are no
mathematical concepts and associated algorithms to help structure the
problem solving, software development can be very challenging. Classes
may then improve the understanding of the problem and
contribute to simplify the modeling of data and actions in programs.
As a consequence, almost all large software systems being developed in the
world today are heavily based on classes.

<p>
Programming with classes is offered by most modern programming
languages, also Python.  In fact, Python employs classes to a very
large extent, but one can use the language for lots of purposes
without knowing what a class is. However, one will frequently
encounter the class concept when searching books or the World Wide Web
for Python programming information. And more important, classes often
provide better solutions to programming problems.  This document
therefore gives an introduction to the class concept with emphasis on
applications to numerical computing.  More advanced use of classes,
including inheritance and object orientation, is treated in
the document <a href="http://tcse6.on.net/oo" target="_self">Object-oriented programming</a> <a href="#Langtangen_TCSE6_oo">[1]</a>.

<p>
The folder <a href="http://tinyurl.com/pwyasaa/class" target="_self"><tt>src/class</tt></a> contains all the program examples from
the present document.

<h1>Simple function classes <a name="sec:class:functors"></a></h1>

Classes can be used for many things in scientific computations, but
one of the most frequent programming tasks is to represent mathematical
functions that have a set of parameters in addition to one or more
independent variables.  The section <a href="#sec:class:func1">Challenge: functions with parameters</a> explains
why such mathematical functions pose difficulties for programmers, and
the section <a href="#sec:class:func2">Representing a function as a class</a> shows how the class idea meets
these difficulties.
The sections <a href="#sec:class:func3">Another function class example</a> presents another example where a class
represents a mathematical function.
More advanced material about classes, which for some readers may clarify
the ideas, but which can also be skipped in a first reading,
appears in the sections <a href="#sec:class:func2b">Alternative function class implementations</a> and
the section <a href="#sec:class:whatis">Making classes without the class construct</a>.

<h2>Challenge: functions with parameters <a name="sec:class:func1"></a></h2>

To motivate for the class concept, we will look at functions with
parameters. One example is \( y(t)=v_0t-\frac{1}{2}gt^2 \).  Conceptually,
in physics, the \( y \) quantity is viewed as a function of \( t \), but \( y \)
also depends on two other parameters, \( v_0 \) and \( g \), although it is
not natural to view \( y \) as a <em>function</em> of these parameters.  We may
write \( y(t;v_0,g) \) to indicate that \( t \) is the independent variable,
while \( v_0 \) and \( g \) are parameters. Strictly speaking, \( g \) is a fixed
parameter (as long as we are on the surface of the earth and can view
\( g \) as constant), so only \( v_0 \) and \( t \) can be arbitrarily chosen in
the formula.  It would then be better to write \( y(t;v_0) \).

<p>
In the general case, we may have a function of \( x \) that has \( n \)
parameters \( p_1,\ldots,p_n \):
\( f(x; p_1,\ldots,p_n) \).
One example could be

$$
\begin{equation*} g(x; A, a) = Ae^{-ax} \thinspace .  \end{equation*}
$$


<p>
How should we implement such functions? One obvious way is to have
the independent variable and the parameters as arguments:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def y(t, v0):
    g = 9.81
    return v0*t - 0.5*g*t**2

def g(x, a, A):
    return A*exp(-a*x)
</code></pre>
<!-- end verbatim block -->

<h3>Problem  <a name="___sec2"></a></h3>

There is one major problem with this solution. Many software tools we can use
for mathematical operations on functions assume that a function of one
variable has only one argument in the computer representation of the
function. For example, we may have a tool for differentiating a function
\( f(x) \) at a point \( x \), using the approximation

$$
\begin{equation}
f'(x)\approx {f(x+h)-f(x)\over h}
\tag{1}
\end{equation}
$$

coded as

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def diff(f, x, h=1E-5):
    return (f(x+h) - f(x))/h
</code></pre>
<!-- end verbatim block -->
The <code>diff</code> function works with any function <code>f</code> that takes
one argument:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def h(t):
    return t**4 + 4*t

dh = diff(h, 0.1)

from math import sin, pi
x = 2*pi
dsin = diff(sin, x, h=1E-6)
</code></pre>
<!-- end verbatim block -->
Unfortunately, <code>diff</code> will not work with our <code>y(t, v0)</code>
function.  Calling <code>diff(y, t)</code> leads to an error inside the
<code>diff</code> function, because it tries to call our <code>y</code> function with
only one argument while the <code>y</code> function requires two.

<p>
Writing an alternative <code>diff</code> function for
<code>f</code> functions having two arguments is a bad remedy as it
restricts the set of admissible <code>f</code> functions to the very special
case of a function with one independent variable and one parameter.
A fundamental principle in computer programming is to strive for
software that is as general and widely applicable as possible.
In the present case, it means that the <code>diff</code> function should be
applicable to all functions <code>f</code> of one variable, and letting
<code>f</code> take one argument is then the natural decision to make.

<p>
The mismatch of function arguments, as outlined above, is a major
problem because a lot of software libraries are available for
operations on mathematical functions of one variable: integration,
differentiation, solving \( f(x)=0 \), finding extrema, etc.
All these libraries will try to
call the mathematical function we provide with only one argument.
When our function has more arguments, the code inside the library
aborts in the call to our function, and such errors may not always
be easy to track down.

<h3>A bad solution: global variables  <a name="___sec3"></a></h3>

The requirement is thus
to define Python implementations of mathematical functions
of one variable with one argument, the independent variable.
The two examples above must then be implemented as

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def y(t):
    g = 9.81
    return v0*t - 0.5*g*t**2

def g(t):
    return A*exp(-a*x)
</code></pre>
<!-- end verbatim block -->
These functions work only if
<code>v0</code>, <code>A</code>, and <code>a</code> are global variables,
initialized before one attempts to call the functions.
Here are two sample calls where <code>diff</code> differentiates <code>y</code> and <code>g</code>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>v0 = 3
dy = diff(y, 1)

A = 1; a = 0.1
dg = diff(g, 1.5)
</code></pre>
<!-- end verbatim block -->

<p>
The use of global variables is in general considered bad programming.
Why global variables are problematic in the present case
can be illustrated when there is need to work with several
versions of a function. Suppose we want to work with two versions
of \( y(t;v_0) \), one with \( v_0=1 \) and one with \( v_0=5 \).
Every time we call <code>y</code> we must remember which version of the function
we work with, and set <code>v0</code> accordingly prior to the call:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>v0 = 1; r1 = y(t)
v0 = 5; r2 = y(t)
</code></pre>
<!-- end verbatim block -->

<p>
Another problem is that
variables with simple names like <code>v0</code>, <code>a</code>, and <code>A</code> may
easily be used as global variables in other parts of the program.
These parts may change our <code>v0</code> in a context different from the
<code>y</code> function, but the change affects the correctness of the
<code>y</code> function. In such a case, we say that changing <code>v0</code> has
<em>side effects</em>, i.e., the change affects other parts of the program
in an unintentional way.
This is one reason why a golden rule of programming tells us to limit the
use of global variables as much as possible.

<p>
Another solution to the problem of needing two \( v_0 \) parameters
could be to introduce two <code>y</code> functions, each with
a distinct \( v_0 \) parameter:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def y1(t):
    g = 9.81
    return v0_1*t - 0.5*g*t**2

def y2(t):
    g = 9.81
    return v0_2*t - 0.5*g*t**2
</code></pre>
<!-- end verbatim block -->
Now we need to initialize <code>v0_1</code> and <code>v0_2</code> once, and then
we can work with <code>y1</code> and <code>y2</code>.
However, if we need 100 \( v_0 \) parameters, we need 100 functions.
This is tedious to code, error prone, difficult to administer, and
simply a really bad solution to a programming problem.

<p>
So, is there a good remedy? The answer is yes: the class concept
solves all the problems described above!

<h2>Representing a function as a class <a name="sec:class:func2"></a></h2>

A class contains a set of variables (data)
and a set of functions, held together as one unit.
The variables are visible in all the functions in the class. That is,
we can view the variables as &quot;global&quot; in these functions.
These characteristics also apply to modules, and modules can be
used to obtain many of the same advantages as classes offer (see
comments in the section <a href="#sec:class:whatis">Making classes without the class construct</a>). However, classes
are technically very different from modules. You can also make many
copies of a class, while there can be only one copy of a module.
When you master both
modules and classes, you will clearly see the similarities and differences.
Now we continue with a specific example of a class.

<p>
Consider the function \( y(t; v_0)=v_0t - \frac{1}{2}gt^2 \).
We may say that \( v_0 \) and \( g \), represented by the variables
<code>v0</code> and <code>g</code>, constitute the data. A Python function,
say <code>value(t)</code>, is needed to compute the value of
\( y(t;v_0) \) and this function
must have access
to the data <code>v0</code> and <code>g</code>, while <code>t</code> is an argument.

<p>
A programmer experienced with classes will then suggest to collect
the data <code>v0</code> and <code>g</code>, and the function <code>value(t)</code>,
together as a class. In addition, a class usually has another function,
called <em>constructor</em> for initializing
the data. The constructor
is always named <code>__init__</code>.
Every class must have a name, often starting with a capital, so we
choose <code>Y</code> as the name since the class represents a mathematical
function with name \( y \).
Figure <a href="#fig:lumpy:classY">1</a> sketches the contents of class <code>Y</code>
as a so-called UML diagram, here created
with aid of the
program <a href="http://tinyurl.com/pwyasaa/class/class_Y_v1_UML.py" target="_self"><tt>class_Y_v1_UML.py</tt></a>.
The UML diagram has two &quot;boxes&quot;, one where the functions are listed,
and one where the variables are listed.
Our next step is to implement this class in Python.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 1:  UML diagram with function and data in the simple class <code>Y</code> for representing a mathematical function \( y(t;v_0) \). <a name="fig:lumpy:classY"></a> </p></center>
<p><img src="fig-class/class_Y_UML.png" align="bottom" width=400></p>
</center>

<h3>Implementation  <a name="___sec5"></a></h3>

The complete code for our
class <code>Y</code> looks as follows in Python:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class Y:
    def __init__(self, v0):
        self.v0 = v0
        self.g = 9.81

    def value(self, t):
        return self.v0*t - 0.5*self.g*t**2
</code></pre>
<!-- end verbatim block -->
A puzzlement for newcomers to Python classes is the <code>self</code>
parameter, which may take some efforts and time to fully understand.
<!-- Just be patient, keep on reading, -->

<h3>Usage and dissection  <a name="___sec6"></a></h3>

Before we dig into what each in the class implementation
means, we start by showing how the class can be used to compute values of
the mathematical function \( y(t;v_0) \).

<p>
A class creates a new data type, here of name <code>Y</code>,
so when we use the class to make
objects, those objects are of type <code>Y</code>. (Actually,
all the standard Python objects, such as
lists, tuples, strings, floating-point numbers, integers,
etc., are built-in
Python classes, with names <code>list</code>, <code>tuple</code>,
<code>str</code>, <code>float</code>,
<code>int</code>, etc.)
An object of a user-defined class (like <code>Y</code>) is usually called
an <em>instance</em>.
We need such an instance in order to use the data in the class and call the
<code>value</code> function.
The following statement constructs an instance bound to the variable
name <code>y</code>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>y = Y(3)
</code></pre>
<!-- end verbatim block -->
Seemingly, we call the class <code>Y</code> as if it were a function.
Actually, <code>Y(3)</code> is automatically translated by Python to
a call to the constructor <code>__init__</code> in class <code>Y</code>.
The arguments in the call, here only the number <code>3</code>,
are always passed on as
arguments to <code>__init__</code> <em>after</em> the <code>self</code>
argument. That is, <code>v0</code> gets the value <code>3</code> and <code>self</code>
is just dropped in the call. This may be confusing, but it is a rule
that the <code>self</code> argument is never used in calls to
functions in classes.

<p>
With the instance <code>y</code>, we can compute the value \( y(t=0.1;v_0=3) \) by the
statement

<p>
<!-- begin verbatim block  pycod-->
<pre><code>v = y.value(0.1)
</code></pre>
<!-- end verbatim block -->
Here also, the <code>self</code> argument is dropped in the call to <code>value</code>.
To access functions and variables in a class, we must prefix the
function and variable names by the name of the instance and a dot:
the <code>value</code> function is reached as <code>y.value</code>, and the
variables are reached as <code>y.v0</code> and <code>y.g</code>. We can, for example,
print the value of <code>v0</code> in the instance <code>y</code> by writing

<p>
<!-- begin verbatim block  pycod-->
<pre><code>print y.v0
</code></pre>
<!-- end verbatim block -->
The output will in this case be <code>3</code>.

<p>
We have already introduced the term "instance'' for the object of a class.
Functions in classes are commonly called <em>methods</em>,
and variables (data) in classes are called
<em>attributes</em>.
From now on we will use this terminology. In our sample class <code>Y</code>
we have two methods, <code>__init__</code> and <code>value</code>, and two
attributes, <code>v0</code> and <code>g</code>.
The names of methods and attributes can be chosen freely, just as
names of ordinary Python functions and variables. However, the constructor
must have the name <code>__init__</code>, otherwise it is not automatically
called when we create new instances.

<p>
You can do whatever you want in whatever method, but it is a
common convention
to use the constructor for initializing the variables in the class.

<h3>The self  variable  <a name="___sec7"></a></h3>

Now we will provide
some more explanation of the <code>self</code> parameter and how the
class methods work. Inside the constructor <code>__init__</code>,
the argument <code>self</code> is a
variable holding the new instance to be constructed.
When we write

<p>
<!-- begin verbatim block  pycod-->
<pre><code>    self.v0 = v0
    self.g = 9.81
</code></pre>
<!-- end verbatim block -->
we define two new attributes in this instance. The <code>self</code> parameter
is invisibly returned to the calling code. We can imagine that Python
translates <code>y = Y(3)</code> to

<p>
<!-- begin verbatim block  pycod-->
<pre><code>Y.__init__(y, 3)
</code></pre>
<!-- end verbatim block -->
so when we do a <code>self.v0 = v0</code> in the constructor, we actually
initialize <code>y.v0</code>. The prefix with <code>Y.</code> is necessary to reach
a class method (just like prefixing a function in a module with the
module name, e.g., <code>math.exp</code>). If we prefix with <code>Y.</code>, we need
to explicitly feed in an instance for the <code>self</code> argument, like
<code>y</code> in the code line above, but
if we prefix with <code>y.</code> (the instance name)
the <code>self</code> argument
is dropped. It is the latter &quot;instance name prefix&quot; which we shall use
when computing with classes.

<p>
Let us look at a call to the <code>value</code> method to see a similar
use of the <code>self</code> argument. When we write

<p>
<!-- begin verbatim block  pycod-->
<pre><code>value = y.value(0.1)
</code></pre>
<!-- end verbatim block -->
Python translates this to a call

<p>
<!-- begin verbatim block  pycod-->
<pre><code>value = Y.value(y, 0.1)
</code></pre>
<!-- end verbatim block -->
such that the <code>self</code> argument in the <code>value</code> method becomes
the <code>y</code> instance. In the expression inside the <code>value</code> method,

<p>
<!-- begin verbatim block  pycod-->
<pre><code>self.v0*t - 0.5*self.g*t**2
</code></pre>
<!-- end verbatim block -->
<code>self</code> is <code>y</code> so this is the same as

<p>
<!-- begin verbatim block  pycod-->
<pre><code>y.v0*t - 0.5*y.g*t**2
</code></pre>
<!-- end verbatim block -->
The rules regarding <code>self</code> are listed below:

<ul>
  <li> Any class method must have <code>self</code> as first argument. (The name can be any valid variable name, but the name <code>self</code> is a widely established convention in Python.)</li>
  <li> <code>self</code> represents an (arbitrary) instance of the class.</li>
  <li> To access another class method or a class attribute, inside class methods, we must prefix with <code>self</code>, as in <code>self.name</code>, where <code>name</code> is the name of the attribute or the other method.</li>
  <li> <code>self</code> is dropped as argument in calls to class methods.</li>
</ul>

It takes some time to understand the <code>self</code> variable, but more
examples and hands-on experience with class programming will help,
so just be patient and continue reading.

<h3>Extension of the class  <a name="___sec8"></a></h3>

We can have as many attributes and methods as we like in a class, so
let us add a new method to class <code>Y</code>. This method is called
<code>formula</code> and prints a string containing the formula of
the mathematical function \( y \). After this formula, we provide the
value of \( v_0 \). The string can then be
constructed as

<p>
<!-- begin verbatim block  pycod-->
<pre><code>'v0*t - 0.5*g*t**2; v0=%g' % self.v0
</code></pre>
<!-- end verbatim block -->
where <code>self</code> is an instance of class <code>Y</code>.
A call of <code>formula</code> does not need any arguments:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>print y.formula()
</code></pre>
<!-- end verbatim block -->
should be enough to create, return, and print the string.
However, even if the <code>formula</code> method does not need any arguments, it
must have a <code>self</code> argument, which is left out in the call
but needed inside the method to access the attributes.
The implementation of the method is therefore

<p>
<!-- begin verbatim block  pycod-->
<pre><code>    def formula(self):
        return 'v0*t - 0.5*g*t**2; v0=%g' % self.v0
</code></pre>
<!-- end verbatim block -->
For completeness, the whole class now reads

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class Y:
    def __init__(self, v0):
        self.v0 = v0
        self.g = 9.81

    def value(self, t):
        return self.v0*t - 0.5*self.g*t**2

    def formula(self):
        return 'v0*t - 0.5*g*t**2; v0=%g' % self.v0
</code></pre>
<!-- end verbatim block -->
Example on use may be

<p>
<!-- begin verbatim block  pycod-->
<pre><code>y = Y(5)
t = 0.2
v = y.value(t)
print 'y(t=%g; v0=%g) = %g' % (t, y.v0, v)
print y.formula()
</code></pre>
<!-- end verbatim block -->
with the output

<p>
<!-- begin verbatim block  ccq-->
<pre><code>y(t=0.2; v0=5) = 0.8038
v0*t - 0.5*g*t**2; v0=5
</code></pre>
<!-- end verbatim block -->

<h3>Remark  <a name="___sec9"></a></h3>

A common mistake done by newcomers to the class construction is to place
the code that applies the class at the same indentation as the class methods.
This is illegal. Only method definitions and assignments to
so-called static attributes
(the section <a href="#sec:class:static">Static methods and attributes</a>) can appear in the indented block under
the <code>class</code> headline.
Ordinary attribute assignment must be done inside methods.
The main program using the class must appear with the same indent as
the <code>class</code> headline.

<h3>Using methods as ordinary functions  <a name="___sec10"></a></h3>

We may create several \( y \) functions with different values of \( v_0 \):

<p>
<!-- begin verbatim block  pycod-->
<pre><code>y1 = Y(1)
y2 = Y(1.5)
y3 = Y(-3)
</code></pre>
<!-- end verbatim block -->
We can treat <code>y1.value</code>, <code>y2.value</code>, and
<code>y3.value</code> as ordinary Python functions of <code>t</code>, and then pass
them on to any Python function that expects a function of one variable.
In particular, we can send the functions to the <code>diff(f, x)</code> function
from the section <a href="#sec:class:func1">Challenge: functions with parameters</a>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>dy1dt = diff(y1.value, 0.1)
dy2dt = diff(y2.value, 0.1)
dy3dt = diff(y3.value, 0.2)
</code></pre>
<!-- end verbatim block -->
Inside the <code>diff(f, x)</code> function, the argument
<code>f</code> now behaves as a function
of one variable that automatically
carries with it two variables <code>v0</code> and <code>g</code>.
When <code>f</code> refers to (e.g.) <code>y3.value</code>, Python actually
knows that <code>f(x)</code>
means <code>y3.value(x)</code>, and inside the <code>y3.value</code> method
<code>self</code> is <code>y3</code>, and we have
access to <code>y3.v0</code> and <code>y3.g</code>.

<h3>Doc strings  <a name="___sec11"></a></h3>

A function may have a doc string right after the
function definition, see the section ref{sec:basic:docstring}.
The aim of the doc string is to explain the purpose of the function
and, for instance, what the arguments and return values are.
A class can also have a doc string, it is just the first string that
appears right after the <code>class</code> headline.
The convention is to enclose the doc string in triple double quotes <code>"""</code>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class Y:
    &quot;&quot;&quot;The vertical motion of a ball.&quot;&quot;&quot;

    def __init__(self, v0):
        ...
</code></pre>
<!-- end verbatim block -->
More comprehensive information can include the methods and how the
class is used in an interactive session:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class Y:
    &quot;&quot;&quot;
    Mathematical function for the vertical motion of a ball.

    Methods:
       constructor(v0): set initial velocity v0.
       value(t): compute the height as function of t.
       formula(): print out the formula for the height.

    Attributes:
       v0: the initial velocity of the ball (time 0).
       g: acceleration of gravity (fixed).

    Usage:
    &gt;&gt;&gt; y = Y(3)
    &gt;&gt;&gt; position1 = y.value(0.1)
    &gt;&gt;&gt; position2 = y.value(0.3)
    &gt;&gt;&gt; print y.formula()
    v0*t - 0.5*g*t**2; v0=3
    &quot;&quot;&quot;
</code></pre>
<!-- end verbatim block -->

<h2>Another function class example <a name="sec:class:func3"></a></h2>

Let us apply the ideas from the <code>Y</code> class to the function

$$
\begin{equation*}
v(r) = \left({\beta\over 2\mu_0}\right)^{{1/ n}}
{n \over n+1}\left( R^{1 + 1/n} - r^{1 + 1/n}\right) ,
\end{equation*}
$$

where \( r \) is the independent variable.
We may write this function as \( v(r; \beta,\mu_0,n,R) \) to
explicitly indicate that
there is one primary independent variable (\( r \)) and four physical
parameters \( \beta \), \( \mu_0 \), \( n \), and \( R \).
ref{sec:plot:ex4} describes a physical interpretation of
\( v \) as the velocity of a fluid.
The class typically holds
the physical parameters as variables and provides an <code>value(r)</code> method
for computing the \( v \) function:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class V:
    def __init__(self, beta, mu0, n, R):
        self.beta, self.mu0, self.n, self.R = beta, mu0, n, R

    def value(self, r):
        beta, mu0, n, R = self.beta, self.mu0, self.n, self.R
        n = float(n)  # ensure float divisions
        v = (beta/(2.0*mu0))**(1/n)*(n/(n+1))*\ 
            (R**(1+1/n) - r**(1+1/n))
        return v
</code></pre>
<!-- end verbatim block -->
There is seemingly
one new thing here in that we initialize several variables on the
same line:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>        self.beta, self.mu0, self.n, self.R = beta, mu0, n, R
</code></pre>
<!-- end verbatim block -->
The comma-separated list of variables on the right-hand
side forms a tuple so this assignment is just the a valid construction where
a set of variables on the left-hand side is set equal to a list or tuple
on the right-hand side, element by element. An
equivalent multi-line code is

<p>
<!-- begin verbatim block  pycod-->
<pre><code>        self.beta = beta
        self.mu0 = mu0
        self.n = n
        self.R = R
</code></pre>
<!-- end verbatim block -->
In the <code>value</code> method it is convenient to avoid the
<code>self.</code> prefix in the mathematical formulas and instead introduce
the local short names <code>beta</code>, <code>mu0</code>, <code>n</code>, and <code>R</code>.
This is in general a good idea, because it makes it easier to read the
implementation of the formula and check its correctness.

<h3>Remark  <a name="___sec13"></a></h3>

Another solution to the problem of sending functions with parameters
to a general library function such as <code>diff</code> is provided in
the document <a href="http://tcse6.on.net/varargs" target="_self">Variable number of
function arguments in Python</a>
<a href="#Langtangen_TCSE6_varargs">[2]</a>. The remedy there is to transfer the
parameters as arguments &quot;through&quot; the <code>diff</code> function.  This can be
done in a general way as explained in that appendix.

<h2>Alternative function class implementations <a name="sec:class:func2b"></a></h2>

To illustrate class programming further, we will now realize class
<code>Y</code> from the section <a href="#sec:class:func2">Representing a function as a class</a> in a different way.
You may consider this section as advanced and skip it, but for
some readers the material might improve the understanding of
class <code>Y</code> and give some insight into
class programming in general.

<p>
It is a good habit always to have a constructor in a class and to
initialize class attributes here, but this is not a requirement.
Let us drop the constructor and make <code>v0</code> an optional
argument to the <code>value</code> method. If the user does not provide
<code>v0</code> in the call to <code>value</code>, we use a <code>v0</code> value that must have
been provided
in an earlier call and stored as an attribute <code>self.v0</code>.
We can recognize if the user provides <code>v0</code> as argument or
not by using <code>None</code> as default value for the keyword argument
and then test if <code>v0 is None</code>.

<p>
Our alternative implementation of class <code>Y</code>, named <code>Y2</code>, now reads

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class Y2:
    def value(self, t, v0=None):
        if v0 is not None:
            self.v0 = v0
        g = 9.81
        return self.v0*t - 0.5*g*t**2
</code></pre>
<!-- end verbatim block -->
This time the class has only one method and one attribute as we
skipped the constructor and let <code>g</code> be a local variable in
the <code>value</code> method.

<p>
But if there is no constructor, how is an instance created?
Python fortunately creates an empty constructor. This allows us to write

<p>
<!-- begin verbatim block  pycod-->
<pre><code>y = Y2()
</code></pre>
<!-- end verbatim block -->
to make an instance <code>y</code>. Since nothing happens in the automatically
generated empty constructor, <code>y</code> has no attributes at this stage.
Writing

<p>
<!-- begin verbatim block  pycod-->
<pre><code>print y.v0
</code></pre>
<!-- end verbatim block -->
therefore leads to the exception

<p>
<!-- begin verbatim block  pycod-->
<pre><code>AttributeError: Y2 instance has no attribute 'v0'
</code></pre>
<!-- end verbatim block -->
By calling

<p>
<!-- begin verbatim block  pycod-->
<pre><code>v = y.value(0.1, 5)
</code></pre>
<!-- end verbatim block -->
we create an attribute <code>self.v0</code> inside the <code>value</code> method.
In general, we can create any attribute <code>name</code> in any method by just assigning
a value to <code>self.name</code>. Now trying a

<p>
<!-- begin verbatim block  pycod-->
<pre><code>print y.v0
</code></pre>
<!-- end verbatim block -->
will print <code>5</code>.
In a new call,

<p>
<!-- begin verbatim block  pycod-->
<pre><code>v = y.value(0.2)
</code></pre>
<!-- end verbatim block -->
the previous <code>v0</code> value (<code>5</code>) is used inside <code>value</code> as
<code>self.v0</code> unless a <code>v0</code> argument is specified in the call.

<p>
The previous implementation is not foolproof if we fail to initialize
<code>v0</code>. For example, the code

<p>
<!-- begin verbatim block  pycod-->
<pre><code>y = Y2()
v = y.value(0.1)
</code></pre>
<!-- end verbatim block -->
will terminate in the <code>value</code> method with the exception

<p>
<!-- begin verbatim block  pycod-->
<pre><code>AttributeError: Y2 instance has no attribute 'v0'
</code></pre>
<!-- end verbatim block -->
As usual, it is better to notify the user with a more informative message.
To check if we have an attribute <code>v0</code>, we can use the Python
function <code>hasattr</code>. Calling <code>hasattr(self, 'v0')</code> returns
<code>True</code> only if the instance <code>self</code> has an attribute
with name <code>'v0'</code>. An improved <code>value</code> method now reads

<p>
<!-- begin verbatim block  pycod-->
<pre><code>    def value(self, t, v0=None):
        if v0 is not None:
            self.v0 = v0
        if not hasattr(self, 'v0'):
            print 'You cannot call value(t) without first '\ 
                  'calling value(t,v0) to set v0'
            return None
        g = 9.81
        return self.v0*t - 0.5*g*t**2
</code></pre>
<!-- end verbatim block -->
Alternatively, we can try to
access <code>self.v0</code> in a <code>try-except</code> block, and
perhaps raise an exception <code>TypeError</code> (which is what Python raises if
there are not enough arguments to a function or method):

<p>
<!-- begin verbatim block  pycod-->
<pre><code>    def value(self, t, v0=None):
        if v0 is not None:
            self.v0 = v0
        g = 9.81
        try:
            value = self.v0*t - 0.5*g*t**2
        except AttributeError:
            msg = 'You cannot call value(t) without first '
                  'calling value(t,v0) to set v0'
            raise TypeError(msg)
        return value
</code></pre>
<!-- end verbatim block -->
Note that Python detects an <code>AttributeError</code>, but from a user's
point of view, not enough parameters were supplied in the call so
a <code>TypeError</code> is more appropriate to communicate back to the
calling code.

<p>
We think class <code>Y</code> is a better implementation than class <code>Y2</code>,
because the former is simpler. As already mentioned, it
is a good habit to include
a constructor and set data here rather than "recording data on the fly"
as we try to in class <code>Y2</code>. The whole purpose of class <code>Y2</code>
is just to show that Python provides great flexibility with respect
to defining attributes, and that there are no requirements to what
a class <em>must</em> contain.

<h2>Making classes without the class construct <a name="sec:class:whatis"></a></h2>

Newcomers to the class concept often have a hard time understanding
what this concept is about.  The present section tries to explain in
more detail how we can introduce classes without having the
class construct in the computer language.
This information may or may
not increase your understanding of classes.  If not, programming
with classes will definitely increase your understanding with time, so
there is no reason to worry.  In fact, you may safely jump to
the section <a href="#sec:class:specialmethods">Special methods</a> as there are no
important concepts in this section that later sections build upon.

<p>
A class contains a collection of variables (data) and a collection
of methods (functions). The collection of variables is unique to each
instance of the class. That is, if we make ten instances, each of them
has its own set of variables. These variables can be thought of as
a dictionary with keys equal to the variable names. Each instance
then has its own dictionary, and we may roughly view the instance
as this
dictionary. (The instance can also contain static class attributes
(the section <a href="#sec:class:static">Static methods and attributes</a>), but these are to be viewed as global
variables in the present context.)

<p>
On the other hand, the methods are shared
among the instances. We may think of a method in a class
as a standard global
function that takes an instance in the form of a dictionary
as first
argument. The method has then access to the variables in the instance
(dictionary) provided in the call.
For the <code>Y</code> class from the section <a href="#sec:class:func2">Representing a function as a class</a>
and an instance <code>y</code>,
the methods are ordinary
functions with the following names and arguments:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>Y.value(y, t)
Y.formula(y)
</code></pre>
<!-- end verbatim block -->
The class acts as a <em>namespace</em>,
meaning that all functions
must be prefixed by the namespace name, here <code>Y</code>.
Two different classes, say <code>C1</code> and <code>C2</code>, may have functions
with the same name, say <code>value</code>, but when the <code>value</code> functions
belong to different namespaces, their names <code>C1.value</code> and
<code>C2.value</code> become distinct.
Modules are also namespaces for the functions and variables in them
(think of <code>math.sin</code>, <code>cmath.sin</code>, <code>numpy.sin</code>).

<p>
The only peculiar thing with the class construct in Python is that
it allows us to use an alternative syntax for method calls:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>y.value(t)
y.formula()
</code></pre>
<!-- end verbatim block -->
This syntax coincides with the traditional syntax of calling class
methods and providing arguments, as found in other computer languages,
such as Java, C#, C++, Simula, and Smalltalk.
The dot notation is also used to access variables in an instance
such that we inside a method can write <code>self.v0</code> instead of
<code>self['v0']</code> (<code>self</code> refers to <code>y</code> through the function call).

<p>
We could easily
implement a simple version of the class concept without having a class
construction in the language. All we need is a dictionary type and
ordinary functions. The dictionary acts as the instance, and methods are
functions that take this dictionary as the first argument such that
the function has access to
all the variables in the instance.
Our <code>Y</code> class could now be implemented as

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def value(self, t):
    return self['v0']*t - 0.5*self['g']*t**2

def formula(self):
    print 'v0*t - 0.5*g*t**2; v0=%g' % self['v0']
</code></pre>
<!-- end verbatim block -->
The two functions are placed in a module called <code>Y</code>.
The usage goes as follows:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import Y
y = {'v0': 4, 'g': 9.81}   # make an &quot;instance&quot;
y1 = Y.value(y, t)
</code></pre>
<!-- end verbatim block -->
We have no constructor since the initialization of the variables is
done when declaring the dictionary <code>y</code>, but we could well include
some initialization function in the <code>Y</code> module

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def init(v0):
    return {'v0': v0, 'g': 9.81}
</code></pre>
<!-- end verbatim block -->
The usage is now slightly different:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import Y
y = Y.init(4)       # make an &quot;instance&quot;
y1 = Y.value(y, t)
</code></pre>
<!-- end verbatim block -->

<p>
This way of implementing classes with the aid of a dictionary and
a set of ordinary functions actually forms the basis for class implementations
in many languages. Python and Perl even
have a syntax that demonstrates this type of
implementation. In fact, every class instance in Python has a dictionary
<code>__dict__</code> as attribute, which holds all the
variables in the instance. Here is a demo that proves the existence of this
dictionary in class <code>Y</code>:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; y = Y(1.2)
&gt;&gt;&gt; print y.__dict__
{'v0': 1.2, 'g': 9.8100000000000005}
</code></pre>
<!-- end verbatim block -->

<p>
To summarize: A Python class can be thought of as some variables collected
in a dictionary, and a set of functions where this dictionary is automatically
provided as first argument such that functions always have full access to
the class variables.

<h3>First remark  <a name="___sec16"></a></h3>

 We have in this section provided a view of
classes <em>from a technical point of view</em>. Others may view a class
as a way of modeling the world in terms of data and operations on
data.  However, in sciences that employ the language of mathematics,
the modeling of the world is usually done by mathematics, and the
mathematical structures provide understanding of the problem and
structure of programs. When appropriate, mathematical structures can
conveniently be mapped on to classes in programs to make the software
simpler and more flexible.

<h3>Second remark  <a name="___sec17"></a></h3>

The view of classes in this section neglects very important topics
such as inheritance and dynamic binding
(explained in the document <a href="http://tcse6.on.net/oo" target="_self">Object-oriented programming</a> <a href="#Langtangen_TCSE6_oo">[1]</a>).
For more completeness of the present section,
we therefore briefly describe how our combination of dictionaries and global
functions can deal with inheritance and dynamic binding
(but this will not make sense unless you know what
inheritance is).

<p>
Data inheritance can be obtained by letting a subclass dictionary
do an <code>update</code> call with the superclass dictionary as argument.
In this way all data in the superclass are also available in the
subclass dictionary. Dynamic binding of methods is more complicated, but
one can think of checking if the method is in the subclass module
(using <code>hasattr</code>), and if not, one proceeds with checking super
class modules until a version of the method is found.

<h1>More examples on classes <a name="sec:class:addex"></a></h1>

The use of classes to solve problems from
mathematical and physical sciences may not be
so obvious. On the other hand, in
many administrative programs for managing
interactions between objects in the real world the objects
themselves are
natural candidates for being modeled by classes.
Below we give some examples on what classes can be used to model.

<h2>Bank accounts <a name="sec:class:account"></a></h2>

The concept of a bank account in a program is a good candidate for a
class.  The account has some data, typically the name of the account
holder, the account number, and the current balance.  Three things we
can do with an account is withdraw money, put money into the account,
and print out the data of the account.  These actions are modeled by
methods.  With a class we can pack the data and actions together into
a new data type so that one account corresponds to one variable in a
program.

<p>
Class <code>Account</code> can be implemented as follows:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class Account:
    def __init__(self, name, account_number, initial_amount):
        self.name = name
        self.no = account_number
        self.balance = initial_amount

    def deposit(self, amount):
        self.balance += amount

    def withdraw(self, amount):
        self.balance -= amount

    def dump(self):
        s = '%s, %s, balance: %s' % \ 
            (self.name, self.no, self.balance)
        print s
</code></pre>
<!-- end verbatim block -->

<p>
Here is a simple test of how class <code>Account</code> can be used:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; from classes import Account
&gt;&gt;&gt; a1 = Account('John Olsson', '19371554951', 20000)
&gt;&gt;&gt; a2 = Account('Liz Olsson',  '19371564761', 20000)
&gt;&gt;&gt; a1.deposit(1000)
&gt;&gt;&gt; a1.withdraw(4000)
&gt;&gt;&gt; a2.withdraw(10500)
&gt;&gt;&gt; a1.withdraw(3500)
&gt;&gt;&gt; print &quot;a1's balance:&quot;, a1.balance
a1's balance: 13500
&gt;&gt;&gt; a1.dump()
John Olsson, 19371554951, balance: 13500
&gt;&gt;&gt; a2.dump()
Liz Olsson, 19371564761, balance: 9500
</code></pre>
<!-- end verbatim block -->

<p>
The author of this class does not want users of the class to operate
on the attributes directly and thereby change the name, the account
number, or the balance. The intention is that users of the class
should only call the constructor, the <code>deposit</code>, <code>withdraw</code>, and
<code>dump</code> methods, and (if desired) inspect the <code>balance</code> attribute, but
never change it. Other languages with class support usually have
special keywords that can restrict access to class attributes and
methods, but Python does not. Either the author of a Python class has
to rely on correct usage, or a special convention can be used: any
name starting with an underscore represents an attribute that should
never be touched or a method that should never be called.  One refers
to names starting with an underscore as <em>protected</em> names. These can
be freely used inside methods in the class, but not outside.

<p>
In class <code>Account</code>, it is natural to protect access to the <code>name</code>,
<code>no</code>, and <code>balance</code> attributes by prefixing these names by an
underscore. For <em>reading</em> only of the <code>balance</code> attribute, we provide
a new method <code>get_balance</code>. The user of the class should now only call
the methods in the class and not access any attributes.

<p>
The new "protected" version of class <code>Account</code>, called
<code>AccountP</code>, reads

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class AccountP:
    def __init__(self, name, account_number, initial_amount):
        self._name = name
        self._no = account_number
        self._balance = initial_amount

    def deposit(self, amount):
        self._balance += amount

    def withdraw(self, amount):
        self._balance -= amount

    def get_balance(self):
        return self._balance

    def dump(self):
        s = '%s, %s, balance: %s' % \ 
            (self._name, self._no, self._balance)
        print s
</code></pre>
<!-- end verbatim block -->

<p>
We can technically access the attributes, but we then break the
convention that names starting with an underscore should never
be touched outside the class. Here is class <code>AccountP</code> in action:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; a1 = AccountP('John Olsson', '19371554951', 20000)
&gt;&gt;&gt; a1.deposit(1000)
&gt;&gt;&gt; a1.withdraw(4000)
&gt;&gt;&gt; a1.withdraw(3500)
&gt;&gt;&gt; a1.dump()
John Olsson, 19371554951, balance: 13500
&gt;&gt;&gt; print a1._balance       # it works, but a convention is broken
13500
print a1.get_balance()      # correct way of viewing the balance
13500
&gt;&gt;&gt; a1._no = '19371554955'  # this is a &quot;serious crime&quot;
</code></pre>
<!-- end verbatim block -->
Python has a special construct, called <em>properties</em>, that can
be used to protect attributes from being changed. This is very useful,
but the author considers properties a bit too complicated for this
introductory book.

<p>
<!-- We remark that users of Python classes tend to access attributes (without -->
<!-- a leading underscore) directly, while in other languages, such as -->
<!-- C++, Java, and C#, developers are strongly encouraged to read an -->
<!-- attribute <code>X</code> by a <code>get_X()</code> method and to change the -->
<!-- attribute by a <code>set_X(X)</code> method. -->

<h2>Phone book <a name="sec:class:phonebook"></a></h2>

You are probably familiar with the phone book on your mobile phone.
The phone book contains a list of persons. For each person you can
record the name, telephone numbers, email address, and perhaps other
relevant data.  A natural way of representing such personal data in a
program is to create a class, say class <code>Person</code>. The attributes of
the class holds data like the name, mobile phone number, office phone
number, private phone number, and email address.  The constructor may
initialize some of the data about a person.  Additional data can be
specified later by calling methods in the class.  One method can print
the data. Other methods can register additional telephone numbers and
an email address. In addition we initialize some of the attributes in
a constructor method. The attributes that are not initialized when
constructing a <code>Person</code> instance can be added later by calling
appropriate methods. For example, adding an office number is done by
calling <code>add_office_number</code>.

<p>
Class <code>Person</code> may look as

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class Person:
    def __init__(self, name,
                 mobile_phone=None, office_phone=None,
                 private_phone=None, email=None):
        self.name = name
        self.mobile = mobile_phone
        self.office = office_phone
        self.private = private_phone
        self.email = email

    def add_mobile_phone(self, number):
        self.mobile = number

    def add_office_phone(self, number):
        self.office = number

    def add_private_phone(self, number):
        self.private = number

    def add_email(self, address):
        self.email = address
</code></pre>
<!-- end verbatim block -->
Note the use of <code>None</code> as default value for various attributes: the
object <code>None</code> is commonly used to indicate that a variable or
attribute is defined, but yet not with a sensible value.

<p>
A quick demo session of class <code>Person</code> may go as follows:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; p1 = Person('Hans Hanson',
...             office_phone='767828283', email='h@hanshanson.com')
&gt;&gt;&gt; p2 = Person('Ole Olsen', office_phone='767828292')
&gt;&gt;&gt; p2.add_email('olsen@somemail.net')
&gt;&gt;&gt; phone_book = [p1, p2]
</code></pre>
<!-- end verbatim block -->
It can be handy to add a method for printing the contents of
a <code>Person</code> instance in a nice fashion:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class Person:
    ...
    def dump(self):
        s = self.name + '\n'
        if self.mobile is not None:
            s += 'mobile phone:   %s\n' % self.mobile
        if self.office is not None:
            s += 'office phone:   %s\n' % self.office
        if self.private is not None:
            s += 'private phone:  %s\n' % self.private
        if self.email is not None:
            s += 'email address:  %s\n' % self.email
        print s
</code></pre>
<!-- end verbatim block -->
With this method we can easily print the phone book:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; for person in phone_book:
...     person.dump()
...
Hans Hanson
office phone:   767828283
email address:  h@hanshanson.com

Ole Olsen
office phone:   767828292
email address:  olsen@somemail.net
</code></pre>
<!-- end verbatim block -->

<p>
A phone book can be a list of <code>Person</code> instances, as indicated in the
examples above. However, if we quickly want to look up the phone
numbers or email address for a given name, it would be more convenient
to store the <code>Person</code> instances in a dictionary with the name
as key:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; phone_book = {'Hanson': p1, 'Olsen': p2}
&gt;&gt;&gt; for person in sorted(phone_book):  # alphabetic order
...     phone_book[person].dump()
</code></pre>
<!-- end verbatim block -->
The current example of <code>Person</code> objects is extended in
the section <a href="#sec:class:phonebook2">Example: Phone book with special methods</a>.

<h2>A circle <a name="sec:class:circle"></a></h2>

Geometric figures, such as a circle, are other candidates for classes
in a program. A circle is uniquely defined by its center point
\( (x_0,y_0) \) and its radius \( R \). We can collect these three numbers
as attributes in a class. The values of \( x_0 \), \( y_0 \), and \( R \) are
naturally initialized in the constructor. Other methods can be
<code>area</code> and <code>circumference</code> for calculating the area
\( \pi R^2 \) and the circumference \( 2\pi R \):

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class Circle:
    def __init__(self, x0, y0, R):
        self.x0, self.y0, self.R = x0, y0, R

    def area(self):
        return pi*self.R**2

    def circumference(self):
        return 2*pi*self.R
</code></pre>
<!-- end verbatim block -->

<p>
An example of using class <code>Circle</code> goes as follows:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; c = Circle(2, -1, 5)
&gt;&gt;&gt; print 'A circle with radius %g at (%g, %g) has area %g' % \ 
...       (c.R, c.x0, c.y0, c.area())
A circle with radius 5 at (2, -1) has area 78.5398
</code></pre>
<!-- end verbatim block -->

<p>
The ideas of class <code>Circle</code> can be applied to other geometric
objects as well: rectangles, triangles, ellipses, boxes, spheres, etc.
<a href="#sec:class:ex23">Exercise 4: Make classes for a rectangle and a triangle</a> tests if you are able to adapt class
<code>Circle</code> to a rectangle and a triangle.

<h3>Verification  <a name="___sec22"></a></h3>

We should include a test function for checking that the implementation
of class <code>Circle</code> is correct:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def test_Circle():
    R = 2.5
    c = Circle(7.4, -8.1, R)
    from math import pi
    area = pi*R**2; circumference = 2*pi*R
    diff = abs(c.area() - area)
    tol = 1E-14
    assert diff &lt; tol, 'bug in Circle.area, diff=%s' % diff
    diff = abs(c.circumference() - circumference)
    assert diff &lt; tol, 'bug in Circle.circumference, diff=%s' % diff
</code></pre>
<!-- end verbatim block -->
The <code>test_Circle</code> function is written in a way that it can be used
in a pytest or nose testing
framework (see the section ref{sec:nose}, or the brief examples
in the sections ref{bioinf:count:verify}, ref{sec:funcif:summary:ex}, and
ref{sec:input:modules:testfunc}).
The necessary conventions
are that the function name starts
with <code>test_</code>, the function takes no arguments, and all tests
are of the form <code>assert success</code> or <code>assert success, msg</code> where
<code>success</code> is a boolean condition for the test and <code>msg</code> is an
optional message to be written if the test fails (<code>success</code> is
<code>False</code>). It is a good habit to write such test functions to
verify the implementation of classes.

<h3>Remark  <a name="___sec23"></a></h3>

There are usually many solutions to a programming problem.
Representing a circle
is no exception. Instead of using a class, we could collect
\( x_0 \), \( y_0 \), and \( R \) in a list and create global functions
<code>area</code> and <code>circumference</code> that take such a list as argument:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>x0, y0, R = 2, -1, 5
circle = [x0, y0, R]

def area(c):
    R = c[2]
    return pi*R**2

def circumference(c):
    R = c[2]
    return 2*pi*R
</code></pre>
<!-- end verbatim block -->
Alternatively, the circle could be represented by a dictionary with
keys <code>'center'</code> and <code>'radius'</code>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>circle = {'center': (2, -1), 'radius': 5}

def area(c):
    R = c['radius']
    return pi*R**2

def circumference(c):
    R = c['radius']
    return 2*pi*R
</code></pre>
<!-- end verbatim block -->

<h1>Special methods <a name="sec:class:specialmethods"></a></h1>

Some class methods have names starting and ending with a double
underscore.  These methods allow a special syntax in the program and
are called <em>special methods</em>.  The constructor <code>__init__</code> is one
example. This method is automatically called when an instance is
created (by calling the class as a function), but we do not need to
explicitly write <code>__init__</code>.  Other special methods make it possible
to perform arithmetic operations with instances, to compare instances
with <code>></code>, <code>>=</code>, <code>!=</code>, etc., to call instances as we call ordinary
functions, and to test if an instance evaluates to <code>True</code> or <code>False</code>,
to mention some possibilities.

<h2>The call special method <a name="sec:class:call"></a></h2>

Computing the value of the mathematical function represented by class
<code>Y</code> from the section <a href="#sec:class:func2">Representing a function as a class</a>, with <code>y</code> as the name of the
instance, is performed by writing <code>y.value(t)</code>.  If we could write
just <code>y(t)</code>, the <code>y</code> instance would look as an ordinary function. Such
a syntax is indeed possible and offered by the special method named
<code>__call__</code>. Writing <code>y(t)</code> implies a call

<p>
<!-- begin verbatim block  pycod-->
<pre><code>y.__call__(t)
</code></pre>
<!-- end verbatim block -->
if class <code>Y</code> has the method <code>__call__</code> defined.
We may easily add this special method:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class Y:
    ...
    def __call__(self, t):
        return self.v0*t - 0.5*self.g*t**2
</code></pre>
<!-- end verbatim block -->
The previous <code>value</code> method is now redundant.  A good programming
convention is to include a <code>__call__</code> method in all classes that
represent a mathematical function.  Instances with <code>__call__</code> methods
are said to be <em>callable</em> objects, just as plain functions are
callable objects as well. The call syntax for callable objects is the
same, regardless of whether the object is a function or a class
instance.  Given an object <code>a</code>,

<p>
<!-- begin verbatim block  pycod-->
<pre><code>if callable(a):
</code></pre>
<!-- end verbatim block -->
tests whether <code>a</code> behaves as a callable, i.e., if <code>a</code>
is a Python function or an instance with a <code>__call__</code>
method.
<!-- isinstance(a, collections.Callable) for v3.0 and 3.1, but -->
<!-- callable is back in 3.2 -->

<p>
In particular, an instance of class <code>Y</code> can be passed as the
<code>f</code> argument to the <code>diff</code> function from the section <a href="#sec:class:func1">Challenge: functions with parameters</a>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>y = Y(v0=5)
dydt = diff(y, 0.1)
</code></pre>
<!-- end verbatim block -->
Inside <code>diff</code>, we can test that <code>f</code> is not a function but an
instance of class <code>Y</code>. However, we only use <code>f</code> in calls, like
<code>f(x)</code>, and for this purpose an instance with a
<code>__call__</code> method works as a plain function.
This feature is very convenient.

<p>
The next section demonstrates a neat application of the call
operator <code>__call__</code> in a numerical algorithm.

<h2>Example: Automagic differentiation <a name="sec:class:autodF"></a></h2>

<h3>Problem  <a name="___sec27"></a></h3>

Given a Python implementation <code>f(x)</code> of a mathematical function
\( f(x) \), we want to create an object that behaves as a Python function
for computing the derivative \( f'(x) \). For example, if this object is
of type <code>Derivative</code>, we should be able to write something like

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; def f(x):
        return x**3
...
&gt;&gt;&gt; dfdx = Derivative(f)
&gt;&gt;&gt; x = 2
&gt;&gt;&gt; dfdx(x)
12.000000992884452
</code></pre>
<!-- end verbatim block -->
That is, <code>dfdx</code> behaves as a straight Python function for implementing
the derivative \( 3x^2 \) of \( x^3 \) (well, the answer is only approximate,
with an error in the 7th decimal,
but the approximation can easily be improved).

<p>
Maple, Mathematica, and many other software packages can do exact
symbolic mathematics, including differentiation and integration.  The
Python package <code>sympy</code> for symbolic mathematics
(see the section ref{sec:formula:sympy})
makes it trivial to calculate the exact derivative of
a large class of functions \( f(x) \) and turn the result into
an ordinary Python function. However, mathematical functions that are defined
in an algorithmic way (e.g., solution of another mathematical
problem), or functions with branches, random numbers, etc., pose
fundamental problems to symbolic differentiation, and then numerical
differentiation is required. Therefore we base the computation of
derivatives in <code>Derivative</code> instances on finite difference
formulas. Use of exact symbolic differentiation is also possible
as indicated in <a href="#sec:class:exer:sympy:diff">Exercise 14: Apply symbolic differentiation</a>.

<h3>Solution  <a name="___sec28"></a></h3>

The most basic (but not the best) formula for a numerical derivative is

$$
\begin{equation}
f'(x)\approx {f(x+h)-f(x)\over h}\tp
\tag{2}
\end{equation}
$$

The idea is that we make a class to hold the function to be
differentiated, call it <code>f</code>, and a step size <code>h</code> to be used in
<a href="#mjx-eqn-2">(2)</a>.
These variables can be set in the
constructor.  The <code>__call__</code> operator computes the derivative with aid
of <a href="#mjx-eqn-1">(1)</a>.  All this can be
coded in a few lines:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class Derivative:
    def __init__(self, f, h=1E-5):
        self.f = f
        self.h = float(h)

    def __call__(self, x):
        f, h = self.f, self.h      # make short forms
        return (f(x+h) - f(x))/h
</code></pre>
<!-- end verbatim block -->
Note that we turn <code>h</code> into a <code>float</code> to avoid
potential integer division.

<p>
Below follows an application of the class to differentiate two
functions \( f(x)=\sin x \)
and \( g(t)=t^3 \):

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; from math import sin, cos, pi
&gt;&gt;&gt; df = Derivative(sin)
&gt;&gt;&gt; x = pi
&gt;&gt;&gt; df(x)
-1.000000082740371
&gt;&gt;&gt; cos(x)  # exact
-1.0
&gt;&gt;&gt; def g(t):
...     return t**3
...
&gt;&gt;&gt; dg = Derivative(g)
&gt;&gt;&gt; t = 1
&gt;&gt;&gt; dg(t)  # compare with 3 (exact)
3.000000248221113
</code></pre>
<!-- end verbatim block -->
The expressions <code>df(x)</code> and <code>dg(t)</code>
look as ordinary Python functions that
evaluate the derivative of the functions <code>sin(x)</code> and <code>g(t)</code>.
Class <code>Derivative</code> works for (almost) any function \( f(x) \).

<h3>Verification  <a name="___sec29"></a></h3>

It is a good programming habit to include a test function for
verifying the implementation of a class.
We can construct a test based on the fact that the
approximate differentiation formula <a href="#mjx-eqn-2">(2)</a>
is exact for linear functions:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def test_Derivative():
    # The formula is exact for linear functions, regardless of h
    f = lambda x: a*x + b
    a = 3.5; b = 8
    dfdx = Derivative(f, h=0.5)
    diff = abs(dfdx(4.5) - a)
    assert diff &lt; 1E-14, 'bug in class Derivative, diff=%s' % diff
</code></pre>
<!-- end verbatim block -->
We have here used a lambda function for compactly defining a function
<code>f</code>, see the section ref{sec:basic:lambdafunc}.
A special feature of <code>f</code> is that it remembers the variables <code>a</code> and
<code>b</code> when <code>f</code> is sent to class <code>Derivative</code> (such a function  is called a
<em>closure</em>).
Note that the test function above follows
the conventions for test functions
outlined in the section <a href="#sec:class:circle">A circle</a>.

<h3>Application: Newton's method  <a name="___sec30"></a></h3>

In what situations will it be convenient to automatically produce a
Python function <code>df(x)</code> which is the derivative of another Python
function <code>f(x)</code>? One example arises when solving nonlinear algebraic
equations \( f(x)=0 \) with Newton's method and we, because of laziness,
lack of time, or lack of training do not manage to derive \( f'(x) \) by
hand. Consider a function <code>Newton</code> for solving \( f(x)=0 \): <code>Newton(f, x,
dfdx, epsilon=1.0E-7, N=100)</code>.
The section ref{sec:diffeq:Newtonsmethod:sec} presents a specific implementation
in a module file
<a href="http://tinyurl.com/pwyasaa/diffeq/Newton.py" target="_self"><tt>Newton.py</tt></a>.  The arguments are a
Python function <code>f</code> for \( f(x) \), a <code>float x</code> for the initial guess
(start value) of \( x \), a Python function <code>dfdx</code> for \( f'(x) \), a <code>float</code>
<code>epsilon</code> for the accuracy \( \epsilon \) of the root: the algorithms
iterates until \( |f(x)| < \epsilon \), and an <code>int N</code> for the maximum
number of iterations that we allow.  All arguments are easy to
provide, except <code>dfdx</code>, which requires computing \( f'(x) \) by hand then
implementation of the formula in a Python function.  Suppose our
target equation reads

$$
\begin{equation*}
f(x) =  10^5(x-0.9)^2(x-1.1)^3=0 \thinspace .
\end{equation*}
$$

The function \( f(x) \) is plotted in Figure
<a href="#fig:hard_polynomial4Newton1">2</a>.  The following session employs the
<code>Derivative</code> class to quickly make a derivative so we can call
Newton's method:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; from classes import Derivative
&gt;&gt;&gt; from Newton import Newton
&gt;&gt;&gt; def f(x):
...     return 100000*(x - 0.9)**2 * (x - 1.1)**3
...
&gt;&gt;&gt; df = Derivative(f)
&gt;&gt;&gt; Newton(f, 1.01, df, epsilon=1E-5)
(1.0987610068093443, 8, -7.5139644257961411e-06)
</code></pre>
<!-- end verbatim block -->
The output 3-tuple holds the approximation to a root, the number of
iterations, and the value of \( f \) at the approximate root (a measure of
the error in the equation).

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 2:  Plot of \( y = 10^5(x-0.9)^2(x-1.1)^3 \). <a name="fig:hard_polynomial4Newton1"></a> </p></center>
<p><img src="fig-class/hard_polynomial4Newton1.png" align="bottom" width=400></p>
</center>

<p>
The exact root is 1.1, and the convergence toward this value is very
slow. (Newton's method converges very slowly when the derivative of
\( f \) is zero at the roots of \( f \). Even slower convergence appears when
higher-order derivatives also are zero, like in this example. Notice
that the error in <code>x</code> is much larger than the error in the equation
(<code>epsilon</code>).  For example, an <code>epsilon</code> tolerance of \( 10^{-10} \)
requires 18 iterations with an error of \( 10^{-3} \).)  Using an exact
derivative gives almost the same result:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; def df_exact(x):
...     return 100000*(2*(x-0.9)*(x-1.1)**3 + \ 
...                    (x-0.9)**2*3*(x-1.1)**2)
...
&gt;&gt;&gt; Newton(f, 1.01, df_exact, epsilon=1E-5)
(1.0987610065618421, 8, -7.5139689100699629e-06)
</code></pre>
<!-- end verbatim block -->
This example indicates that there are hardly any drawbacks in using a
"smart" inexact general differentiation approach as in the
<code>Derivative</code> class. The advantages are many - most notably,
<code>Derivative</code> avoids potential errors from possibly incorrect manual
coding of possibly lengthy expressions of possibly wrong
hand-calculations.  The errors in the involved approximations can be
made smaller, usually much smaller than other errors, like the
tolerance in Newton's method in this example or the uncertainty in
physical parameters in real-life problems.

<h2>Example: Automagic integration <a name="sec:class:autoint"></a></h2>

We can apply the ideas from the section <a href="#sec:class:autodF">Example: Automagic differentiation</a> to
make a class for computing the integral of a function numerically.
Given a function \( f(x) \), we want to compute

$$
\begin{equation*}
F(x; a) = \int_a^x f(t)dt  \thinspace .
\end{equation*}
$$

The computational technique consists of using the Trapezoidal rule with \( n \)
intervals (\( n+1 \) points):

$$
\begin{equation}
\int_a^x f(t)dt = h\left(\frac{1}{2}f(a) + \sum_{i=1}^{n-1} f(a+ih) + \frac{1}{2}f(x)\right),\ 
\end{equation}
$$

where \( h=(x-a)/n \).
In an application
program, we want to compute \( F(x;a) \) by a simple syntax like

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def f(x):
    return exp(-x**2)*sin(10*x)

a = 0; n = 200
F = Integral(f, a, n)
print F(x)
</code></pre>
<!-- end verbatim block -->
Here, <code>f(x)</code> is the Python function to be integrated, and <code>F(x)</code>
behaves as a Python function that calculates values of \( F(x;a) \).

<h3>A simple implementation  <a name="___sec32"></a></h3>

Consider a straightforward implementation of the Trapezoidal rule
in a Python function:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def trapezoidal(f, a, x, n):
    h = (x-a)/float(n)
    I = 0.5*f(a)
    for i in range(1, n):
        I += f(a + i*h)
    I += 0.5*f(x)
    I *= h
    return I
</code></pre>
<!-- end verbatim block -->

<p>
Class <code>Integral</code> must have some attributes and a <code>__call__</code>
method. Since the latter method is supposed to take <code>x</code> as argument,
the other parameters <code>a</code>, <code>f</code>, and <code>n</code> must be class attributes.  The
implementation then becomes

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class Integral:
    def __init__(self, f, a, n=100):
        self.f, self.a, self.n = f, a, n

    def __call__(self, x):
        return trapezoidal(self.f, self.a, x, self.n)
</code></pre>
<!-- end verbatim block -->
Observe that we just reuse the <code>trapezoidal</code> function to perform
the calculation. We could alternatively have copied the body of
the <code>trapezoidal</code> function into the <code>__call__</code> method.
However, if we already have this algorithm implemented and tested as
a function, it is better to call the function.
The class is then known as a <em>wrapper</em> of the underlying function.
A wrapper allows something to be called with alternative syntax.

<p>
An application program computing \( \int_0^{2\pi}\sin x\, dx \)
might look as follows:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>from math import sin, pi

G = Integral(sin, 0, 200)
value = G(2*pi)
</code></pre>
<!-- end verbatim block -->
An equivalent calculation is

<p>
<!-- begin verbatim block  pycod-->
<pre><code>value = trapezoidal(sin, 0, 2*pi, 200)
</code></pre>
<!-- end verbatim block -->

<h3>Verification via symbolic computing  <a name="___sec33"></a></h3>

We should always provide a test function for verification of
the implementation. To avoid dealing with unknown approximation errors
of the Trapezoidal rule, we use the obvious fact that linear functions
are integrated exactly by the rule. Although it is really easy to
pick a linear function, integrate it, and figure out what an integral
is, we can also demonstrate how to automate such a process by the
symbolic computing package <code>sympy</code>. Essentially, we define an
expression in <code>sympy</code>, ask <code>sympy</code> to integrate it, and then turn
the resulting symbolic integral to a plain Python function for
computing:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; import sympy
&gt;&gt;&gt; x = sympy.Symbol('x')
&gt;&gt;&gt; f_expr = sympy.cos(x) + 5*x
&gt;&gt;&gt; f_expr
5*x + cos(x)
&gt;&gt;&gt; F_expr = sympy.integrate(f_expr, x)
&gt;&gt;&gt; F_expr
5*x**2/2 + sin(x)
&gt;&gt;&gt; F = sympy.lambdify([x], F_expr)  # turn f_expr to F(x) func.
&gt;&gt;&gt; F(0)
0.0
&gt;&gt;&gt; F(1)
3.3414709848078967
</code></pre>
<!-- end verbatim block -->
Using such functionality to do exact integration, we can write
our test function as

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def test_Integral():
    # The Trapezoidal rule is exact for linear functions
    import sympy
    x = sympy.Symbol('x')
    f_expr = 2*x + 5
    # Turn sympy expression into plain Python function f(x)
    f = sympy.lambdify([x], f_expr)
    # Find integral of f_expr and turn into plain Python function F
    F_expr = sympy.integrate(f_expr, x)
    F = sympy.lambdify([x], F_expr)

    a = 2
    I = Integral(f, a, n=4)
    x = 6
    diff = abs(I(x) - (F(x) - F(a)))
    assert diff &lt; 1E-15, 'bug in class Integral, diff=%s' % diff
</code></pre>
<!-- end verbatim block -->

<h3>Remark  <a name="___sec34"></a></h3>

Class <code>Integral</code> is inefficient (but probably more
than fast enough) for plotting \( F(x;a) \) as a function \( x \).
<a href="#sec:class:ex13c">Exercise 22: Speed up repeated integral calculations</a> suggests to optimize the class
for this purpose.

<h2>Turning an instance into a string <a name="sec:class:str"></a></h2>

Another special method is <code>__str__</code>. It is called when
a class instance needs to be converted to a string. This happens when
we say <code>print a</code>, and <code>a</code> is an instance. Python will then look
into the <code>a</code> instance
for a <code>__str__</code> method, which is supposed to return a string.
If such a special method is found, the returned string is printed,
otherwise just the name of the class is printed. An example will illustrate
the point. First we try to print an <code>y</code> instance of class
<code>Y</code> from the section <a href="#sec:class:func2">Representing a function as a class</a>
(where there is no <code>__str__</code> method):

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; print y
&lt;__main__.Y instance at 0xb751238c&gt;
</code></pre>
<!-- end verbatim block -->
This means that <code>y</code> is an <code>Y</code> instance in the <code>__main__</code>
module (the main program or the interactive session). The output also
contains an address telling where the <code>y</code> instance is stored
in the computer's memory.

<p>
If we want <code>print y</code> to print out the <code>y</code> instance, we need
to define the <code>__str__</code> method in class <code>Y</code>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class Y:
    ...
    def __str__(self):
        return 'v0*t - 0.5*g*t**2; v0=%g' % self.v0
</code></pre>
<!-- end verbatim block -->
Typically, <code>__str__</code> replaces our previous <code>formula</code>
method and <code>__call__</code> replaces our previous <code>value</code> method.
Python programmers with the experience that we now have gained will
therefore write class <code>Y</code> with special methods only:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class Y:
    def __init__(self, v0):
        self.v0 = v0
        self.g = 9.81

    def __call__(self, t):
        return self.v0*t - 0.5*self.g*t**2

    def __str__(self):
        return 'v0*t - 0.5*g*t**2; v0=%g' % self.v0
</code></pre>
<!-- end verbatim block -->
Let us see the class in action:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; y = Y(1.5)
&gt;&gt;&gt; y(0.2)
0.1038
&gt;&gt;&gt; print y
v0*t - 0.5*g*t**2; v0=1.5
</code></pre>
<!-- end verbatim block -->
What have we gained by using special methods? Well, we can still only
evaluate the formula and write it out, but many users of the class will
claim that the syntax is more attractive since <code>y(t)</code> in code
means \( y(t) \) in mathematics,
and we can do a <code>print y</code> to view the formula.
The bottom line of using special methods is to achieve a more
user-friendly syntax. The next sections illustrate this point further.

<h2>Example: Phone book with special methods <a name="sec:class:phonebook2"></a></h2>

Let us reconsider class <code>Person</code> from the section <a href="#sec:class:phonebook">Phone book</a>.
The <code>dump</code> method in that class is better implemented as
a <code>__str__</code> special method. This is easy: we just change
the method name and replace <code>print s</code> by <code>return s</code>.

<p>
Storing <code>Person</code> instances in a dictionary to form a phone book is
straightforward. However, we make the dictionary a bit easier to use
if we wrap a class around it. That is, we make a class <code>PhoneBook</code>
which holds the dictionary as an attribute. An
<code>add</code> method can be used to add a new person:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class PhoneBook:
    def __init__(self):
        self.contacts = {}   # dict of Person instances

    def add(self, name, mobile=None, office=None,
            private=None, email=None):
        p = Person(name, mobile, office, private, email)
        self.contacts[name] = p
</code></pre>
<!-- end verbatim block -->
A <code>__str__</code> can print the phone book in alphabetic order:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>    def __str__(self):
        s = ''
        for p in sorted(self.contacts):
            s += str(self.contacts[p]) + '\n'
        return s
</code></pre>
<!-- end verbatim block -->
To retrieve a <code>Person</code> instance, we use the <code>__call__</code>
with the person's name as argument:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>    def __call__(self, name):
        return self.contacts[name]
</code></pre>
<!-- end verbatim block -->
The only advantage of this method is simpler syntax: for a <code>PhoneBook</code>
<code>b</code> we can get data about <code>NN</code> by calling
<code>b('NN')</code> rather than accessing the internal dictionary
<code>b.contacts['NN']</code>.

<p>
We can make a simple demo code for a phone book with three
names:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>b = PhoneBook()
b.add('Ole Olsen', office='767828292',
      email='olsen@somemail.net')
b.add('Hans Hanson',
      office='767828283', mobile='995320221')
b.add('Per Person', mobile='906849781')
print b('Per Person')
print b
</code></pre>
<!-- end verbatim block -->
The output becomes

<p>
<!-- begin verbatim block  ccq-->
<pre><code>Per Person
mobile phone:   906849781

Hans Hanson
mobile phone:   995320221
office phone:   767828283

Ole Olsen
office phone:   767828292
email address:  olsen@somemail.net

Per Person
mobile phone:   906849781
</code></pre>
<!-- end verbatim block -->
You are strongly encouraged to work through this last demo program
by hand and simulate what the program does. That is, jump around in
the code and write down on a piece of paper what various variables
contain after each statement. This is an important and good exercise!
You enjoy the happiness of mastering classes if you get the same output
as above. The complete program with classes <code>Person</code> and
<code>PhoneBook</code> and the test above is found in the file
<a href="http://tinyurl.com/pwyasaa/class/PhoneBook.py" target="_self"><tt>PhoneBook.py</tt></a>.
You can run this program, statement by statement,
either in the <a href="http://www.pythontutor.com/" target="_self">Online Python Tutor</a> or
in a debugger (see the document <a href="http://tcse6.on.net/debug" target="_self">Debugging in Python</a> <a href="#Langtangen_TCSE6_debug">[3]</a>)
to control that your understanding of the program flow is correct.

<h3>Remark  <a name="___sec37"></a></h3>

Note that the names are sorted with respect to the first names.
The reason is that strings are sorted after the first character,
then the second character, and so on.
We can supply our own tailored sort
function, as explained in ref{sec:basic:ex28}.
One possibility is to split the
name into words and use the last word for sorting:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def last_name_sort(name1, name2):
    lastname1 = name1.split()[-1]
    lastname2 = name2.split()[-1]
    if lastname1 &lt; lastname2:
        return -1
    elif lastname1 &gt; lastname2:
        return 1
    else: # equality
        return 0

for p in sorted(self.contacts, last_name_sort):
   ...
</code></pre>
<!-- end verbatim block -->

<h2>Adding objects <a name="sec:class:add"></a></h2>

Let <code>a</code> and <code>b</code> be instances of some class <code>C</code>. Does it
make sense to write <code>a + b</code>? Yes, this makes sense if class
<code>C</code> has defined a special method <code>__add__</code>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class C:
    ...
    __add__(self, other):
        ...
</code></pre>
<!-- end verbatim block -->
The <code>__add__</code> method should add the instances <code>self</code>
and <code>other</code> and return the result as an instance.
So when Python encounters <code>a + b</code>, it will check if class
<code>C</code> has an <code>__add__</code> method and interpret <code>a + b</code>
as the call <code>a.__add__(b)</code>.
The next example will hopefully clarify what this idea can be used for.

<h2>Example: Class for polynomials <a name="sec:class:Polynomial"></a></h2>

Let us create a class <code>Polynomial</code>
for polynomials. The coefficients in the polynomial can be given to
the constructor as a list. Index number \( i \) in this list represents the
coefficients of the \( x^i \) term in the polynomial. That is, writing
<code>Polynomial([1,0,-1,2])</code>
defines a polynomial

$$
\begin{equation*} 1 + 0\cdot x - 1\cdot x^2 + 2\cdot x^3 =
1 - x^2 + 2x^3 \thinspace .
\end{equation*}
$$

Polynomials can be added (by just adding the coefficients corresponding
to the same powers)
so our class may have
an <code>__add__</code> method.
A <code>__call__</code> method is natural for evaluating the polynomial,
given a value of \( x \). The class is listed below and explained afterwards.

<h3>Implementation  <a name="___sec40"></a></h3>

<!-- begin verbatim block  pycod-->
<pre><code>class Polynomial:
    def __init__(self, coefficients):
        self.coeff = coefficients

    def __call__(self, x):
        s = 0
        for i in range(len(self.coeff)):
            s += self.coeff[i]*x**i
        return s

    def __add__(self, other):
        # Start with the longest list and add in the other
        if len(self.coeff) &gt; len(other.coeff):
            result_coeff = self.coeff[:]  # copy!
            for i in range(len(other.coeff)):
                result_coeff[i] += other.coeff[i]
        else:
            result_coeff = other.coeff[:] # copy!
            for i in range(len(self.coeff)):
                result_coeff[i] += self.coeff[i]
        return Polynomial(result_coeff)
</code></pre>
<!-- end verbatim block -->
Class <code>Polynomial</code> has one attribute: the list of coefficients.
To evaluate the polynomial, we just sum up coefficient no. \( i \) times
\( x^i \) for \( i=0 \) to the number of coefficients in the list.

<p>
The <code>__add__</code> method looks more advanced. The idea is to add the two
lists of coefficients. However, it may happen that the lists are of
unequal length. We therefore start with the longest list and add in
the other list, element by element.  Observe that <code>result_coeff</code>
starts out as a <em>copy</em> of <code>self.coeff</code>: if not, changes in
<code>result_coeff</code> as we compute the sum will be reflected in
<code>self.coeff</code>. This means that <code>self</code> would be the sum of itself and
the <code>other</code> instance, or in other words, adding two instances,
<code>p1+p2</code>, changes <code>p1</code> - this is not what we want!  An alternative
implementation of class <code>Polynomial</code> is found in <a href="#sec:class:ex4">Exercise 24: Find a bug in a class for polynomials</a>.

<p>
A subtraction method <code>__sub__</code> can be implemented along the lines of
<code>__add__</code>, but is slightly more complicated and left to the reader
through <a href="#sec:class:ex6a">Exercise 25: Implement subtraction of polynomials</a>.  A somewhat more complicated
operation, from a mathematical point of view, is the multiplication of
two polynomials. Let \( p(x)=\sum_{i=0}^Mc_ix^i \) and \( q(x)=\sum_{j=0}^N
d_jx^j \) be the two polynomials. The product becomes

$$
\begin{equation*} \left(\sum_{i=0}^Mc_ix^i\right)\left( \sum_{j=0}^N d_jx^j\right)
= \sum_{i=0}^M \sum_{j=0}^N c_id_j x^{i+j} \thinspace . \end{equation*}
$$

The double sum must be implemented as a double loop, but first the
list for the resulting polynomial must be created with length \( M+N+1 \)
(the highest exponent is \( M+N \) and then we need a constant term).
The implementation of the multiplication operator becomes

<p>
<!-- begin verbatim block  pycod-->
<pre><code>    def __mul__(self, other):
        c = self.coeff
        d = other.coeff
        M = len(c) - 1
        N = len(d) - 1
        result_coeff = numpy.zeros(M+N+1)
        for i in range(0, M+1):
            for j in range(0, N+1):
                result_coeff[i+j] += c[i]*d[j]
        return Polynomial(result_coeff)
</code></pre>
<!-- end verbatim block -->

<p>
We could also include a method for
differentiating the polynomial according to the formula

$$
\begin{equation*}
{d\over dx}\sum_{i=0}^n c_ix^i = \sum_{i=1}^n ic_ix^{i-1} \thinspace .
\end{equation*}
$$

If \( c_i \) is stored as a list <code>c</code>,
the list representation of the derivative, say its name is <code>dc</code>,
fulfills <code>dc[i-1] = i*c[i]</code> for <code>i</code> running from 1 to the
largest index in <code>c</code>. Note that <code>dc</code> has one element less
than <code>c</code>.

<p>
There are two different ways of implementing the differentiation
functionality, either by changing the polynomial coefficients, or by
returning a new <code>Polynomial</code> instance from the method such that the
original polynomial instance is intact.  We let <code>p.differentiate()</code> be
an implementation of the first approach, i.e., this method does not
return anything, but the coefficients in the <code>Polynomial</code> instance <code>p</code>
are altered.  The other approach is implemented by <code>p.derivative()</code>,
which returns a new <code>Polynomial</code> object with coefficients
corresponding to the derivative of <code>p</code>.

<p>
The complete implementation of the two methods
is given below:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class Polynomial:
    ...
    def differentiate(self):
        &quot;&quot;&quot;Differentiate this polynomial in-place.&quot;&quot;&quot;
        for i in range(1, len(self.coeff)):
            self.coeff[i-1] = i*self.coeff[i]
        del self.coeff[-1]

    def derivative(self):
        &quot;&quot;&quot;Copy this polynomial and return its derivative.&quot;&quot;&quot;
        dpdx = Polynomial(self.coeff[:])  # make a copy
        dpdx.differentiate()
        return dpdx
</code></pre>
<!-- end verbatim block -->
The <code>Polynomial</code> class with a <code>differentiate</code> method and not a
<code>derivative</code> method would be mutable (i.e., the object's content can
change) and allow in-place changes of the data, while the <code>Polynomial</code>
class with <code>derivative</code> and not <code>differentiate</code> would yield an
immutable object where the polynomial initialized in the constructor
is never altered.  (Technically, it is possible to grab the <code>coeff</code>
variable in a class instance and alter this list. By starting <code>coeff</code>
with an underscore, a Python programming convention tells programmers
that this variable is for internal use in the class only, and not to
be altered by users of the instance, see the sections <a href="#sec:class:account">Bank accounts</a> and <a href="#sec:class:illegalop">Illegal operations</a>.)  A good rule is
to offer only one of these two functions such that a <code>Polynomial</code>
object is either mutable or immutable (if we leave out
<code>differentiate</code>, its function body must of course be copied into
<code>derivative</code> since <code>derivative</code> now relies on that code).  However,
since the main purpose of this class is to illustrate various types of
programming techniques, we keep both versions.

<h3>Usage  <a name="___sec41"></a></h3>

As a demonstration of the functionality of class <code>Polynomial</code>, we introduce
the two polynomials

$$
\begin{equation*} p_1(x)= 1-x,\quad p_2(x)=x - 6x^4 - x^5  \thinspace . \end{equation*}
$$


<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; p1 = Polynomial([1, -1])
&gt;&gt;&gt; p2 = Polynomial([0, 1, 0, 0, -6, -1])
&gt;&gt;&gt; p3 = p1 + p2
&gt;&gt;&gt; print p3.coeff
[1, 0, 0, 0, -6, -1]
&gt;&gt;&gt; p4 = p1*p2
&gt;&gt;&gt; print p4.coeff
[0, 1, -1, 0, -6, 5, 1]
&gt;&gt;&gt; p5 = p2.derivative()
&gt;&gt;&gt; print p5.coeff
[1, 0, 0, -24, -5]
</code></pre>
<!-- end verbatim block -->
One verification of the implementation may be to compare
<code>p3</code> at (e.g.) \( x=1/2 \) with \( p_1(x) + p_2(x) \):

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; x = 0.5
&gt;&gt;&gt; p1_plus_p2_value = p1(x) + p2(x)
&gt;&gt;&gt; p3_value = p3(x)
&gt;&gt;&gt; print p1_plus_p2_value - p3_value
0.0
</code></pre>
<!-- end verbatim block -->
Note that <code>p1 + p2</code> is very different from <code>p1(x) + p2(x)</code>.  In the
former case, we add two instances of class <code>Polynomial</code>, while in the
latter case we add two instances of class <code>float</code> (since <code>p1(x)</code> and
<code>p2(x)</code> imply calling <code>__call__</code> and that method returns a <code>float</code>
object).

<h3>Pretty print of polynomials  <a name="___sec42"></a></h3>

The <code>Polynomial</code> class can also be equipped with a
<code>__str__</code> method for printing the polynomial to the screen.
A first, rough implementation could simply add up strings
of the form <code>+ self.coeff[i]*x^i</code>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class Polynomial:
    ...
    def __str__(self):
        s = ''
        for i in range(len(self.coeff)):
            s += ' + %g*x^%d' % (self.coeff[i], i)
        return s
</code></pre>
<!-- end verbatim block -->
However, this implementation leads to ugly output from a mathematical
viewpoint. For instance,
a polynomial with coefficients <code>[1,0,0,-1,-6]</code>
gets printed as

<p>
<!-- begin verbatim block  ccq-->
<pre><code> + 1*x^0 + 0*x^1 + 0*x^2 + -1*x^3 + -6*x^4
</code></pre>
<!-- end verbatim block -->
A more desired output would be

<p>
<!-- begin verbatim block  ccq-->
<pre><code>1 - x^3 - 6*x^4
</code></pre>
<!-- end verbatim block -->
That is, terms with a zero coefficient should be dropped; a part <code>'+
-'</code> of the output string should be replaced by <code>'- '</code>; unit
coefficients should be dropped, i.e., <code>' 1*'</code> should be replaced by
space <code>' '</code>; unit power should be dropped by replacing <code>'x^1 '</code> by <code>'x
'</code>; zero power should be dropped and replaced by <code>1</code>, initial spaces
should be fixed, etc.  These adjustments can be implemented using the
<code>replace</code> method in string objects and by composing slices of the
strings. The new version of the <code>__str__</code> method below contains the
necessary adjustments. If you find this type of string manipulation
tricky and difficult to understand, you may safely skip further
inspection of the improved <code>__str__</code> code since the details are not
essential for your present learning about the class concept and
special methods.

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class Polynomial:
    ...
    def __str__(self):
        s = ''
        for i in range(0, len(self.coeff)):
            if self.coeff[i] != 0:
                s += ' + %g*x^%d' % (self.coeff[i], i)
        # Fix layout
        s = s.replace('+ -', '- ')
        s = s.replace('x^0', '1')
        s = s.replace(' 1*', ' ')
        s = s.replace('x^1 ', 'x ')
        if s[0:3] == ' + ':  # remove initial +
            s = s[3:]
        if s[0:3] == ' - ':  # fix spaces for initial -
            s = '-' + s[3:]
        return s
</code></pre>
<!-- end verbatim block -->
Programming sometimes turns into coding (what one think is)
a general solution followed
by a series of special cases to fix caveats in the &quot;general&quot; solution,
just as we experienced with the <code>__str__</code> method above.
This situation often calls for additional future fixes and is often
a sign of a suboptimal solution to the programming problem.

<p>
Pretty print of <code>Polynomial</code> instances can be demonstrated in an
interactive session:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; p1 = Polynomial([1, -1])
&gt;&gt;&gt; print p1
1 - x^1
&gt;&gt;&gt; p2 = Polynomial([0, 1, 0, 0, -6, -1])
&gt;&gt;&gt; p2.differentiate()
&gt;&gt;&gt; print p2
1 - 24*x^3 - 5*x^4
</code></pre>
<!-- end verbatim block -->

<h3>Verifying the implementation  <a name="___sec43"></a></h3>

It is always a good habit to include a test function <code>test_Polynomial()</code>
for verifying the functionality in class <code>Polynomial</code>.
To this end, we construct some examples of addition, multiplication,
and differentiation of polynomials by hand and make tests that class
<code>Polynomial</code> reproduces the correct results. Testing the <code>__str__</code>
method is left as <a href="#sec:class:exer:str">Exercise 26: Test the functionality of pretty print of polynomials</a>.

<p>
Round-off errors may be an issue in class <code>Polynomial</code>: <code>__add__</code>,
<code>derivative</code>, and <code>differentiate</code> will lead to integer coefficients if
the polynomials to be added have integer coefficients, while <code>__mul__</code>
always results in a polynomial with the coefficients stored in a
<code>numpy</code> array with <code>float</code> elements. Integer coefficients in lists can
be compared using <code>==</code> for lists, while coefficients in <code>numpy</code> arrays
must be compared with a tolerance. One can either subtract the <code>numpy</code>
arrays and use the <code>max</code> method to find the largest deviation and
compare this with a tolerance, or one can use <code>numpy.allclose(a, b,
rtol=tol)</code> for comparing the arrays <code>a</code> and <code>b</code> with a (relative)
tolerance <code>tol</code>.

<p>
Let us pick polynomials with integer coefficients as test cases
such that <code>__add__</code>, <code>derivative</code>, and <code>differentiate</code> can
be verified by testing equality (<code>==</code>) of the <code>coeff</code> lists.
Multiplication in <code>__mul__</code> must employ <code>numpy.allclose</code>.

<p>
We follow the convention that all tests are on the form
<code>assert success</code>, where <code>success</code> is a boolean expression
for the test. (The actual version of the test function in
the file <a href="http://tinyurl.com/pwyasaa/class/Polynomial.py" target="_self"><tt>Polynomial.py</tt></a>
adds an error message <code>msg</code> to the test:
<code>assert success, msg</code>.) Another part of the convention is
that the function starts with <code>test_</code> and the function takes no
arguments.

<p>
Our test function now becomes

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def test_Polynomial():
    p1 = Polynomial([1, -1])
    p2 = Polynomial([0, 1, 0, 0, -6, -1])

    p3 = p1 + p2
    p3_exact = Polynomial([1, 0, 0, 0, -6, -1])
    assert p3.coeff == p3_exact.coeff

    p4 = p1*p2
    p4_exact = Polynomial(numpy.array([0,  1, -1,  0, -6,  5,  1]))
    assert numpy.allclose(p4.coeff, p4_exact.coeff, rtol=1E-14)

    p5 = p2.derivative()
    p5_exact = Polynomial([1, 0, 0, -24, -5])
    assert p5.coeff == p5_exact.coeff

    p6 = Polynomial([0, 1, 0, 0, -6, -1])  # p2
    p6.differentiate()
    p6_exact = p5_exact
    assert p6.coeff == p6_exact.coeff
</code></pre>
<!-- end verbatim block -->

<h2>Arithmetic operations and other special methods <a name="sec:class:arithmetics"></a></h2>

Given two instances <code>a</code> and <code>b</code>, the standard binary arithmetic
operations with <code>a</code> and <code>b</code> are defined by the following
special methods:

<ul>
  <li> <code>a + b</code> : <code>a.__add__(b)</code></li>
  <li> <code>a - b</code> : <code>a.__sub__(b)</code></li>
  <li> <code>a*b</code> : <code>a.__mul__(b)</code></li>
  <li> <code>a/b</code> : <code>a.__div__(b)</code></li>
  <li> <code>a**b</code> : <code>a.__pow__(b)</code></li>
</ul>

Some other special methods are also often useful:

<ul>
  <li> the length of <code>a</code>, <code>len(a)</code>: <code>a.__len__()</code></li>
  <li> the absolute value of <code>a</code>, <code>abs(a)</code>: <code>a.__abs__()</code></li>
  <li> <code>a == b</code> : <code>a.__eq__(b)</code></li>
  <li> <code>a > b</code> : <code>a.__gt__(b)</code></li>
  <li> <code>a >= b</code> : <code>a.__ge__(b)</code></li>
  <li> <code>a < b</code> : <code>a.__lt__(b)</code></li>
  <li> <code>a <= b</code> : <code>a.__le__(b)</code></li>
  <li> <code>a != b</code> : <code>a.__ne__(b)</code></li>
  <li> <code>-a</code> : <code>a.__neg__()</code></li>
  <li> evaluating <code>a</code> as a boolean expression (as in the test <code>if a:</code>) implies calling the special method <code>a.__bool__()</code>, which must return <code>True</code> or <code>False</code> - if <code>__bool__</code> is not defined, <code>__len__</code> is called to see if the length is zero (<code>False</code>) or not (<code>True</code>)</li>
</ul>

We can implement such methods in class <code>Polynomial</code>, see <a href="#sec:class:ex6a">Exercise 25: Implement subtraction of polynomials</a>.  The section <a href="#sec:class:Vec2D">Example: Class for vectors in the plane</a> contains
examples on implementing the special methods listed above.

<h2>Special methods for string conversion <a name="sec:class:repr"></a></h2>

Look at this class with a <code>__str__</code> method:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; class MyClass:
...     def __init__(self):
...         self.data = 2
...     def __str__(self):
...         return 'In __str__: %s' % str(self.data)
...
&gt;&gt;&gt; a = MyClass()
&gt;&gt;&gt; print a
In __str__: 2
</code></pre>
<!-- end verbatim block -->
Hopefully, you understand well why we get this output (if not, go back to
the section <a href="#sec:class:str">Turning an instance into a string</a>).

<p>
But what will happen
if we write just <code>a</code> at the command prompt in an interactive shell?

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; a
&lt;__main__.MyClass instance at 0xb75125ac&gt;
</code></pre>
<!-- end verbatim block -->
When writing just <code>a</code> in an interactive session,
Python looks for a special method
<code>__repr__</code> in <code>a</code>. This method is similar to
<code>__str__</code> in that it turns the instance into a string,
but there is a convention that <code>__str__</code> is a pretty print
of the instance contents while <code>__repr__</code> is a complete
representation of the contents of the instance. For a lot of
Python classes, including <code>int</code>, <code>float</code>, <code>complex</code>,
<code>list</code>, <code>tuple</code>, and <code>dict</code>, <code>__repr__</code>
and <code>__str__</code> give identical output. In our class <code>MyClass</code>
the <code>__repr__</code> is missing, and we need to add it if we want

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; a
</code></pre>
<!-- end verbatim block -->
to write the contents like <code>print a</code> does.

<p>
Given an instance <code>a</code>, <code>str(a)</code> implies calling
<code>a.__str__()</code> and <code>repr(a)</code> implies calling
<code>a.__repr__()</code>. This means that

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; a
</code></pre>
<!-- end verbatim block -->
is actually a <code>repr(a)</code> call and

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; print a
</code></pre>
<!-- end verbatim block -->
is actually a <code>print str(a)</code> statement.

<p>
A simple remedy in class <code>MyClass</code> is to define

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def __repr__(self):
    return self.__str__()  # or return str(self)
</code></pre>
<!-- end verbatim block -->
However, as we explain below, the <code>__repr__</code> is best defined
differently.

<h3>Recreating objects from strings  <a name="___sec46"></a></h3>

The Python function <code>eval(e)</code> evaluates a valid Python expression
contained in the string
<code>e</code>, see the section ref{sec:input:eval}.
It is a convention that <code>__repr__</code> returns a string such that
<code>eval</code> applied to the string recreates the instance.
For example, in case of the <code>Y</code> class
from the section <a href="#sec:class:func2">Representing a function as a class</a>, <code>__repr__</code>
should return <code>'Y(10)'</code> if the <code>v0</code> variable has the value <code>10</code>.
Then <code>eval('Y(10)')</code> will be the same as if we had coded
<code>Y(10)</code> directly in the program or an interactive session.

<p>
Below we show examples of <code>__repr__</code> methods in classes <code>Y</code>
(the section <a href="#sec:class:func2">Representing a function as a class</a>),
<code>Polynomial</code> (the section <a href="#sec:class:Polynomial">Example: Class for polynomials</a>),
and <code>MyClass</code> (above):

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class Y:
    ...
    def __repr__(self):
        return 'Y(v0=%s)' % self.v0

class Polynomial:
    ...
    def __repr__(self):
        return 'Polynomial(coefficients=%s)' % self.coeff

class MyClass:
    ...
    def __repr__(self):
        return 'MyClass()'
</code></pre>
<!-- end verbatim block -->
With these definitions, <code>eval(repr(x))</code> recreates the object <code>x</code>
if it is of one of the three types above.
In particular, we can write <code>x</code> to file and later recreate the
<code>x</code> from the file information:

<p>
<!-- begin verbatim block  pycod-->
<pre><code># somefile is some file object
somefile.write(repr(x))
somefile.close()
...
data = somefile.readline()
x2 = eval(data)  # recreate object
</code></pre>
<!-- end verbatim block -->
Now, <code>x2</code> will be equal to <code>x</code> (<code>x2 == x</code> evaluates to <code>True</code>).

<h1>Example: Class for vectors in the plane <a name="sec:class:Vec2D"></a></h1>

This section explains how to implement two-dimensional vectors in Python
such that these vectors act as objects we can add, subtract,
form inner products with, and do other mathematical operations on.
To understand the forthcoming material, it is necessary to
have digested the section <a href="#sec:class:specialmethods">Special methods</a>,
in particular the sections <a href="#sec:class:add">Adding objects</a> and <a href="#sec:class:arithmetics">Arithmetic operations and other special methods</a>.

<h2>Some mathematical operations on vectors  <a name="___sec48"></a></h2>

Vectors in the plane are
described by a pair of real numbers, \( (a, b) \).
In the section ref{sec:plot:vectors} we present
mathematical
rules for adding and subtracting vectors, multiplying two vectors (the inner or
dot or scalar product), the length of a vector, and multiplication by
a scalar:

$$
\begin{align}
(a,b) + (c,d) &= (a+c, b+d),\\ 
(a,b) - (c,d) &= (a-c, b-d),\\ 
(a,b)\cdot(c,d) &= ac + bd,\\ 
||(a,b)|| &= \sqrt{(a,b)\cdot(a,b)}  \thinspace .
\end{align}
$$

Moreover,
two vectors \( (a,b) \) and \( (c,d) \) are equal if \( a=c \) and \( b=d \).

<h2>Implementation  <a name="___sec49"></a></h2>

We may create a class for plane vectors where the above mathematical
operations are implemented by special methods. The class must contain
two attributes, one for each component of the vector, called <code>x</code> and
<code>y</code>
below. We include special methods for addition, subtraction, the scalar
product (multiplication), the absolute value (length), comparison of
two vectors (<code>==</code> and <code>!=</code>), as well as a method for printing out
a vector.

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class Vec2D:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __add__(self, other):
        return Vec2D(self.x + other.x, self.y + other.y)

    def __sub__(self, other):
        return Vec2D(self.x - other.x, self.y - other.y)

    def __mul__(self, other):
        return self.x*other.x + self.y*other.y

    def __abs__(self):
        return math.sqrt(self.x**2 + self.y**2)

    def __eq__(self, other):
        return self.x == other.x and self.y == other.y

    def __str__(self):
        return '(%g, %g)' % (self.x, self.y)

    def __ne__(self, other):
        return not self.__eq__(other)  # reuse __eq__
</code></pre>
<!-- end verbatim block -->
The <code>__add__</code>,
<code>__sub__</code>,
<code>__mul__</code>,
<code>__abs__</code>, and
<code>__eq__</code> methods
should be quite straightforward to understand from the previous
mathematical definitions of these operations.
The last method deserves a comment: here we simply reuse the
equality operator <code>__eq__</code>, but precede it with a <code>not</code>.
We could also have implemented this method as

<p>
<!-- begin verbatim block  pycod-->
<pre><code>    def __ne__(self, other):
        return self.x != other.x or self.y != other.y
</code></pre>
<!-- end verbatim block -->
Nevertheless, this implementation requires us to write more, and it has
the danger of introducing an error in the logics of the boolean
expressions. A more reliable approach, when we know that the
<code>__eq__</code> method works, is to reuse this method and
observe that <code>a != b</code> means <code>not (a == b)</code>.

<p>
A word of warning is in place regarding our implementation of the
equality operator (<code>==</code> via <code>__eq__</code>).
We test for equality of each component, which is correct from a
mathematical point of view. However, each vector component is a
floating-point number that may be subject to round-off errors both
in the representation on the computer and from previous (inexact)
floating-point calculations. Two mathematically equal components may
be different in their inexact representations on the computer.
The remedy for this problem is to avoid testing for equality, but instead
check that the difference between the components is sufficiently small.
The function <code>numpy.allclose</code> can be used for this purpose:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>if a == b:
</code></pre>
<!-- end verbatim block -->
by

<p>
<!-- begin verbatim block  pycod-->
<pre><code>if numpy.allclose(a, b):
</code></pre>
<!-- end verbatim block -->
A more reliable
equality operator can now be implemented:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class Vec2D:
    ...
    def __eq__(self, other):
        return numpy.allclose(self.x, other.x) and \ 
               numpy.allclose(self.y, other.y)
</code></pre>
<!-- end verbatim block -->
As a rule of thumb, you should never apply the <code>==</code> test to two
<code>float</code> objects.

<p>
The special method
<code>__len__</code> could be introduced as a synonym for
<code>__abs__</code>, i.e., for a <code>Vec2D</code> instance named <code>v</code>,
<code>len(v)</code> is the same as <code>abs(v)</code>, because the absolute value of
a vector is mathematically the same as the length of the vector.
However, if we implement

<p>
<!-- begin verbatim block  pycod-->
<pre><code>    def __len__(self):
        # Reuse implementation of __abs__
        return abs(self)  # equiv. to self.__abs__()
</code></pre>
<!-- end verbatim block -->
we will run into trouble when we compute <code>len(v)</code> and the answer
is (as usual) a <code>float</code>. Python will then complain and tell us that
<code>len(v)</code> must return an <code>int</code>. Therefore,
<code>__len__</code> cannot be used as a synonym for the length of the
vector in our application. On the other hand, we could let
<code>len(v)</code> mean the number of components in the vector:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>    def __len__(self):
        return 2
</code></pre>
<!-- end verbatim block -->
This is not a very useful function, though, as we already know that all our
<code>Vec2D</code> vectors have just two components.
For generalizations of the class to vectors with \( n \) components, the
<code>__len__</code> method is of course useful.

<h2>Usage  <a name="___sec50"></a></h2>

Let us play with some <code>Vec2D</code> objects:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; u = Vec2D(0,1)
&gt;&gt;&gt; v = Vec2D(1,0)
&gt;&gt;&gt; w = Vec2D(1,1)
&gt;&gt;&gt; a = u + v
&gt;&gt;&gt; print a
(1, 1)
&gt;&gt;&gt; a == w
True
&gt;&gt;&gt; a = u - v
&gt;&gt;&gt; print a
(-1, 1)
&gt;&gt;&gt; a = u*v
&gt;&gt;&gt; print a
0
&gt;&gt;&gt; print abs(u)
1.0
&gt;&gt;&gt; u == v
False
&gt;&gt;&gt; u != v
True
</code></pre>
<!-- end verbatim block -->
When you read through this interactive session, you should check
that the calculation is mathematically correct,
that the resulting object type of a calculation is correct,
and how each calculation is performed in the program.
The latter topic is investigated by following the program
flow through the class methods.
As an example, let us consider the expression <code>u != v</code>.
This is a boolean expression that is <code>True</code> since <code>u</code> and <code>v</code>
are different vectors. The resulting object type should be <code>bool</code>,
with values <code>True</code> or <code>False</code>. This is confirmed by the output
in the interactive session above. The Python calculation of
<code>u != v</code> leads to a call to

<p>
<!-- begin verbatim block  pycod-->
<pre><code>u.__ne__(v)
</code></pre>
<!-- end verbatim block -->
which leads to a call to

<p>
<!-- begin verbatim block  pycod-->
<pre><code>u.__eq__(v)
</code></pre>
<!-- end verbatim block -->
The result of this last call is <code>False</code>, because the special method
will evaluate the boolean expression

<p>
<!-- begin verbatim block  pycod-->
<pre><code>0 == 1 and 1 == 0
</code></pre>
<!-- end verbatim block -->
which is obviously <code>False</code>. When going back to the <code>__ne__</code>
method, we end up with a return of <code>not False</code>, which evaluates
to <code>True</code>.

<h3>Comment  <a name="___sec51"></a></h3>

For real computations with vectors in the plane, you would probably just
use a Numerical Python array of length 2. However, one thing such objects
cannot do is evaluating <code>u*v</code> as a scalar product.
The multiplication operator for Numerical Python arrays is not defined
as a scalar product (it is rather defined as
\( (a,b)\cdot(c,d) = (ac, bd) \)). Another difference between our <code>Vec2D</code>
class and Numerical Python arrays is the <code>abs</code> function, which
computes the length of the vector in class <code>Vec2D</code>, while it does something
completely different with Numerical Python arrays.

<h1>Example: Class for complex numbers  <a name="___sec52"></a></h1>

Imagine that Python did not already have complex numbers. We could
then make a class for such numbers and support the standard
mathematical operations.  This exercise turns out to be a very good
pedagogical example of programming with classes and special methods,
so we shall make our own class for complex numbers and go through
all the details of the implementation.

<p>
The class must contain two attributes:
the real and imaginary part of the complex number. In addition, we would
like to add, subtract, multiply, and divide complex numbers.
We would also like to write out a complex number in some suitable format.
A session involving our own complex numbers may take the form

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; u = Complex(2,-1)
&gt;&gt;&gt; v = Complex(1)     # zero imaginary part
&gt;&gt;&gt; w = u + v
&gt;&gt;&gt; print w
(3, -1)
&gt;&gt;&gt; w != u
True
&gt;&gt;&gt; u*v
Complex(2, -1)
&gt;&gt;&gt; u &lt; v
illegal operation &quot;&lt;&quot; for complex numbers
&gt;&gt;&gt; print w + 4
(7, -1)
&gt;&gt;&gt; print 4 - w
(1, 1)
</code></pre>
<!-- end verbatim block -->
We do not manage to use exactly the same syntax with <code>j</code> as
imaginary unit as in Python's built-in complex numbers so
to specify a complex number we must create a <code>Complex</code> instance.

<h2>Implementation <a name="sec:class:Complex"></a></h2>

Here is the complete implementation of our class for complex numbers:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class Complex:
    def __init__(self, real, imag=0.0):
        self.real = real
        self.imag = imag

    def __add__(self, other):
        return Complex(self.real + other.real,
                       self.imag + other.imag)

    def __sub__(self, other):
        return Complex(self.real - other.real,
                       self.imag - other.imag)

    def __mul__(self, other):
        return Complex(self.real*other.real - self.imag*other.imag,
                       self.imag*other.real + self.real*other.imag)

    def __div__(self, other):
        sr, si, or, oi = self.real, self.imag, \ 
                         other.real, other.imag # short forms
        r = float(or**2 + oi**2)
        return Complex((sr*or+si*oi)/r, (si*or-sr*oi)/r)

    def __abs__(self):
        return sqrt(self.real**2 + self.imag**2)

    def __neg__(self):   # defines -c (c is Complex)
        return Complex(-self.real, -self.imag)

    def __eq__(self, other):
        return self.real == other.real and self.imag == other.imag

    def __ne__(self, other):
        return not self.__eq__(other)

    def __str__(self):
        return '(%g, %g)' % (self.real, self.imag)

    def __repr__(self):
        return 'Complex' + str(self)

    def __pow__(self, power):
        raise NotImplementedError\ 
              ('self**power is not yet impl. for Complex')
</code></pre>
<!-- end verbatim block -->
The special methods for addition, subtraction, multiplication,
division, and the absolute value
follow easily from the mathematical definitions of these
operations for complex
numbers (see the section ref{sec:formula:complex}).
What <code>-c</code> means when <code>c</code> is of type <code>Complex</code>,
is also easy to
define and implement. The <code>__eq__</code> method needs a word of
caution: the method is mathematically correct, but comparison of real numbers
on a computer should always employ a tolerance.
The version of <code>__eq__</code> shown above is about compact
code and equivalence to the mathematics. Any real-world numerical
computations should employ a test that
<code>abs(self.real - other.real) < eps</code> <em>and</em>
<code>abs(self.imag - other.imag) < eps</code>, where <code>eps</code> is some
small tolerance, say <code>eps = 1E-14</code>.

<p>
The final <code>__pow__</code> method exemplifies a way to
introduce a method in a class, while we postpone its implementation. The simplest
way to do this is by inserting an empty function body using the
<code>pass</code> ("do nothing") statement:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class Polynomial:
    ...
    def __pow__(self, power):
        # Postpone implementation of self**power
        pass
</code></pre>
<!-- end verbatim block -->
However, the preferred method is to raise a <code>NotImplementedError</code>
exception so that users writing power expressions are notified that
this operation is not available. The simple <code>pass</code> will just
silently bypass this serious fact!

<h2>Illegal operations <a name="sec:class:illegalop"></a></h2>

Some mathematical operations, like the comparison operators
<code>></code>, <code>>=</code>, etc., do not have a meaning for complex numbers.
By default, Python allows us to use these comparison operators
for our <code>Complex</code> instances, but the boolean result will be
mathematical nonsense.
Therefore, we should implement the corresponding special methods and
give a sensible error message that the operations are not available
for complex numbers. Since the messages are quite similar, we
make a separate method to gather common operations:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>    def _illegal(self, op):
        print 'illegal operation &quot;%s&quot; for complex numbers' % op
</code></pre>
<!-- end verbatim block -->
Note the underscore prefix: this is a Python convention telling
that the <code>_illegal</code> method is local to the class in the sense
that it is not supposed to be used outside the class, just by other
class methods.
In computer science terms, we say that names starting with an underscore
are not part of the <em>application programming interface</em>, known as
the API.
Other programming languages, such as Java, C++, and C#, have special
keywords, like <code>private</code> and <code>protected</code>
that can be used
to technically hide both data and methods from users of the class.
Python will never restrict anybody who tries to access data or
methods that are considered private to the class, but the leading underscore
in the name reminds any user of the class that she now touches parts
of the class that are not meant to be used &quot;from the outside&quot;.

<p>
Various special methods for comparison operators can now call
up <code>_illegal</code> to issue the error message:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>    def __gt__(self, other):  self._illegal('&gt;')
    def __ge__(self, other):  self._illegal('&gt;=')
    def __lt__(self, other):  self._illegal('&lt;')
    def __le__(self, other):  self._illegal('&lt;=')
</code></pre>
<!-- end verbatim block -->

<h2>Mixing complex and real numbers <a name="sec:class:complex:mixed"></a></h2>

The implementation of class <code>Complex</code> is far from perfect.
Suppose we add a complex number and a real number, which is
a mathematically perfectly valid operation:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>w = u + 4.5
</code></pre>
<!-- end verbatim block -->
This statement leads to an exception,

<p>
<!-- begin verbatim block  pycod-->
<pre><code>AttributeError: 'float' object has no attribute 'real'
</code></pre>
<!-- end verbatim block -->
In this case, Python sees <code>u + 4.5</code> and tries to
use <code>u.__add__(4.5)</code>, which causes trouble because
the <code>other</code> argument in the <code>__add__</code> method
is 4.5, i.e., a <code>float</code> object, and <code>float</code> objects
do not contain an attribute with the name <code>real</code> (<code>other.real</code>
is used in our <code>__add__</code> method, and accessing
<code>other.real</code> is what causes the error).

<p>
One idea for a remedy could be to set

<p>
<!-- begin verbatim block  pycod-->
<pre><code>other = Complex(other)
</code></pre>
<!-- end verbatim block -->
since this construction turns a real number <code>other</code> into a
<code>Complex</code> object. However, when we add two <code>Complex</code>
instances, <code>other</code> is of type <code>Complex</code>, and
the constructor simply stores this <code>Complex</code> instance as
<code>self.real</code> (look at the method <code>__init__</code>).
This is not what we want!

<p>
A better idea is to test for the type of <code>other</code> and perform the
right conversion to <code>Complex</code>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>    def __add__(self, other):
        if isinstance(other, (float,int)):
            other = Complex(other)
        return Complex(self.real + other.real,
                       self.imag + other.imag)
</code></pre>
<!-- end verbatim block -->
We could alternatively drop the conversion of <code>other</code> and
instead implement two addition rules, depending on
the type of <code>other</code>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>    def __add__(self, other):
        if isinstance(other, (float,int)):
            return Complex(self.real + other, self.imag)
        else:
            return Complex(self.real + other.real,
                           self.imag + other.imag)
</code></pre>
<!-- end verbatim block -->

<p>
A third way is to look for what we require from the <code>other</code> object,
and check that this demand is fulfilled. Mathematically, we require
<code>other</code> to be a complex or real number, but from a programming
point of view, all we demand (in the original <code>__add__</code>
implementation) is that <code>other</code> has <code>real</code> and
<code>imag</code> attributes. To check if an object <code>a</code> has an attribute
with name stored in the string <code>attr</code>, one can use the function

<p>
<!-- begin verbatim block  pycod-->
<pre><code>hasattr(a, attr)
</code></pre>
<!-- end verbatim block -->
In our context, we need to perform the test

<p>
<!-- begin verbatim block  pycod-->
<pre><code>if hasattr(other, 'real') and hasattr(other, 'imag'):
</code></pre>
<!-- end verbatim block -->
Our third implementation of the <code>__add__</code> method therefore becomes

<p>
<!-- begin verbatim block  pycod-->
<pre><code>    def __add__(self, other):
        if isinstance(other, (float,int)):
            other = Complex(other)
        elif not (hasattr(other, 'real') and \ 
                  hasattr(other, 'imag')):
            raise TypeError('other must have real and imag attr.')
        return Complex(self.real + other.real,
                       self.imag + other.imag)
</code></pre>
<!-- end verbatim block -->
The advantage with this third alternative is that we may add
instances of class <code>Complex</code> and Python's own complex class (<code>complex</code>),
since all we need is an object with <code>real</code> and <code>imag</code> attributes.

<h2>Dynamic, static, strong, weak, and duck typing  <a name="___sec56"></a></h2>

The presentations of alternative implementations of the
<code>__add__</code> actually touch some very important computer science
topics. In Python, function arguments can refer to
objects of any type, and the type of an argument can change
during program execution. This feature is known as <em>dynamic typing</em>
and supported by languages such as Python, Perl, Ruby, and Tcl.
Many other languages, C, C++, Java, and C# for instance, restrict
a function argument to be of one type, which must be known when we write
the program. Any attempt to call the function with an argument of another
type is flagged as an error. One says that the language employs
<em>static typing</em>, since the type cannot change as in languages
having dynamic typing. The code snippet

<p>
<!-- begin verbatim block  pycod-->
<pre><code>a = 6    # a is integer
a = 'b'  # a is string
</code></pre>
<!-- end verbatim block -->
is valid in a language with dynamic typing, but not in a language with
static typing.

<p>
Our next point is easiest illustrated through an example. Consider
the code

<p>
<!-- begin verbatim block  pycod-->
<pre><code>a = 6
b = '9'
c = a + b
</code></pre>
<!-- end verbatim block -->
The expression <code>a + b</code> adds an integer and a string, which is
illegal in Python. However, since <code>b</code> is the string <code>'9'</code>,
it is natural to interpret <code>a + b</code> as <code>6 + 9</code>.
That is, if the string <code>b</code> is converted to an integer, we may
calculate <code>a + b</code>. Languages performing this conversion automatically
are said to employ <em>weak typing</em>, while languages that require
the programmer to explicit perform the conversion, as in

<p>
<!-- begin verbatim block  pycod-->
<pre><code>c = a + float(b)
</code></pre>
<!-- end verbatim block -->
are known to have <em>strong typing</em>. Python, Java, C, and C# are
examples of languages with strong typing, while Perl and C++ allow
weak typing. However, in our third
implementation of the <code>__add__</code> method,
certain types - <code>int</code> and <code>float</code> --
are automatically converted to the right type <code>Complex</code>.
The programmer has therefore imposed a kind of weak typing in the
behavior of the addition operation for complex numbers.

<p>
There is also something called <em>duck typing</em> where the code only
imposes a requirement of some data or methods in the object, rather
than demanding the object to be of a particular type.  The explanation
of the term duck typing is the principle: <em>if it walks like a duck,
and quacks like a duck, it's a duck</em>.  An operation <code>a + b</code> may be
valid if <code>a</code> and <code>b</code> have certain properties that make it possible to
add the objects, regardless of the type of <code>a</code> or <code>b</code>.  To enable
<code>a + b</code> in our third implementation of the <code>__add__</code> method, it is
sufficient that <code>b</code> has <code>real</code> and <code>imag</code> attributes.  That is,
objects with <code>real</code> and <code>imag</code> look like <code>Complex</code> objects. Whether
they really are of type <code>Complex</code> is not considered important in this
context.

<p>
There is a continuously ongoing debate in computer science which kind
of typing that is preferable: dynamic versus static, and weak versus
strong.  Static and strong typing, as found in Java and C#, support
coding safety and reliability at the expense of long and sometimes
repetitive code, while dynamic and weak typing support programming
flexibility and short code. Many will argue that short code is more
readable and reliable than long code, so there is no simple conclusion.

<h2>Special methods for &quot;right&quot; operands <a name="sec:class:complex:rightop"></a></h2>

What happens if we add a <code>float</code> and a <code>Complex</code> in that order?

<p>
<!-- begin verbatim block  pycod-->
<pre><code>w = 4.5 + u
</code></pre>
<!-- end verbatim block -->
This statement causes the exception

<p>
<!-- begin verbatim block  pycod-->
<pre><code>TypeError: unsupported operand type(s) for +: 'float' and 'instance'
</code></pre>
<!-- end verbatim block -->
This time Python cannot find any definition of what the plus operation
means with a  <code>float</code> on the left-hand side  and a <code>Complex</code> object
on the right-hand side of the plus sign.
The <code>float</code> class was created many years ago without any
knowledge of our <code>Complex</code> objects, and we are not allowed
to extend the <code>__add__</code> method
in the <code>float</code> class to handle
<code>Complex</code> instances. Nevertheless, Python has a special method
<code>__radd__</code> for the case where the class instance (<code>self</code>)
is on the right-hand side of the operator and the
<code>other</code> object is on the left-hand side. That is, we may implement
a possible <code>float</code> or <code>int</code> plus a <code>Complex</code> by

<p>
<!-- begin verbatim block  pycod-->
<pre><code>    def __radd__(self, other):        # defines other + self
        return self.__add__(other)    # other + self = self + other
</code></pre>
<!-- end verbatim block -->
Similar special methods exist for subtraction, multiplication, and
division. For the subtraction operator, observe that <code>other - self</code>,
which is the operation assumed to implemented
in <code>__rsub__</code>, can be realized by
<code>other.__sub__(self)</code>. A possible implementation is

<p>
<!-- begin verbatim block  pycod-->
<pre><code>    def __sub__(self, other):
        print 'in sub, self=%s, other=%s' % (self, other)
        if isinstance(other, (float,int)):
            other = Complex(other)
        return Complex(self.real - other.real,
                       self.imag - other.imag)

    def __rsub__(self, other):
        print 'in rsub, self=%s, other=%s' % (self, other)
        if isinstance(other, (float,int)):
            other = Complex(other)
        return other.__sub__(self)
</code></pre>
<!-- end verbatim block -->
The <code>print</code> statements are inserted to better understand how these
methods are visited. A quick test demonstrates what happens:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; w = u - 4.5
in sub, self=(2, -1), other=4.5
&gt;&gt;&gt; print w
(-2.5, -1)
&gt;&gt;&gt; w = 4.5 - u
in rsub, self=(2, -1), other=4.5
in sub, self=(4.5, 0), other=(2, -1)
&gt;&gt;&gt; print w
(2.5, 1)
</code></pre>
<!-- end verbatim block -->

<h3>Remark  <a name="___sec58"></a></h3>

As you probably realize, there is quite some code to be implemented
and lots of considerations to be resolved before we have a class
<code>Complex</code> for professional use in the real world. Fortunately,
Python provides its <code>complex</code> class, which offers everything we need
for computing with complex numbers. This fact reminds us that it is
important to know what others already have implemented, so that we
avoid &quot;reinventing the wheel&quot;.
In a learning process, however, it is a probably a very
good idea to look into
the details of a class <code>Complex</code> as we did above.

<h2>Inspecting instances <a name="sec:class:inspect"></a></h2>

The purpose of this section is to explain how we can easily look at
the contents of a class instance, i.e., the data attributes and the methods.
As usual, we look at an example - this time involving
a very simple class:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class A:
    &quot;&quot;&quot;A class for demo purposes.&quot;&quot;&quot;
    def __init__(self, value):
        self.v = value

    def dump(self):
        print self.__dict__
</code></pre>
<!-- end verbatim block -->
The <code>self.__dict__</code> attribute is briefly mentioned in
the section <a href="#sec:class:whatis">Making classes without the class construct</a>.
Every instance is automatically equipped with this attribute, which
is a dictionary that stores all the ordinary attributes of the instance
(the variable names are keys, and the object references are values).
In class <code>A</code> there is only one attribute, so the
<code>self.__dict__</code> dictionary contains one key, <code>'v'</code>:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; a = A([1,2])
&gt;&gt;&gt; a.dump()
{'v': [1, 2]}
</code></pre>
<!-- end verbatim block -->

<p>
Another way of inspecting what an instance <code>a</code> contains is to call
<code>dir(a)</code>. This Python function
writes out the names of all methods and variables
(and more) of an object:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; dir(a)
'__doc__', '__init__', '__module__', 'dump', 'v']
</code></pre>
<!-- end verbatim block -->
The <code>__doc__</code> variable
is a docstring, similar to docstrings in
functions (see the section ref{sec:basic:docstring}),
i.e., a description of the class
appearing as a first string right after the <code>class</code> headline:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; a.__doc__
'A class for demo purposes.'
</code></pre>
<!-- end verbatim block -->

<p>
The <code>__module__</code> variable holds the name of the module in
which the class is defined. If the class is defined in the program itself and
not in an imported module,  <code>__module__</code> equals
<code>'__main__'</code>.

<p>
The rest of the entries in the list returned
from <code>dir(a)</code> correspond to method and attribute names defined by
the programmer of the class, in this example the methods
<code>__init__</code> and  <code>dump</code>, and
the attribute <code>v</code>.

<p>
Now, let us try to add new variables to an existing instance:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; a.myvar = 10
&gt;&gt;&gt; a.dump()
{'myvar': 10, 'v': [1, 2]}
&gt;&gt;&gt; dir(a)
['__doc__', '__init__', '__module__', 'dump', 'myvar', 'v']
</code></pre>
<!-- end verbatim block -->
The output of <code>a.dump()</code> and <code>dir(a)</code> show that we were
successful in adding a new variable to this instance on the fly.
If we make
a new instance, it contains only the variables and methods that
we find in the definition of class <code>A</code>:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; b = A(-1)
&gt;&gt;&gt; b.dump()
{'v': -1}
&gt;&gt;&gt; dir(b)
['__doc__', '__init__', '__module__', 'dump', 'v']
</code></pre>
<!-- end verbatim block -->

<p>
We may also add new methods to an instance, but this will not be shown here.

<p>
Adding or removing attributes and methods
may sound scary and highly illegal to C, C++, and Java programmers,
but more dynamic classes is natural and legal in many other languages -
and often useful.

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Python classes are dynamic and their contents can be inspected.</b>
<p>
As seen by the examples above,

<ol>
<li> a class instance is dynamic and allows attributes to be added or
   removed while the program is running,</li>
<li> the contents of an instance can be inspected by the <code>dir</code> function,
   and the data attributes are available through the <code>__dict__</code> dictionary.</li>
</ol>

There is a special module, <code>inspect</code>, doing more detailed inspection
of Python objects. One can, for example, get the arguments of
functions or methods and even inspect the code of the object.
</div>


<h1>Static methods and attributes <a name="sec:class:static"></a></h1>

Up to now, each instance has its own copy of attributes.
Sometimes it can be natural
to have attributes that are shared among all instances.
For example, we may have an attribute that counts how many
instances that have been made so far. We can exemplify how to
do this in a little class for points \( (x,y,z) \) in space:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; class SpacePoint:
...     counter = 0
...     def __init__(self, x, y, z):
...         self.p = (x, y, z)
...         SpacePoint.counter += 1
</code></pre>
<!-- end verbatim block -->
The <code>counter</code> attribute is initialized at the same indentation level
as the methods in the class, and the attribute is not prefixed
by <code>self</code>. Such attributes declared outside methods are shared among
all instances and called <em>static attributes</em>.
To access the <code>counter</code> attribute, we must prefix
by the classname <code>SpacePoint</code> instead of <code>self</code>:
<code>SpacePoint.counter</code>.
In the constructor we increase this common counter by 1, i.e.,
every time a new instance is made the counter is updated to keep track
of how many objects we have created so far:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; p1 = SpacePoint(0,0,0)
&gt;&gt;&gt; SpacePoint.counter
1
&gt;&gt;&gt; for i in range(400):
...     p = SpacePoint(i*0.5, i, i+1)
...
&gt;&gt;&gt; SpacePoint.counter
401
</code></pre>
<!-- end verbatim block -->

<p>
The methods we have seen so far must be called through an instance, which is
fed in as the <code>self</code> variable in the method.
We can also make class methods that can be called without having an
instance. The method is then similar to a plain Python function, except that
it is contained inside a class and the method name must be prefixed
by the classname. Such methods are known as <em>static methods</em>.
Let us illustrate the syntax by making a very simple
class with just one static method <code>write</code>:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; class A:
...     @staticmethod
...     def write(message):
...         print message
...
&gt;&gt;&gt; A.write('Hello!')
Hello!
</code></pre>
<!-- end verbatim block -->
As demonstrated, we can call <code>write</code> without having any instance
of class <code>A</code>, we just prefix with the class name. Also note that
<code>write</code> does not take a <code>self</code> argument.
Since this argument is missing inside the method, we can never access
non-static attributes since these always must be prefixed by an instance
(i.e., <code>self</code>). However, we can access static attributes, prefixed
by the classname.

<p>
If desired, we can make an instance and call <code>write</code> through
that instance too:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; a = A()
&gt;&gt;&gt; a.write('Hello again')
Hello again
</code></pre>
<!-- end verbatim block -->
Static methods are used when you want a global function, but find it
natural to let the function belong to a class and be prefixed with
the classname.

<h1>Summary  <a name="___sec61"></a></h1>

<h2>Chapter topics <a name="sec:class:summary"></a></h2>

<h3>Classes  <a name="___sec63"></a></h3>

A class contains attributes (variables) and methods.
A first rough overview of a class can be to just list the
attributes and methods, e.g., in a UML diagram.

<p>
Below is a sample class with three attributes (<code>m</code>, <code>M</code>, and
<code>G</code>) and three methods (a constructor, <code>force</code>, and <code>visualize</code>).
The class represents the gravity force between two masses. This force
is computed by the <code>force</code> method, while the <code>visualize</code> method plots
the force as a function of the distance between the masses.

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class Gravity:
    &quot;&quot;&quot;Gravity force between two physical objects.&quot;&quot;&quot;

    def __init__(self, m, M):
        self.m = m           # mass of object 1
        self.M = M           # mass of object 2
        self.G = 6.67428E-11 # gravity constant, m**3/kg/s**2

    def force(self, r):
        G, m, M = self.G, self.m, self.M
        return G*m*M/r**2

    def visualize(self, r_start, r_stop, n=100):
        from scitools.std import plot, linspace
        r = linspace(r_start, r_stop, n)
        g = self.force(r)
        title='Gravity force: m=%g, M=%g' % (self.m, self.M)
        plot(r, g, title=title)
</code></pre>
<!-- end verbatim block -->
Note that to access attributes inside the <code>force</code> method, and to
call the <code>force</code> method inside the <code>visualize</code> method, we must prefix
with <code>self</code>.
Also recall that all methods must take <code>self</code>, &quot;this&quot; instance,
as first argument, but the argument is left out in calls.
The assignment of attributes to a local variable (e.g., <code>G = self.G</code>)
inside methods is not necessary, but here it makes the mathematical
formula easier to read and compare with standard mathematical notation.

<p>
This class (found in file <a href="http://tinyurl.com/pwyasaa/class/Gravity.py" target="_self"><tt>Gravity.py</tt></a>)
can be used to find
the gravity force between the Moon and the Earth:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>mass_moon = 7.35E+22;  mass_earth = 5.97E+24
gravity = Gravity(mass_moon, mass_earth)
r = 3.85E+8  # Earth-Moon distance in meters
Fg = gravity.force(r)
print 'force:', Fg
</code></pre>
<!-- end verbatim block -->

<p>
<!-- bar plot of experiment type? n values, m bars next to each other for -->
<!-- each value -->

<h3>Special methods  <a name="___sec64"></a></h3>

A collection of special methods, with two leading and trailing underscores in
the method names, offers special syntax in Python programs.

<p>
The table below provides an overview of the
most important special methods.

<p>
<table border="1">
<thead>
<tr><th align="center">                          Construction                          </th> <th align="center">                            Meaning2                            </th> </tr>
</thead>
<tbody>
<tr><td align="left">   <code>a.__init__(self, args)</code>                                 </td> <td align="left">   constructor: <code>a = A(args)</code>                               </td> </tr>
<tr><td align="left">   <code>a.__del__(self)</code>                                        </td> <td align="left">   destructor: <code>del a</code>                                      </td> </tr>
<tr><td align="left">   <code>a.__call__(self, args)</code>                                 </td> <td align="left">   call as function: <code>a(args)</code>                              </td> </tr>
<tr><td align="left">   <code>a.__str__(self)</code>                                        </td> <td align="left">   pretty print: <code>print a</code>, <code>str(a)</code>             </td> </tr>
<tr><td align="left">   <code>a.__repr__(self)</code>                                       </td> <td align="left">   representation: <code>a = eval(repr(a))</code>                      </td> </tr>
<tr><td align="left">   <code>a.__add__(self, b)</code>                                     </td> <td align="left">   <code>a + b</code>                                                  </td> </tr>
<tr><td align="left">   <code>a.__sub__(self, b)</code>                                     </td> <td align="left">   <code>a - b</code>                                                  </td> </tr>
<tr><td align="left">   <code>a.__mul__(self, b)</code>                                     </td> <td align="left">   <code>a*b</code>                                                    </td> </tr>
<tr><td align="left">   <code>a.__div__(self, b)</code>                                     </td> <td align="left">   <code>a/b</code>                                                    </td> </tr>
<tr><td align="left">   <code>a.__radd__(self, b)</code>                                    </td> <td align="left">   <code>b + a</code>                                                  </td> </tr>
<tr><td align="left">   <code>a.__rsub__(self, b)</code>                                    </td> <td align="left">   <code>b - a</code>                                                  </td> </tr>
<tr><td align="left">   <code>a.__rmul__(self, b)</code>                                    </td> <td align="left">   <code>b*a</code>                                                    </td> </tr>
<tr><td align="left">   <code>a.__rdiv__(self, b)</code>                                    </td> <td align="left">   <code>b/a</code>                                                    </td> </tr>
<tr><td align="left">   <code>a.__pow__(self, p)</code>                                     </td> <td align="left">   <code>a**p</code>                                                   </td> </tr>
<tr><td align="left">   <code>a.__lt__(self, b)</code>                                      </td> <td align="left">   <code>a < b</code>                                                  </td> </tr>
<tr><td align="left">   <code>a.__gt__(self, b)</code>                                      </td> <td align="left">   <code>a > b</code>                                                  </td> </tr>
<tr><td align="left">   <code>a.__le__(self, b)</code>                                      </td> <td align="left">   <code>a <= b</code>                                                 </td> </tr>
<tr><td align="left">   <code>a.__ge__(self, b)</code>                                      </td> <td align="left">   <code>a => b</code>                                                 </td> </tr>
<tr><td align="left">   <code>a.__eq__(self, b)</code>                                      </td> <td align="left">   <code>a == b</code>                                                 </td> </tr>
<tr><td align="left">   <code>a.__ne__(self, b)</code>                                      </td> <td align="left">   <code>a != b</code>                                                 </td> </tr>
<tr><td align="left">   <code>a.__bool__(self)</code>                                       </td> <td align="left">   boolean expression, as in <code>if a:</code>                        </td> </tr>
<tr><td align="left">   <code>a.__len__(self)</code>                                        </td> <td align="left">   length of <code>a</code> (<code>int</code>): <code>len(a)</code>    </td> </tr>
<tr><td align="left">   <code>a.__abs__(self)</code>                                        </td> <td align="left">   <code>abs(a)</code>                                                 </td> </tr>
</tbody>
</table>

<h3>Terminology  <a name="___sec65"></a></h3>

The important computer science topics in this document are

<ul>
  <li> classes</li>
  <li> methods</li>
  <li> attributes</li>
  <li> constructor (<code>__init__</code>)</li>
  <li> special methods (<code>__add__</code>, <code>__str__</code>, <code>__ne__</code>, etc.)</li>
</ul>

<h2>Example: interval arithmetic  <a name="___sec66"></a></h2>

Input data to mathematical formulas are often subject to uncertainty,
usually because physical measurements of many quantities involve
measurement errors, or because it is difficult to measure a parameter and
one is forced to make a qualified guess of the value instead.
In such cases it could be more natural to specify an input parameter
by an interval \( [a,b] \), which is guaranteed to contain the true value
of the parameter. The size of the interval expresses the uncertainty
in this parameter. Suppose all input parameters are specified as
intervals, what will be the interval, i.e., the uncertainty, of the
output data from the formula? This section develops a tool for
computing this output uncertainty in the cases where
the overall computation consists
of the standard arithmetic operations.

<p>
To be specific, consider measuring the acceleration of gravity by
dropping a ball and recording the time it takes to reach the ground.
Let the ground correspond to \( y=0 \) and let the ball be dropped
from \( y=y_0 \). The position of the ball, \( y(t) \), is then

$$
\begin{equation*} y(t) = y_0 - \frac{1}{2}gt^2 \thinspace . \end{equation*}
$$

If \( T \) is the time it takes to reach the ground, we have that \( y(T)=0 \),
which gives the equation \( \frac{1}{2}gT^2=y_0 \), with solution

$$
\begin{equation*}g = 2y_0T^{-2} \thinspace . \end{equation*}
$$

In such experiments we always
introduce some measurement error in the start position \( y_0 \) and in
the time taking (\( T \)). Suppose \( y_0 \) is known to lie in \( [0.99,1.01] \) m
and \( T \) in \( [0.43, 0.47] \) s, reflecting a
2% measurement error in position and a 10% error
from using a stop watch. What is the error in \( g \)? With the tool to
be developed below, we can find that there is a 22% error in \( g \).

<h3>Problem  <a name="___sec67"></a></h3>

Assume that two numbers \( p \) and \( q \) are guaranteed to lie inside intervals,

$$
\begin{equation*} p=[a,b], \quad q = [c, d] \thinspace . \end{equation*}
$$

The sum \( p+q \) is then guaranteed to lie inside an interval \( [s,t] \)
where \( s=a+c \) and \( t=b+d \). Below we list the rules of
<em>interval arithmetic</em>, i.e.,
the rules for addition,
subtraction, multiplication, and division of two intervals:

<ul>
  <li> \( p+q = [a + c, b + d] \)</li>
  <li> \( p-q = [a - d, b - c] \)</li>
  <li> \( pq =  [\min(ac, ad, bc, bd), \max(ac, ad, bc, bd)] \)</li>
  <li> \( p/q = [\min(a/c, a/d, b/c, b/d), \max(a/c, a/d, b/c, b/d)] \) provided that \( [c,d] \) does not contain zero</li>
</ul>

For doing these calculations in a program, it would be natural to have
a new type for quantities specified by intervals. This new type
should support
the operators <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code> according to the
rules above.
The task is hence to implement a class for interval arithmetic with
special methods for the listed operators.
Using the class, we should be able to estimate the uncertainty
of two formulas:

<ul>
  <li> The acceleration of gravity, \( g=2y_0T^{-2} \), given a 2% uncertainty in \( y_0 \): \( y_0=[0.99,1.01] \), and a 10% uncertainty in \( T \): \( T=[T_m\cdot 0.95, T_m\cdot 1.05] \), with \( T_m=0.45 \).</li>
  <li> The volume of a sphere, \( V=\frac{4}{3}\pi R^3 \), given a 20% uncertainty in \( R \): \( R=[R_m\cdot 0.9, R_m\cdot 1.1] \), with \( R_m =6 \).</li>
</ul>

<h3>Solution  <a name="___sec68"></a></h3>

The new type is naturally realized as a class <code>IntervalMath</code>
whose data consist of
the lower and upper bound of the interval. Special methods are used to
implement arithmetic operations and printing of the object.
Having understood class <code>Vec2D</code> from the section <a href="#sec:class:Vec2D">Example: Class for vectors in the plane</a>,
it should be straightforward to understand the class below:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class IntervalMath:
    def __init__(self, lower, upper):
        self.lo = float(lower)
        self.up = float(upper)

    def __add__(self, other):
        a, b, c, d = self.lo, self.up, other.lo, other.up
        return IntervalMath(a + c, b + d)

    def __sub__(self, other):
        a, b, c, d = self.lo, self.up, other.lo, other.up
        return IntervalMath(a - d, b - c)

    def __mul__(self, other):
        a, b, c, d = self.lo, self.up, other.lo, other.up
        return IntervalMath(min(a*c, a*d, b*c, b*d),
                            max(a*c, a*d, b*c, b*d))

    def __div__(self, other):
        a, b, c, d = self.lo, self.up, other.lo, other.up
        # [c,d] cannot contain zero:
        if c*d &lt;= 0:
            raise ValueError\ 
                  ('Interval %s cannot be denominator because '\ 
                  'it contains zero')
        return IntervalMath(min(a/c, a/d, b/c, b/d),
                            max(a/c, a/d, b/c, b/d))

    def __str__(self):
        return '[%g, %g]' % (self.lo, self.up)
</code></pre>
<!-- end verbatim block -->
The code of this class is found in the file
<a href="http://tinyurl.com/pwyasaa/class/IntervalMath.py" target="_self"><tt>IntervalMath.py</tt></a>.
A quick demo of the class can go as

<p>
<!-- begin verbatim block  pycod-->
<pre><code>I = IntervalMath
a = I(-3,-2)
b = I(4,5)
expr = 'a+b', 'a-b', 'a*b', 'a/b'
for e in expr:
    print '%s =' % e, eval(e)
</code></pre>
<!-- end verbatim block -->
The output becomes

<p>
<!-- begin verbatim block  ccq-->
<pre><code>a+b = [1, 3]
a-b = [-8, -6]
a*b = [-15, -8]
a/b = [-0.75, -0.4]
</code></pre>
<!-- end verbatim block -->
This gives the impression that with very short code we can
provide a new type that
enables computations with interval arithmetic and thereby with uncertain
quantities. However, the class above has severe limitations as shown
next.

<p>
<!-- === Extending the Class === -->

<p>
Consider computing the uncertainty of \( aq \) if \( a \) is
expressed as an interval \( [4,5] \) and \( q \) is a number (<code>float</code>):

<p>
<!-- begin verbatim block  pycod-->
<pre><code>a = I(4,5)
q = 2
b = a*q
</code></pre>
<!-- end verbatim block -->
This does not work so well:

<p>
<!-- begin verbatim block  ccq-->
<pre><code>  File &quot;IntervalMath.py&quot;, line 15, in __mul__
    a, b, c, d = self.lo, self.up, other.lo, other.up
AttributeError: 'float' object has no attribute 'lo'
</code></pre>
<!-- end verbatim block -->
The problem is that <code>a*q</code> is a multiplication between
an <code>IntervalMath</code> object <code>a</code> and a <code>float</code> object <code>q</code>.
The <code>__mul__</code> method in class <code>IntervalMath</code> is invoked,
but the code there tries to extract the <code>lo</code> attribute of <code>q</code>,
which does not exist since <code>q</code> is a <code>float</code>.

<p>
We can extend the <code>__mul__</code> method and the other methods for
arithmetic operations to allow for a number as operand - we just
convert the number to an interval with the same lower and upper bounds:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>    def __mul__(self, other):
        if isinstance(other, (int, float)):
            other = IntervalMath(other, other)
        a, b, c, d = self.lo, self.up, other.lo, other.up
        return IntervalMath(min(a*c, a*d, b*c, b*d),
                            max(a*c, a*d, b*c, b*d))
</code></pre>
<!-- end verbatim block -->

<p>
Looking at the formula \( g=2y_0T^{-2} \), we run into a related problem:
now we want to multiply \( 2 \) (<code>int</code>)
with \( y_0 \), and if \( y_0 \) is an interval,
this multiplication is not defined among <code>int</code> objects.
To handle this case,
we need to implement an <code>__rmul__(self, other)</code> method
for doing <code>other*self</code>, as explained in the section <a href="#sec:class:complex:rightop">Special methods for &quot;right&quot; operands</a>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>    def __rmul__(self, other):
        if isinstance(other, (int, float)):
            other = IntervalMath(other, other)
        return other*self
</code></pre>
<!-- end verbatim block -->
Similar methods for addition, subtraction, and division must also be
included in the class.

<p>
Returning to \( g=2y_0T^{-2} \), we also have a problem with \( T^{-2} \) when
\( T \) is an interval. The expression <code>T**(-2)</code> invokes the
power operator (at least if we do not rewrite the expression as
<code>1/(T*T)</code>), which requires a <code>__pow__</code> method
in class <code>IntervalMath</code>. We limit the
possibility to have integer powers, since this is easy to compute
by repeated multiplications:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>    def __pow__(self, exponent):
        if isinstance(exponent, int):
            p = 1
            if exponent &gt; 0:
                for i in range(exponent):
                    p = p*self
            elif exponent &lt; 0:
                for i in range(-exponent):
                    p = p*self
                p = 1/p
            else:   # exponent == 0
                p = IntervalMath(1, 1)
            return p
        else:
            raise TypeError('exponent must int')
</code></pre>
<!-- end verbatim block -->
Another natural extension of the class
is the possibility to convert an interval to
a number by choosing the midpoint of the interval:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; a = IntervalMath(5,7)
&gt;&gt;&gt; float(a)
6
</code></pre>
<!-- end verbatim block -->
<code>float(a)</code> calls <code>a.__float__()</code>, which we implement as

<p>
<!-- begin verbatim block  pycod-->
<pre><code>    def __float__(self):
        return 0.5*(self.lo + self.up)
</code></pre>
<!-- end verbatim block -->
A <code>__repr__</code> method returning the right syntax for recreating the
present instance is also natural to include in any class:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>    def __repr__(self):
        return '%s(%g, %g)' % \ 
               (self.__class__.__name__, self.lo, self.up)
</code></pre>
<!-- end verbatim block -->

<p>
<!-- === Demonstrating the Class === -->

<p>
We are now in a position to test out the extended class <code>IntervalMath</code>.

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; g = 9.81
&gt;&gt;&gt; y_0 = I(0.99, 1.01)      # 2% uncertainty
&gt;&gt;&gt; Tm = 0.45                # mean T
&gt;&gt;&gt; T = I(Tm*0.95, Tm*1.05)  # 10% uncertainty
&gt;&gt;&gt; print T
[0.4275, 0.4725]
&gt;&gt;&gt; g = 2*y_0*T**(-2)
&gt;&gt;&gt; g
IntervalMath(8.86873, 11.053)
&gt;&gt;&gt; # Compute with mean values
&gt;&gt;&gt; T = float(T)
&gt;&gt;&gt; y = 1
&gt;&gt;&gt; g = 2*y_0*T**(-2)
&gt;&gt;&gt; print '%.2f' % g
9.88
</code></pre>
<!-- end verbatim block -->

<p>
Another formula, the volume \( V=\frac{4}{3}\pi R^3 \) of a sphere,
shows great sensitivity to uncertainties in \( R \):

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; Rm = 6
&gt;&gt;&gt; R = I(Rm*0.9, Rm*1.1)   # 20 % error
&gt;&gt;&gt; V = (4./3)*pi*R**3
&gt;&gt;&gt; V
IntervalMath(659.584, 1204.26)
&gt;&gt;&gt; print V
[659.584, 1204.26]
&gt;&gt;&gt; print float(V)
931.922044761
&gt;&gt;&gt; # Compute with mean values
&gt;&gt;&gt; R = float(R)
&gt;&gt;&gt; V = (4./3)*pi*R**3
&gt;&gt;&gt; print V
904.778684234
</code></pre>
<!-- end verbatim block -->
Here, a 20% uncertainty in \( R \) gives almost 60% uncertainty in \( V \),
and the mean of the \( V \) interval is significantly different from
computing the volume with the mean of \( R \).
<!-- >>> R.width_in_percent() -->
<!-- 19.999999999999986 -->
<!-- >>> V.width_in_percent() -->
<!-- 58.446601941747581 -->

<p>
The complete code of class <code>IntervalMath</code> is found in
<code>IntervalMath.py</code>. Compared to the implementations shown above,
the real implementation in the file employs some ingenious constructions
and help methods to save typing and repeating code in the special
methods for arithmetic operations.

<h1>Exercises  <a name="___sec69"></a></h1>

<!-- --- begin exercise --- -->

<h2>Exercise 1: Make a function class <a name="sec:class:ex2"></a></h2>

Make a class <code>F</code> that implements the function

$$
\begin{equation*} f(x; a, w)=e^{-ax}\sin(wx) \thinspace . \end{equation*}
$$

A <code>value(x)</code> method computes values of \( f \), while \( a \) and \( w \) are class
attributes.
Test the class in an interactive session:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; from F import F
&gt;&gt;&gt; f = F(a=1.0, w=0.1)
&gt;&gt;&gt; from math import pi
&gt;&gt;&gt; print f.value(x=pi)
0.013353835137
&gt;&gt;&gt; f.a = 2
&gt;&gt;&gt; print f.value(pi)
0.00057707154012
</code></pre>
<!-- end verbatim block -->
Filename: <code>F.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 2: Add an attribute to a class <a name="sec:class:ex25q"></a></h2>

Add an attribute <code>transactions</code> to the <code>Account</code> class from
the section <a href="#sec:class:account">Bank accounts</a>. The new attribute counts the number
of transactions done in the <code>deposit</code> and <code>withdraw</code> methods.
Print the total number of transactions in the <code>dump</code>
method. Write a test function <code>test_Account()</code> for testing that the
implementation of the extended class <code>Account</code> is correct.
Filename: <code>Account2.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 3: Add functionality to a class <a name="sec:class:ex25q2"></a></h2>

In class <code>Account</code> from the section <a href="#sec:class:account">Bank accounts</a>, introduce a
list <code>transactions</code>, where each element holds a dictionary with the
amount of a transaction and the point of time the transaction took
place. Remove the <code>balance</code> attribute and use instead the
<code>transactions</code> list to compute the balance in <code>get_balance</code>.  Print
out a nicely formatted table of all transactions, their amounts, and
their time in a method <code>print_transactions</code>.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Use the <code>time</code> module to get the date and local time.

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>Account3.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 4: Make classes for a rectangle and a triangle <a name="sec:class:ex23"></a></h2>

The purpose of this exercise is to create classes like
class <code>Circle</code> from the section <a href="#sec:class:circle">A circle</a> for
representing other geometric figures: a rectangle with width
\( W \), height \( H \), and lower left corner \( (x_0, y_0) \); and
a general triangle specified by its
three vertices \( (x_0,y_0) \), \( (x_1,y_1) \), and
\( (x_2,y_2) \) as explained in ref{sec:basic:ex25}.
Provide three methods: <code>__init__</code> (to initialize the geometric data),
<code>area</code>, and <code>perimeter</code>. Write test functions <code>test_Rectangle()</code>
and <code>test_Triangle()</code> for
checking that the results produced by <code>area</code> and <code>perimeter</code>
coincide with exact values within a small tolerance.
Filename: <code>geometric_shapes.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 5: Make a class for quadratic functions <a name="sec:class:ex11"></a></h2>

Consider a quadratic function \( f(x;a,b,c)=ax^2 + bx + c \).
Make a class <code>Quadratic</code>
for representing \( f \), where \( a \), \( b \), and \( c \) are attributes, and
the methods are

<ul>
  <li> <code>value</code> for computing a value of \( f \) at a point \( x \),</li>
  <li> <code>table</code> for writing out a table of \( x \) and \( f \) values for \( n \) $x$ values in the interval \( [L,R] \),</li>
  <li> <code>roots</code> for computing the two roots.</li>
</ul>

The file with class <code>Quadratic</code> and corresponding demonstrations and/or
tests should be organized as a module such that other programs can
do a <code>from Quadratic import Quadratic</code> to use the class.
Filename: <code>Quadratic.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 6: Make a class for straight lines <a name="sec:class:ex25"></a></h2>

Make a class <code>Line</code> whose constructor takes two points
<code>p1</code> and <code>p2</code> (2-tuples or 2-lists) as input.
The line goes through these two
points (see function <code>line</code> in the section ref{sec:basic:docstring} for
the relevant formula of the line).
A <code>value(x)</code> method computes a value on the line
at the point <code>x</code>. Also make
a function <code>test_Line()</code> for verifying the implementation.
Here is a demo in an interactive session:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; from Line import Line, test_Line
&gt;&gt;&gt; line = Line((0,-1), (2,4))
&gt;&gt;&gt; print line.value(0.5), line.value(0), line.value(1)
0.25 -1.0 1.5
&gt;&gt;&gt; test_Line()
</code></pre>
<!-- end verbatim block -->
Filename: <code>Line.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 7: Flexible handling of function arguments <a name="sec:class:ex25b"></a></h2>

The constructor in class <code>Line</code> in <a href="#sec:class:ex25">Exercise 6: Make a class for straight lines</a> takes
two points as arguments.  Now we want to have more flexibility in the
way we specify a straight line: we can give two points, a point and a
slope, or a slope and the line's interception with the \( y \) axis.
Write this extended class and a test function for checking that the
increased flexibility does work.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Let the constructor take two arguments <code>p1</code> and <code>p2</code>
as before, and test with
<code>isinstance</code> whether the
arguments are <code>float</code> versus <code>tuple</code> or <code>list</code> to determine
what kind of data the user supplies:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>if isinstance(p1, (tuple,list)) and isinstance(p2, (float,int)):
    # p1 is a point and p2 is slope
    self.a = p2
    self.b = p1[1] - p2*p1[0]
elif ...
</code></pre>
<!-- end verbatim block -->

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>Line2.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 8: Wrap functions in a class <a name="sec:class:ex27d"></a></h2>

The purpose of this exercise is to make a class interface to an
already existing set of functions implementing Lagrange's
interpolation method from ref{sec:class:ex27a}.  We want to
construct a class <code>LagrangeInterpolation</code> with a typical usage like:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import numpy as np
# Compute some interpolation points along y=sin(x)
xp = np.linspace(0, np.pi, 5)
yp = np.sin(xp)

# Lagrange's interpolation polynomial
p_L = LagrangeInterpolation(xp, yp)
x = 1.2
print 'p_L(%g)=%g' % (x, p_L(x)),
print 'sin(%g)=%g' % (x, np.sin(x))
p_L.plot()   # show graph of p_L
</code></pre>
<!-- end verbatim block -->
The <code>plot</code> method visualizes \( p_L(x) \) for \( x \) between the first
and last interpolation point (<code>xp[0]</code> and <code>xp[-1]</code>).
In addition to writing the class itself, you should write code to verify
the implementation.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
The class does not need much code as it can call
the functions <code>p_L</code> from
ref{sec:class:ex27a} and
<code>graph</code> from ref{sec:class:ex27b}, available in
the <code>Lagrange_poly2</code> module made in the latter exercise.

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>Lagrange_poly3.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 9: Flexible handling of function arguments <a name="sec:class:ex27e"></a></h2>

Instead of manually computing the interpolation points,
as demonstrated in <a href="#sec:class:ex27d">Exercise 8: Wrap functions in a class</a>, we now want
the constructor in class <code>LagrangeInterpolation</code> to also
accept some Python function <code>f(x)</code> for computing
the interpolation points.
Typically, we would like to write
this code:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>from numpy import exp, sin, pi

def myfunction(x):
    return exp(-x/2.0)*sin(x)

p_L = LagrangeInterpolation(myfunction, x=[0, pi], n=11)
</code></pre>
<!-- end verbatim block -->
With such a code, \( n=11 \) uniformly distributed \( x \) points between
\( 0 \) and \( \pi \) are computed, and the corresponding \( y \) values are
obtained by calling <code>myfunction</code>.
The Lagrange interpolation polynomial is then constructed from
these points. Note that the previous types of calls,
<code>LangrangeInterpolation(xp, yp)</code>, must still be valid.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
The constructor in class <code>LagrangeInterpolation</code> must now
accept two different sets of arguments: <code>xp, yp</code> vs. <code>f, x, n</code>.
You can use the <code>isinstance(a, t)</code> function to test if object <code>a</code> is
of type <code>t</code>. Declare the constructor with three
arguments <code>arg1</code>, <code>arg2</code>, and <code>arg3=None</code>. Test
if <code>arg1</code> and <code>arg2</code> are arrays
(<code>isinstance(arg1, numpy.ndarray)</code>), and
in that case, set <code>xp=arg1</code> and <code>yp=arg2</code>. On the other hand,
if <code>arg1</code> is a function (<code>callable(arg1)</code> is <code>True</code>),
<code>arg2</code> is a list or tuple (<code>isinstance(arg2, (list,tuple))</code>),
and <code>arg3</code> is an integer, set
<code>f=arg1</code>, <code>x=arg2</code>, and <code>n=arg3</code>.

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>Lagrange_poly4.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 10: Deduce a class implementation <a name="sec:class:ex1"></a></h2>

Write a class <code>Hello</code> that behaves as illustrated in the following
session:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; a = Hello()
&gt;&gt;&gt; print a('students')
Hello, students!
&gt;&gt;&gt; print a
Hello, World!
</code></pre>
<!-- end verbatim block -->
Filename: <code>Hello.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 11: Implement special methods in a class <a name="sec:class:ex2b2"></a></h2>

Modify the class from <a href="#sec:class:ex2">Exercise 1: Make a function class</a>
such that the following interactive session can be run:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; from F import F
&gt;&gt;&gt; f = F(a=1.0, w=0.1)
&gt;&gt;&gt; from math import pi
&gt;&gt;&gt; print f(x=pi)
0.013353835137
&gt;&gt;&gt; f.a = 2
&gt;&gt;&gt; print f(pi)
0.00057707154012
&gt;&gt;&gt; print f
exp(-a*x)*sin(w*x)
</code></pre>
<!-- end verbatim block -->
Filename: <code>F2.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 12: Make a class for summation of series <a name="sec:class:ex2b"></a></h2>

The task in this exercise is to calculate a sum \( S(x)=\sum_{k=M}^N f_k(x) \),
where \( f_k(x) \) is some user-given formula for the terms in the sum.
The following snippet demonstrates the typical use and functionality
of a class <code>Sum</code> for computing \( S(x)= \sum_{k=0}^N (-x)^k \):

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def term(k, x):
    return (-x)**k

S = Sum(term, M=0, N=3)
x = 0.5
print S(x)
print S.term(k=4)
</code></pre>
<!-- end verbatim block -->
The latter statement prints the term \( (-x)^4 \).

<p>
<b>a)</b>
Implement class <code>Sum</code> such that the code snippet above works.

<p>
<b>b)</b>
Implement a test function <code>test_Sum()</code> for verifying the results of
the various methods in class <code>Sum</code> for a specific choice of \( f_k(x) \).

<p>
<b>c)</b>
Apply class <code>Sum</code> to compute the Taylor polynomial approximation to
\( \sin x \) for \( x=\pi \) and some chosen \( x \) and \( N \).

<p>
Filename: <code>Sum.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 13: Apply a numerical differentiation class <a name="sec:class:ex10"></a></h2>

Isolate class <code>Derivative</code> from the section <a href="#sec:class:autodF">Example: Automagic differentiation</a>
in a module file. Also isolate class <code>Y</code> from
the section <a href="#sec:class:func2">Representing a function as a class</a> in a module file.
Make a program that imports class <code>Derivative</code> and class
<code>Y</code> and applies the former to differentiate the
function \( y(t)=v_0t - \frac{1}{2}gt^2 \) represented by class <code>Y</code>.
Compare the computed derivative with the exact value for
\( t=0, \frac{1}{2}v_0/g, v_0/g \).
Filenames: <code>dYdt.py</code>, <code>Derivative.py</code>, <code>Y.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 14: Apply symbolic differentiation <a name="sec:class:exer:sympy:diff"></a></h2>

Class <code>Derivative</code> from the section <a href="#sec:class:autodF">Example: Automagic differentiation</a> applies numerical
differentiation. With the aid of <code>sympy</code> we can quite easily
offer exact differentiation. Extend class <code>Derivative</code> such
that the differentiation is exact if the user supplies a <code>sympy</code>
expression as argument to the constructor:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; def f(x):
        return x**3
...
&gt;&gt;&gt; import sympy
&gt;&gt;&gt; x = sympy.symbols('x')
&gt;&gt;&gt; symbolic_formula = f(x)
&gt;&gt;&gt; dfdx = Derivative(symbolic_formula)
&gt;&gt;&gt; x = 2
&gt;&gt;&gt; dfdx(x)
12
</code></pre>
<!-- end verbatim block -->

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Introduce a test on the type of argument in the constructor in
class <code>Derivative</code>: if <code>str(type(f))</code> starts with <code>sympy</code>,
<code>f</code> is a <code>sympy</code> expression that we can differentiate with
<code>sympy.diff</code> and turn the result into a plain Python with
<code>sympy.lamdify</code>,
see the section ref{sec:formula:sympy:diffint}.

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>Derivative_sympy.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 15: Implement in-place <code>+=</code> and <code>-=</code> operators <a name="sec:class:ex25qb"></a></h2>

As alternatives to the <code>deposit</code> and <code>withdraw</code> methods
in class  <code>Account</code> class from
the section <a href="#sec:class:account">Bank accounts</a>, we could use the operation <code>+=</code> for
<code>deposit</code> and <code>-=</code> for <code>withdraw</code>.
Implement the <code>+=</code> and <code>-=</code> operators, a
<code>__str__</code> method, and preferably a
<code>__repr__</code> method in class <code>Account</code>. Write a <code>test_Account()</code>
function to verify the implementation of all functionality
in class <code>Account</code>.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
The special methods <code>__iadd__</code> and <code>__isub__</code>
implement the <code>+=</code> and <code>-=</code> operators, respectively.
For instance, <code>a -= p</code> implies a call to <code>a.__isub__(p)</code>.
One important feature of <code>__iadd__</code> and <code>__isub__</code>
is that they must return <code>self</code> to work properly,
see the documentation of these
methods in Chapter 3 of the <a href="http://docs.python.org/2/reference/" target="_self">Python Language Reference</a>.

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>Account4.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 16: Implement a class for numerical differentiation <a name="sec:class:ex21"></a></h2>

<!-- Class <code>Derivative</code> from the section <a href="#sec:class:autodF">Example: Automagic differentiation</a> applies the -->
<!-- simple formula <a href="#mjx-eqn-1">(1)</a> for numerical differentiation. -->
<!-- An alternative and usually better formula is -->
A widely used formula for numerical differentiation of a function \( f(x) \)
takes the form

$$
\begin{align}
f'(x) & \approx  {f(x+h) - f(x-h)\over 2h} \tp
\tag{3}
\end{align}
$$

This formula usually gives more accurate derivatives than
<a href="#mjx-eqn-1">(1)</a> because it applies a centered, rather than
a one-sided, difference.

<p>
The goal of this exercise is to use the formula <a href="#mjx-eqn-3">(3)</a>
to automatically differentiate a mathematical function \( f(x) \) implemented
as a Python function <code>f(x)</code>. More precisely, the following
code should work:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def f(x):
    return 0.25*x**4

df = Central(f)  # make function-like object df
# df(x) computes the derivative of f(x) approximately
x = 2
print 'df(%g)=%g' % (x, df(x))
print 'exact:',  x**3
</code></pre>
<!-- end verbatim block -->

<p>
<b>a)</b>
Implement class <code>Central</code> and test that the code above works.
Include an optional argument <code>h</code> to the constructor in class
<code>Central</code> so that \( h \) in the
approximation <a href="#mjx-eqn-3">(3)</a> can be specified.

<p>
<b>b)</b>
Write a test function <code>test_Central()</code> to verify the implementation.
Utilize the fact that the formula <a href="#mjx-eqn-3">(3)</a> is
exact for quadratic polynomials.

<p>
<b>c)</b>
Write a function <code>table(f, x, h=1E-5)</code> that prints a
table of errors in the numerical derivative <a href="#mjx-eqn-3">(3)</a>
applied to a function <code>f</code> at some points <code>x</code>.
The argument <code>f</code> is a <code>sympy</code> expression for
a function. This <code>f</code> object can be transformed to a Python function and fed
to the constructor of class <code>Central</code>, and <code>f</code> can be used to compute
the exact derivative symbolically.
The argument <code>x</code> is a list or array of points \( x \), and <code>h</code> is the \( h \)
in <a href="#mjx-eqn-3">(3)</a>.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
The following session demonstrates how <code>sympy</code> can differentiate a
mathematical expression and turn the result into a Python
function:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; import sympy
&gt;&gt;&gt; x = sympy.Symbol('x')
&gt;&gt;&gt; f_expr = 'x*sin(2*x)'
&gt;&gt;&gt; df_expr = sympy.diff(f_expr)
&gt;&gt;&gt; df_expr
2*x*cos(2*x) + sin(2*x)
&gt;&gt;&gt; df = sympy.lambdify([x], df_expr)  # make Python function
&gt;&gt;&gt; df(0)
0.0
</code></pre>
<!-- end verbatim block -->

<p>
<!-- --- end hint in exercise --- -->

<p>
<b>d)</b>
Organize the file with the class and functions such that it can be
used a module.

<p>
Filename: <code>Central.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 17: Examine a program <a name="sec:class:ex21b"></a></h2>

Consider this program file for computing a backward difference approximation
to the derivative of a function <code>f(x)</code>:

<p>
<!-- begin verbatim block  pypro-->
<pre><code>from math import *

class Backward:
    def __init__(self, f, h=e-9):
        self.f, self.h = f, h
    def __call__(self, x):
        h, f = self.h, self.f
        return (f(x) - f(x-h))/h  # finite difference

dsin = Backward(sin)
e = dsin(0) - cos(0); print 'error:', e
dexp = Backward(exp, h=e-7)
e = dexp(0) - exp(0); print 'error:', e
</code></pre>
<!-- end verbatim block -->
The output becomes

<p>
<!-- begin verbatim block  ccq-->
<pre><code>error: -1.00023355634
error: 371.570909212
</code></pre>
<!-- end verbatim block -->
Is the approximation that bad, or are there bugs in the program?

<p>
<!-- h=e-7 means e - 7! Same with e-9 -->
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 18: Modify a class for numerical differentiation <a name="sec:class:ex23s"></a></h2>

Make the two attributes <code>h</code> and <code>f</code> of class
<code>Derivative</code> from the section <a href="#sec:class:autodF">Example: Automagic differentiation</a> protected as
explained in the section <a href="#sec:class:account">Bank accounts</a>. That is, prefix <code>h</code> and
<code>f</code> with an underscore to tell users that these attributes should not be
accessed directly. Add two methods <code>get_precision()</code> and
<code>set_precision(h)</code> for reading and changing <code>h</code>.
Filename: <code>Derivative_protected.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 19: Make a class for the Heaviside function <a name="sec:basic:exHclass"></a></h2>

the exercise &quot;Implement a
smoothed Heaviside function&quot; in the document <a href="http://tcse6.on.net/funcif" target="_self">Functions and
branching</a>,

<p>
<b>a)</b>
Use a class to implement the
discontinuous Heaviside function and smoothed continuous version, as defined
in the exercise &quot;Implement a
smoothed Heaviside function&quot; in the document <a href="http://tcse6.on.net/funcif" target="_self">Functions and
branching</a>,
such that the following code works:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>H = Heaviside()         # original discontinous Heaviside function
print H(0.1)
H = Heaviside(eps=0.8)  # smoothed continuous Heaviside function
print H(0.1)
</code></pre>
<!-- end verbatim block -->

<p>
<b>b)</b>
Extend class <code>Heaviside</code> such that
array arguments are allowed:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>H = Heaviside()         # original discontinous Heaviside function
x = numpy.linspace(-1, 1, 11)
print H(x)
H = Heaviside(eps=0.8)  # smoothed Heaviside function
print H(x)
</code></pre>
<!-- end verbatim block -->

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Use ideas from the section ref{sec:vec:Heaviside}.

<p>
<!-- --- end hint in exercise --- -->

<p>
<b>c)</b>
Extend class <code>Heaviside</code> such that it supports plotting:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>H = Heaviside()
x, y = H.plot(xmin=-4, xmax=4)  # x in [-4, 4]
from matplotlib.pyplot import plot
plot(x, y)

H = Heaviside(eps=1)
x, y = H.plot(xmin=-4, xmax=4)
plot(x, y)
</code></pre>
<!-- end verbatim block -->

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Techniques from the section ref{sec:plot:pwisefunc} must in the first case
be used to return arrays <code>x</code> and <code>y</code> such that the discontinuity is
exactly reproduced. In the continuous (smoothed) case, one needs to
compute a sufficiently fine resolution (<code>x</code>) based on the <code>eps</code>
parameter, e.g., 201/$\epsilon$ points in the interval \( [-\epsilon,
\epsilon] \), with a coarser set of coordinates outside this interval
where the smoothed Heaviside function is almost constant, 0 or 1.

<p>
<!-- --- end hint in exercise --- -->

<p>
<b>d)</b>
Write a test function <code>test_Heaviside()</code> for verifying the result
of the various methods in class <code>Heaviside</code>.

<p>
Filename: <code>Heaviside_class.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 20: Make a class for the indicator function <a name="sec:basic:exIndclass"></a></h2>

We shall work with indicator
functions as explained in the exercise &quot;Implement an indicator function&quot;
in the document <a href="http://tcse6.on.net/funcif" target="_self">Functions and
branching</a>. Make a class implementation
of such an indicator function, using a definition in terms of
Heaviside functions. Allow for an \( \epsilon \) parameter in the calls to the
Heaviside function such that
we can easily choose between a discontinuous and a smoothed,
continuous version of the indicator function:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>I = Indicator(a, b)          # indicator function on [a,b]
print I(b+0.1), I((a+b)/2.0)
I = Indicator(0, 2, eps=1)   # smoothed indicator function on [0,2]
print I(0), I(1), I(1.9)
</code></pre>
<!-- end verbatim block -->
Note that if you build on the version of class <code>Heaviside</code>
in <a href="#sec:basic:exHclass">Exercise 19: Make a class for the Heaviside function</a>b, any <code>Indicator</code> instance
will accept array arguments too.
Filename: <code>Indicator.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 21: Make a class for piecewise constant functions <a name="sec:basic:ex:piecewisefunc"></a></h2>

The purpose of this exercise is to implement a piecewise constant
function, as explained in ref{sec:basic:exH4}, in a Python
class.

<p>
<b>a)</b>
Implement the minimum functionality such that the following code works:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>f = PiecewiseConstant([(0.4, 1), (0.2, 1.5), (0.1, 3)], xmax=4)
print f(1.5), f(1.75), f(4)

x = np.linspace(0, 4, 21)
print f(x)
</code></pre>
<!-- end verbatim block -->

<p>
<b>b)</b>
Add a <code>plot</code> method to class <code>PiecewiseConstant</code>
such that we
can easily plot the graph of the function:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>x, y = f.plot()
from matplotlib.pyplot import plot
plot(x, y)
</code></pre>
<!-- end verbatim block -->

<p>
Filename: <code>PiecewiseConstant.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 22: Speed up repeated integral calculations <a name="sec:class:ex13c"></a></h2>

The observant reader may have noticed that our <code>Integral</code> class
from the section <a href="#sec:class:autoint">Example: Automagic integration</a>
is very inefficient if we want to tabulate or plot a
function \( F(x)=\int_a^xf(x) \) for several consecutive values of \( x \),
say \( x_0 < x_1 < \cdots < x_n \). Requesting \( F(x_k) \) will recompute
the integral computed as part of \( F(x_{k-1}) \), and this is of course
waste of computer work.
Use the ideas from the section ref{sec:diffeq:integral} to modify
the <code>__call__</code> method such that if <code>x</code> is an array,
assumed to contain coordinates of increasing value:
\( x_0 < x_1 < \cdots < x_n \), the method returns an array with
\( F(x_0), F(x_1),\ldots,F(x_n) \) with the minimum computational work.
Filename: <code>Integral_eff.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 23: Apply a class for polynomials <a name="sec:class:ex5"></a></h2>

The Taylor polynomial of degree \( N \) for the exponential function \( e^x \)
is given by

$$
\begin{equation*} p(x) = \sum_{k=0}^N {x^k\over k!} \thinspace . \end{equation*}
$$

Make a program that (i) imports class
<code>Polynomial</code> from the section <a href="#sec:class:Polynomial">Example: Class for polynomials</a>, (ii) reads  \( x \)
and a series of \( N \) values
from the command line, (iii) creates a
<code>Polynomial</code> instance representing the Taylor polynomial for each
\( N \) value, and (iv)
prints the values of \( p(x) \) for all the given \( N \) values as well as the
exact value \( e^x \).
Try the program out with
\( x=0.5, 3, 10 \) and \( N=2,5,10, 15, 25 \).
Filename: <code>Polynomial_exp.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 24: Find a bug in a class for polynomials <a name="sec:class:ex4"></a></h2>

Go through this alternative implementation of class
<code>Polynomial</code> from the section <a href="#sec:class:Polynomial">Example: Class for polynomials</a>
and explain each line in detail:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class Polynomial:
    def __init__(self, coefficients):
        self.coeff = coefficients

    def __call__(self, x):
        return sum([c*x**i for i, c in enumerate(self.coeff)])

    def __add__(self, other):
        maxlength = max(len(self), len(other))
        # Extend both lists with zeros to this maxlength
        self.coeff += [0]*(maxlength - len(self.coeff))
        other.coeff += [0]*(maxlength - len(other.coeff))
        result_coeff = self.coeff
        for i in range(maxlength):
            result_coeff[i] += other.coeff[i]
        return Polynomial(result_coeff)
</code></pre>
<!-- end verbatim block -->
The <code>enumerate</code> function, used in the <code>__call__</code> method,
enables us to iterate over a list <code>somelist</code> with
both list indices and list elements: <code>for index, element in enumerate(somelist)</code>.
Write the code above in a file, and demonstrate that adding two polynomials
does not work. Find the bug and correct it.
Filename: <code>Polynomial_error.py</code>.

<p>
<!-- result_coeff = self.coeff[:] -->
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 25: Implement subtraction of polynomials <a name="sec:class:ex6a"></a></h2>

Implement the special method <code>__sub__</code> in class
<code>Polynomial</code> from the section <a href="#sec:class:Polynomial">Example: Class for polynomials</a>.
Add a test for this functionality in function <code>test_Polynomial</code>.
Filename: <code>Polynomial_sub.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 26: Test the functionality of pretty print of polynomials <a name="sec:class:exer:str"></a></h2>

Verify the functionality of the <code>__str__</code> method in class <code>Polynomial</code> from
the section <a href="#sec:class:Polynomial">Example: Class for polynomials</a> by writing a new test function
<code>test_Polynomial_str()</code>.
Filename: <code>Polynomial_test_str.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 27: Vectorize a class for polynomials <a name="sec:class:ex7v"></a></h2>

Introducing an array instead of a list in class <code>Polynomial</code> does not
enhance the efficiency of the implementation unless the mathematical
computations are also vectorized. That is, all explicit Python loops
must be substituted by vectorized expressions.

<p>
<b>a)</b>
Go through class <code>Polynomial.py</code> and make sure the <code>coeff</code> attribute
is always a <code>numpy</code> array with <code>float</code> elements.

<p>
<b>b)</b>
Update the test function <code>test_Polynomial</code> to make use of the fact
that the <code>coeff</code> attribute is always a
<code>numpy</code> array with <code>float</code> elements. Run <code>test_Polynomial</code>
to check that the new implementation is correct.

<p>
<b>c)</b>
Vectorize the <code>__add__</code> method by adding the
common parts of the coefficients arrays and then appending
the rest of the longest array to the result.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Appending an array
<code>a</code> to an array <code>b</code> can be done by <code>concatenate(a, b)</code>.

<p>
<!-- --- end hint in exercise --- -->

<p>
<b>d)</b>
Vectorize the <code>__call__</code> method by
observing that evaluation of a polynomial, \( \sum_{i=0}^{n-1}c_ix^i \),
can be computed as the inner product of two arrays:
\( (c_0,\ldots,c_{n-1}) \) and \( (x^0,x^1,\ldots,x^{n-1}) \).
The latter array can be computed by <code>x**p</code>, where
<code>p</code> is an array with powers \( 0,1,\ldots,n-1 \), and <code>x</code>
is a scalar.

<p>
<b>e)</b>
The <code>differentiate</code> method can be vectorized by
the statements

<p>
<!-- begin verbatim block  pycod-->
<pre><code>n = len(self.coeff)
self.coeff[:-1] = linspace(1, n-1, n-1)*self.coeff[1:]
self.coeff = self.coeff[:-1]
</code></pre>
<!-- end verbatim block -->
Show by hand calculations in a case where <code>n</code> is 3 that
the vectorized statements produce the same result as the
original <code>differentiate</code> method.

<p>
Filename: <code>Polynomial_vec.py</code>.

<p>
<!-- Closing remarks for this Exercise -->

<h3>Remarks  <a name="___sec97"></a></h3>

The <code>__mul__</code> method is more challenging to vectorize so you may leave
this unaltered. Check that the
vectorized versions of <code>__add__</code>,
<code>__call__</code>, and <code>differentiate</code> work as intended by calling
the <code>test_Polynomial</code> function.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 28: Use a dict to hold polynomial coefficients <a name="sec:class:ex8"></a></h2>

Use a dictionary for the <code>coeff</code> attribute in class <code>Polynomial</code> from
the section <a href="#sec:class:Polynomial">Example: Class for polynomials</a> such that <code>self.coeff[k]</code> holds the
coefficient of the \( x^k \) term.  The advantage with a dictionary is
that only the nonzero coefficients need to be stored.

<p>
<b>a)</b>
Implement a constructor and the <code>__add__</code> method.

<p>
<b>b)</b>
Implement the <code>__mul__</code> method.

<p>
<b>c)</b>
Write a test function for verifying the implementations in a) and b)
when the polynomials \( x-3x^{100} \) and \( x^{20} - x +4x^{100} \) are added
and multiplied.

<p>
Filename: <code>Polynomial_dict.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 29: Extend class Vec2D to work with lists/tuples <a name="sec:class:ex16"></a></h2>

The <code>Vec2D</code> class from the section <a href="#sec:class:Vec2D">Example: Class for vectors in the plane</a> supports
addition and subtraction, but only addition and subtraction of two
<code>Vec2D</code> objects. Sometimes we would like to add or subtract a
point that is represented by a list or a tuple:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>u = Vec2D(-2, 4)
v = u + (1,1.5)
w = [-3, 2] - v
</code></pre>
<!-- end verbatim block -->
That is, a list or a tuple must be allowed in the right or left operand.
Implement such an extension of class <code>Vec2D</code>.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Ideas are found in the sections <a href="#sec:class:complex:mixed">Mixing complex and real numbers</a> and
<a href="#sec:class:complex:rightop">Special methods for &quot;right&quot; operands</a>.

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>Vec2D_lists.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 30: Extend class Vec2D to 3D vectors <a name="sec:class:ex17b"></a></h2>

Extend the implementation of class <code>Vec2D</code>
from the section <a href="#sec:class:Vec2D">Example: Class for vectors in the plane</a> to a class <code>Vec3D</code> for vectors
in three-dimensional space. Add a method <code>cross</code> for computing
the cross product of two 3D vectors.
Filename: <code>Vec3D.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 31: Use NumPy arrays in class Vec2D <a name="sec:class:ex17"></a></h2>

The internal code in class <code>Vec2D</code> from the section <a href="#sec:class:Vec2D">Example: Class for vectors in the plane</a>
can be valid for vectors in any space dimension if we represent the
vector as a NumPy array in the class instead of separate variables <code>x</code>
and <code>y</code> for the vector components.  Make a new class <code>Vec</code> where you
apply NumPy functionality in the methods.  The constructor should be
able to treat all the following ways of initializing a vector:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>a = array([1, -1, 4], float)  # numpy array
v = Vec(a)
v = Vec([1, -1, 4])           # list
v = Vec((1, -1, 4))           # tuple
v = Vec(1, -1)                # coordinates
</code></pre>
<!-- end verbatim block -->

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
In the constructor, use variable number of arguments as
described in the document <a href="http://tcse6.on.net/varargs" target="_self">Variable number of
function arguments in Python</a>
<a href="#Langtangen_TCSE6_varargs">[2]</a>.  All arguments are then available as
a tuple, and if there is only one element in the tuple, it should be
an array, list, or tuple you can send through <code>asarray</code> to get a NumPy
array. If there are many arguments, these are coordinates, and the
tuple of arguments can be transformed by <code>array</code> to a NumPy array.
Assume in all operations that the involved vectors have equal
dimension (typically that <code>other</code> has the same dimension as
<code>self</code>). Recall to return <code>Vec</code> objects from all arithmetic
operations, not NumPy arrays, because the next operation with the
vector will then not take place in <code>Vec</code> but in NumPy. If <code>self.v</code> is
the attribute holding the vector as a NumPy array, the addition
operator will typically be implemented as

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class Vec:
    ...
    def __add__(self, other):
        return Vec(selv.v + other.v)
</code></pre>
<!-- end verbatim block -->

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>Vec.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 32: Make classes for students and courses <a name="sec:class:ex15"></a></h2>

Redo the summarizing problem in the section ref{sec:files:sumex} by using
classes.  More precisely, introduce a class <code>Student</code> and a class
<code>Course</code>.  Find appropriate attributes and methods.  The classes
should have a <code>__str__</code> method for pretty-printing of the contents.
Filename: <code>Student_Course.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 33: Find local and global extrema of a function <a name="sec:plot:ex28"></a></h2>

Extreme points of a function \( f(x) \) are normally found by solving
\( f'(x)=0 \). A much simpler method is to evaluate \( f(x) \) for a set of
discrete points in the interval \( [a, b] \) and look for local minima and
maxima among these points. We work with \( n+1 \) equally spaced points
\( a=x_0 < x_1 < \cdots < x_{n}=b \), \( x_i=a+ih \), \( h=(b-a)/n \).

<p>
First we find all local extreme points in the interior of the domain.
Local minima are recognized by

$$
\begin{equation*} f(x_{i-1}) > f(x_i) < f(x_{i+1}),\quad i=1,\ldots,n-1 \thinspace .
\end{equation*}
$$

Similarly, at a local maximum point \( x_i \) we have

$$
\begin{equation*} f(x_{i-1}) < f(x_i) > f(x_{i+1}),\quad i=1,\ldots,n-1 \thinspace .
\end{equation*}
$$

Let \( P_{\min} \) be the set of \( x \) values for local minima and
\( F_{\min} \) the set of the corresponding \( f(x) \) values at these minima.
Two sets \( P_{\max} \) and \( F_{\max} \) are defined correspondingly for the maxima.

<p>
The boundary points \( x=a \) and \( x=b \) are for algorithmic simplicity also
defined as local extreme points: \( x=a \) is a local minimum if \( f(a) < f(x_1) \),
and a local maximum otherwise. Similarly, \( x=b \) is a local minimum if
\( f(b) < f(x_{n-1}) \), and a local maximum otherwise.
The end points \( a \) and \( b \) and the corresponding function values must
be added to the sets \( P_{\min},P_{\max},F_{\min},F_{\max} \).

<p>
The global maximum point is defined as the \( x \) value corresponding
to the maximum value in \( F_{\max} \). The global minimum point is
the \( x \) value corresponding to the minimum value in \( F_{\min} \).

<p>
<b>a)</b>
Make a class <code>MinMax</code> with the following functionality:

<ul>
  <li> <code>__init__</code> takes \( f(x) \), \( a \), \( b \), and \( n \) as arguments, and calls a method <code>_find_extrema</code> to compute the local and global extreme points.</li>
  <li> <code>_find_extrema</code> implements the algorithm above for finding local and global extreme points, and stores the sets \( P_{\min},P_{\max},F_{\min},F_{\max} \) as list attributes in the (<code>self</code>) instance.</li>
  <li> <code>get_global_minimum</code> returns the global minimum point as a pair
    \( (x, f(x)) \).</li>
  <li> <code>get_global_maximum</code> returns the global maximum point as a pair
    \( (x, f(x)) \).</li>
  <li> <code>get_all_minima</code> returns a list or array of all \( (x,f(x)) \) minima.</li>
  <li> <code>get_all_maxima</code> returns a list or array of all \( (x,f(x)) \) maxima.</li>
  <li> <code>__str__</code> returns a string where a nicely formatted table
    of all the min/max points are listed, plus the global extreme points.</li>
</ul>

Here is a sample code using class <code>MinMax</code>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def f(x):
    return x**2*exp(-0.2*x)*sin(2*pi*x)

m = MinMax(f, 0, 4, 5001)
print m
</code></pre>
<!-- end verbatim block -->
The output becomes

<p>
<!-- begin verbatim block  ccq-->
<pre><code>All minima: 0.8056, 1.7736, 2.7632, 3.7584, 0
All maxima: 0.3616, 1.284, 2.2672, 3.2608, 4
Global minimum: 3.7584
Global maximum: 3.2608
</code></pre>
<!-- end verbatim block -->
Make sure that the program also works for functions without local
extrema, e.g., linear functions \( f(x)=ax+b \).

<p>
<b>b)</b>
The algorithm sketched above finds local extreme
points \( x_i \), but all we know is that the true extreme point is in the
interval \( (x_{i-1},x_{i+1}) \). A more accurate algorithm may take this
interval as a starting point and run a Bisection method (see
the final part of the document <a href="http://tcse6.on.net/input" target="_self">User
input and error handling</a>
<a href="#Langtangen_TCSE6_input">[4]</a>) to find the extreme point \( \bar x \) such
that \( f'(\bar x)=0 \).  Add a method
<code>_refine_extrema</code> in class <code>MinMax</code>,
which goes through all the interior local minima
and maxima and solves \( f'(\bar x)=0 \).  Compute \( f'(x) \) using the
<code>Derivative</code> class (the section <a href="#sec:class:autodF">Example: Automagic differentiation</a> with \( h \ll
x_{i+1}-x_{i-1} \).

<p>
Filename: <code>minmaxf.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 34: Find the optimal production for a company <a name="sec:class:ex18a"></a></h2>

The company PROD produces two different products, P$_1$ and P$_2$,
based on three different raw materials, \( \mbox{M}_1 \), \( \mbox{M}_2 \) and
\( \mbox{M}_3 \). The following table shows how much of each raw material
\( \mbox{M}_i \) that is required to produce <em>a single unit</em> of each
product P$_j$:

<p>
<table border="1">
<thead>
<tr><th align="center">                </th> <th align="center">     P$_1$      </th> <th align="center">     P$_2$      </th> </tr>
</thead>
<tbody>
<tr><td align="center">   \( \mbox{M}_1 \)    </td> <td align="center">   2                   </td> <td align="center">   1                   </td> </tr>
<tr><td align="center">   \( \mbox{M}_2 \)    </td> <td align="center">   5                   </td> <td align="center">   3                   </td> </tr>
<tr><td align="center">   \( \mbox{M}_3 \)    </td> <td align="center">   0                   </td> <td align="center">   4                   </td> </tr>
</tbody>
</table>
<p>
 For instance, to produce one unit of \( \mbox{P}_2 \) one needs 1 unit of
 \( \mbox{M}_1 \), 3 units of \( \mbox{M}_2 \) and 4 units of \( \mbox{M}_3 \).
 Furthermore, PROD has available 100, 80 and 150 units of material
 \( \mbox{M}_1 \), \( \mbox{M}_2 \) and \( \mbox{M}_3 \) respectively (for the
 time period considered).  The revenue per produced unit of product
 \( \mbox{P}_1 \) is 150 NOK, and for one unit of \( \mbox{P}_2 \) it is 175
 NOK. On the other hand the raw materials \( \mbox{M}_1 \), \( \mbox{M}_2 \)
 and \( \mbox{M}_3 \) cost 10, 17 and 25 NOK per unit, respectively.  The
 question is: how much should PROD produce of each product?  We here
 assume that PROD wants to maximize its net revenue (which is revenue
 minus costs).

<p>
<b>a)</b>
Let \( x \) and \( y \) be the number of units produced of product
\( \mbox{P}_1 \) and \( \mbox{P}_2 \), respectively. Explain why the total
revenue \( f(x,y) \) is given by

$$
\begin{equation*}
       f(x,y)=150x-(10\cdot 2+17\cdot 5)x+
              175y-(10\cdot 1+17\cdot 3 + 25\cdot 4)y
\end{equation*}
$$

and simplify this expression.
The function \( f(x,y) \) is <em>linear</em> in \( x \) and \( y \)
(make sure you know what linearity means).

<p>
<b>b)</b>
Explain why PROD's problem may be stated mathematically as follows:

$$
\begin{equation}
  \tag{4}
  \begin{array}{lrrrrr}
   \mbox{\rm maximize}    &\multicolumn{3}{c}{f(x,y)} \\ 
   \mbox{\rm subject to}  &       \\ 
       &2x   &+   &y  &\le &100 \\ 
       &5x   &+   &3y &\le &80 \\ 
       &     &    &4y &\le &150 \\ 
       &     &\multicolumn{4}{l}{x\ge 0, y \ge 0.}
  \end{array}
 \end{equation}
$$

 This is an example of a <em>linear optimization problem.</em>

<p>
<b>c)</b>
The production \( (x,y) \) may be considered as a point in the
plane. Illustrate geometrically the set \( T \) of all such points that
satisfy the constraints in model <a href="#mjx-eqn-4">(4)</a>. Every point in this
set is called a <em>feasible point.</em>

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
For every inequality
determine first the straight line obtained by replacing the
inequality by equality. Then, find the points satisfying the
inequality (a half-plane), and finally, intersect these half-planes.

<p>
<!-- --- end hint in exercise --- -->

<p>
<b>d)</b>
Make a program
for drawing the straight lines defined by the
inequalities. Each line can be written as \( ax + by = c \). Let the
program read each line from the command line
as a list of the \( a \), \( b \), and \( c \) values. In the present case
the command-line arguments will be

<p>
<!-- begin verbatim block  ccq-->
<pre><code>'[2,1,100]' '[5,3,80]' '[0,4,150]' '[1,0,0]' '[0,1,0]'
</code></pre>
<!-- end verbatim block -->

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Perform an <code>eval</code> on the elements of <code>sys.argv[1:]</code> to
get \( a \), \( b \), and \( c \) for each line as a list in the program.

<p>
<!-- --- end hint in exercise --- -->

<p>
<b>e)</b>
Let \( \alpha \) be a positive number and
consider the <em>level set</em> of the function \( f \), defined as the set

$$
\begin{equation*}
        L_{\alpha}= \{(x,y) \in T: f(x,y)=\alpha\}.
\end{equation*}
$$

This set consists of all feasible points having the same net revenue
\( \alpha \). Extend the program with two new command-line arguments
holding \( p \) and \( q \) for a function \( f(x,y)=px + qy \). Use this
information to compute the level set lines \( y=\alpha /q - px/q \), and
plot the level set lines for some different values of \( \alpha \) (use
the \( \alpha \) value in the legend for each line).

<p>
<b>f)</b>
Use what you saw in e) to solve the problem <a href="#mjx-eqn-4">(4)</a>
geometrically.  This solution is called an <em>optimal solution</em>.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
How large can you choose \( \alpha \) such that
\( L_{\alpha} \) is nonempty?

<p>
<!-- --- end hint in exercise --- -->

<p>
<b>g)</b>
Assume that we have other values on the revenues and costs than the
actual numbers in a).  Explain why
<a href="#mjx-eqn-4">(4)</a>, with these new parameter values, still has an optimal
solution lying in a corner point of \( T \).  Extend the program
to calculate all the corner points of a
region \( T \) in the plane determined by the linear inequalities like
those listed above.  Moreover, the program
shall compute the maximum of a given linear function \( f(x,y)=ax+by \)
over \( T \) by calculating the function values in the corner points and
finding the smallest function value.

<p>
Filename: <code>optimization.py</code>.

<p>
<!-- --- end exercise --- -->

<h1>References  <a name="___sec105"></a></h1>

<!-- begin bibliography -->

<ol>
 <li> <a name="Langtangen_TCSE6_oo"></a> <b>H. P. Langtangen</b>. 
    Object-oriented programming,
    <a href="http://tcse6.on.net/oo" target="_self"><tt>http://tcse6.on.net/oo</tt></a>.</li>
 <li> <a name="Langtangen_TCSE6_varargs"></a> <b>H. P. Langtangen</b>. 
    Variable number of function arguments in Python,
    <a href="http://tcse6.on.net/varargs" target="_self"><tt>http://tcse6.on.net/varargs</tt></a>.</li>
 <li> <a name="Langtangen_TCSE6_debug"></a> <b>H. P. Langtangen</b>. 
    Debugging in Python,
    <a href="http://tcse6.on.net/debug" target="_self"><tt>http://tcse6.on.net/debug</tt></a>.</li>
 <li> <a name="Langtangen_TCSE6_input"></a> <b>H. P. Langtangen</b>. 
    User input and error handling,
    <a href="http://tcse6.on.net/input" target="_self"><tt>http://tcse6.on.net/input</tt></a>.</li>
</ol>

<!-- end bibliography -->

<p>
<!-- begin bottom navigation -->
<table style="width: 100%"><tr><td>
</td><td>
</td></tr></table>
<!-- end bottom navigation -->
</p>

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

