<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Array computing and curve plotting">
<meta name="keywords" content="vectors,vector computing,scalar (math quantity),heterogeneous lists,Numerical Python,NumPy,array (datatype),array computing,vectorization,array slicing,subarrays,allocate,vectorization,scalar code,curve plotting,plotting,making graphs,backend (Easyviz),backend (Easyviz),remove files (in Python),delete files (in Python),boolean indexing,boolean indexing,in-place array arithmetics,check an object's type,shape (of an array),array shape,matrix,shape (of an array),array shape,least squares approximation,Trapezoidal rule for integration,Lagrange's interpolation formula,interpolation,Midpoint rule for integration,Trapezoidal rule for integration">

<title>Array computing and curve plotting</title>

<!-- Bootstrap style: bootswatch_readable -->
<link href="http://netdna.bootstrapcdn.com/bootswatch/3.1.1/readable/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->

<style type="text/css">
/* Let inline verbatim have the same color as the surroundings */
code { color: inherit; background-color: transparent; }
</style>

</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [(' Vectors ', 1, None, '___sec0'),
              (' The vector concept ', 2, None, '___sec1'),
              (' Mathematical operations on vectors ',
               2,
               'sec:plot:vectors',
               'sec:plot:vectors'),
              (' Vector arithmetics and vector functions ',
               2,
               'sec:plot:arraycomp',
               'sec:plot:arraycomp'),
              (' Arrays in Python programs ', 1, None, '___sec4'),
              (' Using lists for collecting function data ',
               2,
               'sec:plot:listdata',
               'sec:plot:listdata'),
              (' Basics of numerical Python arrays ',
               2,
               'sec:plot:array:basics',
               'sec:plot:array:basics'),
              (' Computing coordinates and function values ',
               2,
               None,
               '___sec7'),
              (' Vectorization ',
               2,
               'sec:plot:vectorization',
               'sec:plot:vectorization'),
              (' Curve plotting ',
               1,
               'sec:plot:curveplots',
               'sec:plot:curveplots'),
              (' Matplotlib; pylab ', 2, 'sec:plot:pylab', 'sec:plot:pylab'),
              (' A basic plot ', 3, None, '___sec11'),
              (' Decorating the plot ', 3, None, '___sec12'),
              (' Plotting multiple curves ', 3, None, '___sec13'),
              (' Placing several plots in one figure ', 3, None, '___sec14'),
              (' Matplotlib; pyplot ',
               2,
               'sec:plot:pyplot',
               'sec:plot:pyplot'),
              (' SciTools and Easyviz ',
               2,
               'sec:plot:SciTools',
               'sec:plot:SciTools'),
              (' Importing SciTools and Easyviz ', 3, None, '___sec17'),
              (' A basic plot ', 3, None, '___sec18'),
              (' Decorating the plot ', 3, None, '___sec19'),
              (' Plotting multiple curves ', 3, None, '___sec20'),
              (' Changing backend ', 3, None, '___sec21'),
              (' Placing several plots in one figure ', 3, None, '___sec22'),
              (' Making animations ', 2, 'easyviz:movie', 'easyviz:movie'),
              (' Example ', 3, None, '___sec24'),
              (' Animation in Easyviz ', 3, None, '___sec25'),
              (' Basic animation in Matplotlib ', 3, None, '___sec26'),
              (' Using FuncAnimation in Matplotlib ', 3, None, '___sec27'),
              (' Making videos ', 2, 'sec:plot:video', 'sec:plot:video'),
              (' Animated GIF file ', 3, None, '___sec29'),
              (' MP4, Ogg, WebM, and Flash videos ', 3, None, '___sec30'),
              (' Curve plots in pure text ', 2, None, '___sec31'),
              (' Plotting difficulties ',
               1,
               'sec:plot:difficulties',
               'sec:plot:difficulties'),
              (' Piecewisely defined functions ',
               2,
               'sec:plot:pwisefunc',
               'sec:plot:pwisefunc'),
              (' Example: The Heaviside function ', 3, None, '___sec34'),
              (' Example: A hat function ', 3, None, '___sec35'),
              (' Rapidly varying functions ',
               2,
               'sec:plot:sin1x',
               'sec:plot:sin1x'),
              (' More advanced vectorization of functions ',
               1,
               'sec:plot:if:vectorize',
               'sec:plot:if:vectorize'),
              (' Vectorization of StringFunction objects ',
               2,
               'sec:plot:StringFunction:vectorize',
               'sec:plot:StringFunction:vectorize'),
              (' Vectorization of the Heaviside function ',
               2,
               'sec:vec:Heaviside',
               'sec:vec:Heaviside'),
              (' Loop ', 3, None, '___sec40'),
              (' Automatic vectorization ', 3, None, '___sec41'),
              (' Mixing boolean and floating-point calculations ',
               3,
               None,
               '___sec42'),
              (' Manual vectorization ', 3, None, '___sec43'),
              (' Vectorization of a hat function ',
               2,
               'sec:vec:hatfunc',
               'sec:vec:hatfunc'),
              (' More on numerical Python arrays ',
               1,
               'sec:plot:numpy:more',
               'sec:plot:numpy:more'),
              (' Copying arrays ', 2, None, '___sec46'),
              (' In-place arithmetics ', 2, None, '___sec47'),
              (' Allocating arrays ', 2, None, '___sec48'),
              (' Generalized indexing ',
               2,
               'sec:plot:generalized:index',
               'sec:plot:generalized:index'),
              (' Testing for the array type ', 2, None, '___sec50'),
              (' Example: Vectorizing a constant function ',
               3,
               None,
               '___sec51'),
              (' Compact syntax for array generation ', 2, None, '___sec52'),
              (' Shape manipulation ', 2, None, '___sec53'),
              (' Higher-dimensional arrays ',
               1,
               'sec:plot:2Darrays',
               'sec:plot:2Darrays'),
              (' Matrices and arrays ', 2, None, '___sec55'),
              (' Two-dimensional numerical Python arrays ',
               2,
               'sec:plot:2D:arrays',
               'sec:plot:2D:arrays'),
              (' Array computing ',
               2,
               'sec:plot:array2comp',
               'sec:plot:array2comp'),
              (' Remark ', 3, None, '___sec58'),
              (' Two-dimensional arrays and functions of two variables ',
               2,
               None,
               '___sec59'),
              (' Matrix objects ',
               2,
               'sec:plot:numpy:matrix',
               'sec:plot:numpy:matrix'),
              (' Summary ', 1, None, '___sec61'),
              (' Chapter topics ', 2, None, '___sec62'),
              (' Array computing ', 3, None, '___sec63'),
              (' Plotting curves ', 3, None, '___sec64'),
              (' Making movies ', 3, None, '___sec65'),
              (' Terminology ', 3, None, '___sec66'),
              (' Example: Animating a function ',
               2,
               'sec:plot:summarizing',
               'sec:plot:summarizing'),
              (' Problem ', 3, None, '___sec68'),
              (' Solution ', 3, None, '___sec69'),
              (' Scaling ', 3, None, '___sec70'),
              (' Exercises ', 1, 'sec:plot:exer', 'sec:plot:exer'),
              (' Exercise 1: Fill lists with function values ',
               2,
               'sec:plot:ex1',
               'sec:plot:ex1'),
              (' Exercise 2: Fill arrays; loop version ',
               2,
               'sec:plot:ex2',
               'sec:plot:ex2'),
              (' Exercise 3: Fill arrays; vectorized version ',
               2,
               'sec:plot:ex2b',
               'sec:plot:ex2b'),
              (' Exercise 4: Plot a function ',
               2,
               'sec:plot:ex2c',
               'sec:plot:ex2c'),
              (' Exercise 5: Apply a function to a vector ',
               2,
               'sec:plot:math:ex1',
               'sec:plot:math:ex1'),
              (' Exercise 6: Simulate by hand a vectorized expression ',
               2,
               'sec:plot:ex3',
               'sec:plot:ex3'),
              (' Exercise 7: Demonstrate array slicing ',
               2,
               'sec:plot:ex15d',
               'sec:plot:ex15d'),
              (' Exercise 8: Replace list operations by array computing ',
               2,
               'sec:plot:ex33',
               'sec:plot:ex33'),
              (' Exercise 9: Plot a formula ',
               2,
               'sec:plot:ex15',
               'sec:plot:ex15'),
              (' Exercise 10: Plot a formula for several parameters ',
               2,
               'sec:plot:ex15b',
               'sec:plot:ex15b'),
              (' Exercise 11: Specify the extent of the axes in a plot ',
               2,
               'sec:plot:ex15ba',
               'sec:plot:ex15ba'),
              (' Exercise 12: Plot exact and inexact Fahrenheit-Celsius conversion formulas ',
               2,
               'sec:plot:ex15c',
               'sec:plot:ex15c'),
              (' Exercise 13: Plot the trajectory of a ball ',
               2,
               'sec:plot:ex5',
               'sec:plot:ex5'),
              (' Exercise 14: Plot data in a two-column file ',
               2,
               'sec:files:ex12',
               'sec:files:ex12'),
              (' Remarks ', 3, None, '___sec86'),
              (' Exercise 15: Write function data to file ',
               2,
               'sec:files:ex12e',
               'sec:files:ex12e'),
              (' Exercise 16: Plot data from a file ',
               2,
               'sec:files:ex12c',
               'sec:files:ex12c'),
              (' Exercise 17: Fit a polynomial to data points ',
               2,
               'sec:files:ex12c2',
               'sec:files:ex12c2'),
              (' Exercise 18: Fit a polynomial to experimental data ',
               2,
               'sec:files:ex19',
               'sec:files:ex19'),
              (' Exercise 19: Read acceleration data and find velocities ',
               2,
               'sec:files:ex22',
               'sec:files:ex22'),
              (' Exercise 20: Read acceleration data and plot velocities ',
               2,
               'sec:files:ex23',
               'sec:files:ex23'),
              (" Exercise 21: Plot a trip's path and velocity from GPS coordinates ",
               2,
               'sec:files:ex24',
               'sec:files:ex24'),
              (' Exercise 22: Vectorize the Midpoint rule for integration ',
               2,
               'sec:class:exer:sum',
               'sec:class:exer:sum'),
              (' Remarks ', 3, None, '___sec95'),
              (" Exercise 23: Implement Lagrange's interpolation formula ",
               2,
               'sec:class:ex27a',
               'sec:class:ex27a'),
              (" Exercise 24: Plot Lagrange's interpolating polynomial ",
               2,
               'sec:class:ex27b',
               'sec:class:ex27b'),
              (" Exercise 25: Investigate the behavior of Lagrange's interpolating polynomials ",
               2,
               'sec:class:ex27c',
               'sec:class:ex27c'),
              (' Remarks ', 3, None, '___sec99'),
              (' Exercise 26: Plot a wave packet ',
               2,
               'sec:plot:ex5d',
               'sec:plot:ex5d'),
              (' Exercise 27: Judge a plot ',
               2,
               'sec:plot:ex7',
               'sec:plot:ex7'),
              (' Exercise 28: Plot the viscosity of water ',
               2,
               'sec:plot:ex13c',
               'sec:plot:ex13c'),
              (' Exercise 29: Explore a complicated function graphically ',
               2,
               'sec:plot:ex16',
               'sec:plot:ex16'),
              (' Exercise 30: Plot Taylor polynomial approximations to $\\sin x$ ',
               2,
               'sec:plot:ex5b',
               'sec:plot:ex5b'),
              (' Exercise 31: Animate a wave packet ',
               2,
               'sec:plot:ex5e',
               'sec:plot:ex5e'),
              (' Exercise 32: Animate a smoothed Heaviside function ',
               2,
               'sec:plot:ex32',
               'sec:plot:ex32'),
              (' Exercise 33: Animate two-scale temperature variations ',
               2,
               'sec:plot:ex18',
               'sec:plot:ex18'),
              (' Remarks ', 3, None, '___sec108'),
              (' Exercise 34: Use non-uniformly distributed coordinates for visualization ',
               2,
               'sec:plot:ex19',
               'sec:plot:ex19'),
              (' Exercise 35: Animate a sequence of approximations to $\\pi$ ',
               2,
               'sec:plot:ex31',
               'sec:plot:ex31'),
              (" Exercise 36: Animate a planet's orbit ",
               2,
               'sec:plot:ex5g',
               'sec:plot:ex5g'),
              (' Exercise 37: Animate the evolution of Taylor polynomials ',
               2,
               'sec:plot:ex17',
               'sec:plot:ex17'),
              (' Exercise 38: Plot the velocity profile for pipeflow ',
               2,
               'sec:plot:ex4',
               'sec:plot:ex4'),
              (' Exercise 39: Plot sum-of-sines approximations to a function ',
               2,
               'sec:plot:ex8',
               'sec:plot:ex8'),
              (' Exercise 40: Animate the evolution of a sum-of-sine approximation to a function ',
               2,
               'sec:plot:ex8m',
               'sec:plot:ex8m'),
              (' Exercise 41: Plot functions from the command line ',
               2,
               'sec:plot:ex14',
               'sec:plot:ex14'),
              (' Exercise 42: Improve command-line input ',
               2,
               'sec:plot:ex14b',
               'sec:plot:ex14b'),
              (' Exercise 43: Demonstrate energy concepts from physics ',
               2,
               'sec:plot:ex20',
               'sec:plot:ex20'),
              (' Exercise 44: Plot a w-like function ',
               2,
               'sec:plot:math:ex9',
               'sec:plot:math:ex9'),
              (' Exercise 45: Plot a piecewise constant function ',
               2,
               'sec:basic:exH4plot',
               'sec:basic:exH4plot'),
              (' Exercise 46: Vectorize a piecewise constant function ',
               2,
               'sec:basic:exH4vecz1',
               'sec:basic:exH4vecz1'),
              (' Remarks ', 3, None, '___sec122'),
              (' Exercise 47: Visualize approximations in the Midpoint integration rule ',
               2,
               'sec:plot:ex:vizmidpoint',
               'sec:plot:ex:vizmidpoint'),
              (' Exercise 48: Visualize approximations in the Trapezoidal integration rule ',
               2,
               'sec:plot:ex:viztrapezoidal',
               'sec:plot:ex:viztrapezoidal'),
              (' Exercise 49: Experience overflow in a function ',
               2,
               'sec:plot:ex13',
               'sec:plot:ex13'),
              (' Remarks ', 3, None, '___sec126'),
              (' Exercise 50: Apply a function to a rank 2 array ',
               2,
               'sec:plot:math:ex2',
               'sec:plot:math:ex2'),
              (' Exercise 51: Explain why array computations fail ',
               2,
               'sec:plot:ex11',
               'sec:plot:ex11'),
              (' References ', 1, None, '___sec129')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\tp}{\thinspace .}
$$




    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="plot-bootstrap.html">Array computing and curve plotting</a>
  </div>
  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="#___sec0" style="font-size: 80%;">Vectors</a></li>
     <!-- navigation toc: --> <li><a href="#___sec4" style="font-size: 80%;">Arrays in Python programs</a></li>
     <!-- navigation toc: --> <li><a href="#sec:plot:curveplots" style="font-size: 80%;">Curve plotting</a></li>
     <!-- navigation toc: --> <li><a href="#sec:plot:difficulties" style="font-size: 80%;">Plotting difficulties</a></li>
     <!-- navigation toc: --> <li><a href="#sec:plot:if:vectorize" style="font-size: 80%;">More advanced vectorization of functions</a></li>
     <!-- navigation toc: --> <li><a href="#sec:plot:numpy:more" style="font-size: 80%;">More on numerical Python arrays</a></li>
     <!-- navigation toc: --> <li><a href="#sec:plot:2Darrays" style="font-size: 80%;">Higher-dimensional arrays</a></li>
     <!-- navigation toc: --> <li><a href="#___sec61" style="font-size: 80%;">Summary</a></li>
     <!-- navigation toc: --> <li><a href="#sec:plot:exer" style="font-size: 80%;">Exercises</a></li>
     <!-- navigation toc: --> <li><a href="#___sec129" style="font-size: 80%;">References</a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<a name="part0000"></a>
<!-- ------------------- main content ---------------------- -->



<div class="jumbotron">
<center><h1>Array computing and curve plotting</h1></center>  <!-- document title -->

<p>
<!-- author(s): Hans Petter Langtangen -->

<center>
<b>Hans Petter Langtangen</b> [1, 2]
</center>


<p>
<!-- institution(s) -->

<center>[1] <b>Center for Biomedical Computing, Simula Research Laboratory</b></center>
<center>[2] <b>Department of Informatics, University of Oslo</b></center>
<p>
<center><h4>Aug 31, 2014</h4></center> <!-- date -->

<h2>Table of contents</h2>

<a href="#___sec0"> Vectors </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec1"> The vector concept </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:vectors"> Mathematical operations on vectors </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:arraycomp"> Vector arithmetics and vector functions </a><br>
<a href="#___sec4"> Arrays in Python programs </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:listdata"> Using lists for collecting function data </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:array:basics"> Basics of numerical Python arrays </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec7"> Computing coordinates and function values </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:vectorization"> Vectorization </a><br>
<a href="#sec:plot:curveplots"> Curve plotting </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:pylab"> Matplotlib; pylab </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec11"> A basic plot </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec12"> Decorating the plot </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec13"> Plotting multiple curves </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec14"> Placing several plots in one figure </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:pyplot"> Matplotlib; pyplot </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:SciTools"> SciTools and Easyviz </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec17"> Importing SciTools and Easyviz </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec18"> A basic plot </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec19"> Decorating the plot </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec20"> Plotting multiple curves </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec21"> Changing backend </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec22"> Placing several plots in one figure </a><br>
&nbsp; &nbsp; &nbsp; <a href="#easyviz:movie"> Making animations </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec24"> Example </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec25"> Animation in Easyviz </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec26"> Basic animation in Matplotlib </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec27"> Using FuncAnimation in Matplotlib </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:video"> Making videos </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec29"> Animated GIF file </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec30"> MP4, Ogg, WebM, and Flash videos </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec31"> Curve plots in pure text </a><br>
<a href="#sec:plot:difficulties"> Plotting difficulties </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:pwisefunc"> Piecewisely defined functions </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec34"> Example: The Heaviside function </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec35"> Example: A hat function </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:sin1x"> Rapidly varying functions </a><br>
<a href="#sec:plot:if:vectorize"> More advanced vectorization of functions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:StringFunction:vectorize"> Vectorization of StringFunction objects </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:vec:Heaviside"> Vectorization of the Heaviside function </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec40"> Loop </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec41"> Automatic vectorization </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec42"> Mixing boolean and floating-point calculations </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec43"> Manual vectorization </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:vec:hatfunc"> Vectorization of a hat function </a><br>
<a href="#sec:plot:numpy:more"> More on numerical Python arrays </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec46"> Copying arrays </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec47"> In-place arithmetics </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec48"> Allocating arrays </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:generalized:index"> Generalized indexing </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec50"> Testing for the array type </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec51"> Example: Vectorizing a constant function </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec52"> Compact syntax for array generation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec53"> Shape manipulation </a><br>
<a href="#sec:plot:2Darrays"> Higher-dimensional arrays </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec55"> Matrices and arrays </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:2D:arrays"> Two-dimensional numerical Python arrays </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:array2comp"> Array computing </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec58"> Remark </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec59"> Two-dimensional arrays and functions of two variables </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:numpy:matrix"> Matrix objects </a><br>
<a href="#___sec61"> Summary </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec62"> Chapter topics </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec63"> Array computing </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec64"> Plotting curves </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec65"> Making movies </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec66"> Terminology </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:summarizing"> Example: Animating a function </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec68"> Problem </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec69"> Solution </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec70"> Scaling </a><br>
<a href="#sec:plot:exer"> Exercises </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:ex1"> Exercise 1: Fill lists with function values </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:ex2"> Exercise 2: Fill arrays; loop version </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:ex2b"> Exercise 3: Fill arrays; vectorized version </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:ex2c"> Exercise 4: Plot a function </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:math:ex1"> Exercise 5: Apply a function to a vector </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:ex3"> Exercise 6: Simulate by hand a vectorized expression </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:ex15d"> Exercise 7: Demonstrate array slicing </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:ex33"> Exercise 8: Replace list operations by array computing </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:ex15"> Exercise 9: Plot a formula </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:ex15b"> Exercise 10: Plot a formula for several parameters </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:ex15ba"> Exercise 11: Specify the extent of the axes in a plot </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:ex15c"> Exercise 12: Plot exact and inexact Fahrenheit-Celsius conversion formulas </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:ex5"> Exercise 13: Plot the trajectory of a ball </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:ex12"> Exercise 14: Plot data in a two-column file </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec86"> Remarks </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:ex12e"> Exercise 15: Write function data to file </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:ex12c"> Exercise 16: Plot data from a file </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:ex12c2"> Exercise 17: Fit a polynomial to data points </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:ex19"> Exercise 18: Fit a polynomial to experimental data </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:ex22"> Exercise 19: Read acceleration data and find velocities </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:ex23"> Exercise 20: Read acceleration data and plot velocities </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:ex24"> Exercise 21: Plot a trip's path and velocity from GPS coordinates </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:exer:sum"> Exercise 22: Vectorize the Midpoint rule for integration </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec95"> Remarks </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:ex27a"> Exercise 23: Implement Lagrange's interpolation formula </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:ex27b"> Exercise 24: Plot Lagrange's interpolating polynomial </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:class:ex27c"> Exercise 25: Investigate the behavior of Lagrange's interpolating polynomials </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec99"> Remarks </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:ex5d"> Exercise 26: Plot a wave packet </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:ex7"> Exercise 27: Judge a plot </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:ex13c"> Exercise 28: Plot the viscosity of water </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:ex16"> Exercise 29: Explore a complicated function graphically </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:ex5b"> Exercise 30: Plot Taylor polynomial approximations to \( \sin x \) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:ex5e"> Exercise 31: Animate a wave packet </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:ex32"> Exercise 32: Animate a smoothed Heaviside function </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:ex18"> Exercise 33: Animate two-scale temperature variations </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec108"> Remarks </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:ex19"> Exercise 34: Use non-uniformly distributed coordinates for visualization </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:ex31"> Exercise 35: Animate a sequence of approximations to \( \pi \) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:ex5g"> Exercise 36: Animate a planet's orbit </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:ex17"> Exercise 37: Animate the evolution of Taylor polynomials </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:ex4"> Exercise 38: Plot the velocity profile for pipeflow </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:ex8"> Exercise 39: Plot sum-of-sines approximations to a function </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:ex8m"> Exercise 40: Animate the evolution of a sum-of-sine approximation to a function </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:ex14"> Exercise 41: Plot functions from the command line </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:ex14b"> Exercise 42: Improve command-line input </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:ex20"> Exercise 43: Demonstrate energy concepts from physics </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:math:ex9"> Exercise 44: Plot a w-like function </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:basic:exH4plot"> Exercise 45: Plot a piecewise constant function </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:basic:exH4vecz1"> Exercise 46: Vectorize a piecewise constant function </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec122"> Remarks </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:ex:vizmidpoint"> Exercise 47: Visualize approximations in the Midpoint integration rule </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:ex:viztrapezoidal"> Exercise 48: Visualize approximations in the Trapezoidal integration rule </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:ex13"> Exercise 49: Experience overflow in a function </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec126"> Remarks </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:math:ex2"> Exercise 50: Apply a function to a rank 2 array </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:plot:ex11"> Exercise 51: Explain why array computations fail </a><br>
<a href="#___sec129"> References </a><br>
</p>
<p>
<!-- Externaldocuments: ../formulas/main_formulas, ../looplist/main_looplist, ../funcif/main_funcif, ../input/main_input, ../files/main_files, ../class/main_class, ../random/main_random, ../oo/main_oo, ../diffeq/main_diffeq, ../discalc/main_discalc, ../ode1/main_ode1, ../boxspring/main_boxspring, ../ode2/main_ode2, ../debug/main_debug, ../cython/main_cython, ../tech/main_timing, ../tech/main_varargs, ../tech/main_runpy, ../tech/main_ostasks, ../tech/main_accesspy, ../tech/main_nose -->

<p>
<a name="ch:plot"></a>

<p>
A list object is handy for storing tabular data, such as a sequence of
objects or a table of objects.  An array is very similar to a list,
but less flexible and computationally much more efficient.  When using
the computer to perform mathematical calculations, we often end up
with a huge amount of numbers and associated arithmetic operations.
Storing numbers in lists may in such contexts lead to slow programs,
while arrays can make the programs run much faster.  This is crucial
for many advanced applications of mathematics in industry and science,
where computer programs may run for hours and days, or even weeks.
Any clever idea that reduces the execution time by some factor is
therefore paramount.

<p>
However, one can argue that programmers of mathematical software have
traditionally paid too much attention to efficiency and &quot;clever&quot;
program constructs. The resulting software often becomes very hard to
maintain and extend. In this document we advocate a focus on clear,
well-designed, and easy-to-understand programs that work
correctly. Thereafter, one can start thinking about optimization for
speed. Fortunately, arrays contribute to clear code, correctness and
speed - all at once.

<p>
This document gives an introduction to arrays: how they are created
and what they can be used for.  Array computing usually ends up with a
lot of numbers. It may be very hard to understand what these numbers
mean by just looking at them. Since the human is a visual animal, a
good way to understand numbers is to visualize them. In this
document we concentrate on visualizing curves that reflect functions
of one variable; i.e., curves of the form \( y=f(x) \).  A synonym for
curve is graph, and the image of curves on the screen is often called
a plot.  We will use arrays to store the information about points
along the curve. In a nutshell, array computing demands visualization
and visualization demands arrays.

<p>
All program examples in this document can be found as files in the
folder <a href="http://tinyurl.com/pwyasaa/plot" target="_self"><tt>src/plot</tt></a>.

<p>


</div> <!-- end jumbotron -->

<h1 id="___sec0">Vectors <a name="___sec0"></a></h1>

This section gives a brief introduction to the vector concept,
assuming that you have heard about vectors in the plane and maybe
vectors in space before. This background will be valuable when we
start to work with arrays and curve plotting.

<h2 id="___sec1">The vector concept <a name="___sec1"></a></h2>

Some mathematical quantities are associated with a set of numbers. One
example is a point in the plane, where we need two coordinates (real
numbers) to describe the point mathematically.  Naming the two
coordinates of a particular point as \( x \) and \( y \), it is common to use
the notation \( (x,y) \) for the point.  That is, we group the numbers
inside parentheses.  Instead of symbols we might use the numbers
directly: \( (0,0) \) and \( (1.5,-2.35) \) are also examples of coordinates
in the plane.

<p>
A point in three-dimensional space has three coordinates, which we may
name \( x_1 \), \( x_2 \), and \( x_3 \). The common notation groups the numbers
inside parentheses: \( (x_1,x_2,x_3) \).  Alternatively, we may use the
symbols \( x \), \( y \), and \( z \), and write the point as \( (x,y,z) \), or
numbers can be used instead of symbols.

<p>
<!-- Now, think of a bird that is flying around. At time \( t \) the bird -->
<!-- is located at the point \( (x,y,z) \) in space. The complete information -->
<!-- of where the bird is, can be represented as a collection of -->
<!-- \( t \), \( x \), \( y \), and \( z \). These numbers can be collected inside -->
<!-- parentheses: \( (x,y,z,t) \) or \( (t,x,y,z) \). This quantity is known -->
<!-- as a space-time point. -->

<p>
From high school you may have a memory of solving two equations with
two unknowns. At the university you will soon meet problems that are
formulated as \( n \) equations with \( n \) unknowns.  The solution of such
problems contains \( n \) numbers that we can collect inside parentheses
and number from 1 to \( n \): \( (x_1,x_2,x_3,\ldots,x_{n-1},x_n) \).

<p>
Quantities such as \( (x,y) \), \( (x,y,z) \), or \( (x_1,\ldots,x_n) \) are known
as <em>vectors</em> in mathematics.  A visual representation of a vector is
an arrow that goes from the origin to a point. For example, the vector
\( (x,y) \) is an arrow that goes from \( (0,0) \) to the point with
coordinates \( (x,y) \) in the plane. Similarly, \( (x,y,z) \) is an arrow
from \( (0,0,0) \) to the point \( (x,y,z) \) in three-dimensional space.

<p>
Mathematicians found it convenient to introduce spaces with higher
dimension than three, because when we have a solution of \( n \) equations
collected in a vector \( (x_1,\ldots,x_n) \), we may think of this vector
as a point in a space with dimension \( n \), or equivalently, an arrow
that goes from the origin \( (0,\ldots,0) \) in \( n \)-dimensional space to
the point \( (x_1,\ldots,x_n) \). Figure <a href="#sec:plot:vec:fig1">1</a>
illustrates a vector as an arrow, either starting at the origin, or at
any other point. Two arrows/vectors that have the same direction and
the same length are mathematically equivalent.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 1:  A vector \( (2,3) \) visualized in the standard way as an arrow from the origin to the point \( (2,3) \), and mathematically equivalently, as an arrow from \( (1,\frac{1}{2}) \) (or any point \( (a,b) \)) to \( (3, 3\frac{1}{2}) \) (or \( (a+2,b+3) \)). <a name="sec:plot:vec:fig1"></a> </p></center>
<p><img src="fig-plot/vector_illustration2.png" align="bottom" width=400></p>
</center>

<p>
We say that \( (x_1,\ldots,x_n) \) is an \( n \)-vector or a vector with \( n \)
components. Each of the numbers \( x_1 \), \( x_2 \), \( \ldots \) is a component
or an element. We refer to the first component (or element), the
second component (or element), and so forth.

<p>
A Python program may use a list or tuple to represent a vector:

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">v1 <span style="color: #666666">=</span> [x, y]         <span style="color: #408080; font-style: italic"># list of variables</span>
v2 <span style="color: #666666">=</span> (<span style="color: #666666">-1</span>, <span style="color: #666666">2</span>)        <span style="color: #408080; font-style: italic"># tuple of numbers</span>
v3 <span style="color: #666666">=</span> (x1, x2, x3)   <span style="color: #408080; font-style: italic"># tuple of variables</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> exp
v4 <span style="color: #666666">=</span> [exp(<span style="color: #666666">-</span>i<span style="color: #666666">*0.1</span>) <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">150</span>)]
</pre></div>
<p>
While <code>v1</code> and <code>v2</code> are vectors in the plane and <code>v3</code> is a vector in
three-dimensional space, <code>v4</code> is a vector in a 150-dimensional space,
consisting of 150 values of the exponential function.  Since Python
lists and tuples have 0 as the first index, we may also in mathematics
write the vector \( (x_1,x_2) \) as \( (x_0,x_1) \). This is not at all common
in mathematics, but makes the distance from a mathematical description
of a problem to its solution in Python shorter.

<p>
It is impossible to visually demonstrate how a space with 150
dimensions looks like.  Going from the plane to three-dimensional
space gives a rough feeling of what it means to add a dimension, but
if we forget about the idea of a visual perception of space, the
mathematics is very simple: going from a 4-dimensional vector to a
5-dimensional vector is just as easy as adding an element to a list of
symbols or numbers.

<h2 id="sec:plot:vectors">Mathematical operations on vectors<a name="sec:plot:vectors"></a></h2>

Since vectors can be viewed as arrows having a length and a direction,
vectors are extremely useful in geometry and physics.  The velocity of
a car has a magnitude and a direction, so has the acceleration, and
the position of a point in the car is also a vector.  An edge of a
triangle can be viewed as a line (arrow) with a direction and length.

<p>
In geometric and physical applications of vectors, mathematical
operations on vectors are important. We shall exemplify some of the
most important operations on vectors below. The goal is not to teach
computations with vectors, but more to illustrate that such
computations are defined by mathematical rules.  Given two vectors,
\( (u_1,u_2) \) and \( (v_1,v_2) \), we can add these vectors according to the
rule:

$$
\begin{equation}
(u_1,u_2) + (v_1,v_2) = (u_1+v_1, u_2+v_2)\tp
\end{equation}
$$

We can also subtract two vectors using a similar rule:

$$
\begin{equation}
(u_1,u_2) - (v_1,v_2) = (u_1-v_1, u_2-v_2)\tp
\end{equation}
$$

A vector can be multiplied by a number. This number, called \( a \) below, is
usually denoted as a <em>scalar</em>:

$$
\begin{equation}
a\cdot (v_1,v_2) = (av_1, av_2)\tp
\end{equation}
$$

The inner product, also called dot product, or scalar product,
of two vectors is a number:

$$
\begin{equation} (u_1,u_2)\cdot (v_1,v_2) = u_1v_1 + u_2v_2\tp
\end{equation}
$$

(From high school mathematics and physics you might recall that the
inner or dot product also can be expressed as the product of the
lengths of the two vectors multiplied by the cosine of the angle
between them, but we will not make use of that formula.  There is also
a <em>cross product</em> defined for 2-vectors or 3-vectors, but we do not
list the cross product formula here.)

<p>
The length of a vector is defined by

$$
\begin{equation} ||(v_1,v_2)|| = \sqrt{(v_1,v_2)\cdot (v_1,v_2)}= \sqrt{v_1^2 + v_2^2}\tp
\end{equation}
$$


<p>
The same mathematical operations apply to \( n \)-dimensional vectors as
well.  Instead of counting indices from 1, as we usually do in
mathematics, we now count from 0, as in Python. The addition and
subtraction of two vectors with \( n \) components (or elements) read

$$
\begin{align}
(u_0,\ldots,u_{n-1}) + (v_0,\ldots,v_{n-1}) &=  (u_0+v_0,\ldots,u_{n-1}+v_{n-1}) , \\ 
(u_0,\ldots,u_{n-1}) - (v_0,\ldots,v_{n-1}) &=  (u_0-v_0,\ldots,u_{n-1}-v_{n-1}) \tp
\end{align}
$$

Multiplication of a scalar \( a \) and a vector \( (v_0,\ldots,v_{n-1}) \) equals

$$
\begin{equation}
(av_0,\ldots,av_{n-1})\tp
\end{equation}
$$

The inner or dot product of two \( n \)-vectors is defined as

$$
\begin{equation}
(u_0,\ldots,u_{n-1}) \cdot (v_0,\ldots,v_{n-1})
= u_0v_0+\cdots + u_{n-1}v_{n-1} = \sum_{j=0}^{n-1} u_jv_j\tp
\end{equation}
$$

Finally, the length \( ||v|| \) of an \( n \)-vector \( v=(v_0,\ldots,v_{n-1}) \) is

$$
\begin{align}
\sqrt{(v_0,\ldots,v_{n-1})\cdot (v_0,\ldots,v_{n-1})} &=
\left(v_0^2 + v_1^2 + \cdots + v_{n-1}^2\right)^\frac{1}{2}\nonumber\\ 
& =
\left(\sum_{j=0}^{n-1} v_j^2\right)^\frac{1}{2}\tp
\end{align}
$$

<h2 id="sec:plot:arraycomp">Vector arithmetics and vector functions<a name="sec:plot:arraycomp"></a></h2>

In addition to the operations on vectors in the section <a href="#sec:plot:vectors">Mathematical operations on vectors</a>, which you might recall from high school
mathematics, we can define other operations on vectors.  This is very
useful for speeding up programs.  Unfortunately, the forthcoming
vector operations are hardly treated in textbooks on mathematics, yet
these operations play a significant role in mathematical software,
especially in computing environment such as MATLAB, Octave, Python,
and R.

<p>
Applying a mathematical function of one variable, \( f(x) \), to a vector
is defined as a vector where \( f \) is applied to each element. Let
\( v=(v_0,\ldots,v_{n-1}) \) be a vector. Then

$$
\begin{equation*} f(v) = (f(v_0),\ldots,f(v_{n-1}))\tp\end{equation*}
$$

For example, the sine of \( v \) is

$$
\begin{equation*} \sin(v) = (\sin(v_0),\ldots,\sin(v_{n-1}))\tp\end{equation*}
$$

It follows that squaring a vector, or the more general operation of
raising the vector to a power, can be defined as applying the
operation to each element:

$$
\begin{equation*} v^b = (v_0^b,\ldots,v_{n-1}^b)\tp\end{equation*}
$$

Another operation between two vectors that arises in computer programming
of mathematics is the &quot;asterisk&quot; multiplication, defined as

$$
\begin{equation} u*v = (u_0v_0, u_1v_1, \ldots, u_{n-1}v_{n-1})\tp
\tag{1}
\end{equation}
$$

Adding a scalar to a vector or array can be defined as adding the scalar
to each component. If \( a \) is a scalar and \( v \) a vector, we have

$$
\begin{equation*} a + v = (a+v_0, \ldots, a+v_{n-1})\tp\end{equation*}
$$


<p>
A compound vector expression may look like

$$
\begin{equation}
v^2*\cos(v)*e^v + 2\tp
\tag{2}
\end{equation}
$$

How do we calculate this expression?  We use the normal rules of
mathematics, working our way, term by term, from left to right, paying
attention to the fact that powers are evaluated before multiplications
and divisions, which are evaluated prior to addition and subtraction.
First we calculate \( v^2 \), which results in a vector we may call
\( u \). Then we calculate \( \cos(v) \) and call the result \( p \). Then we
multiply \( u*p \) to get a vector which we may call \( w \). The next step is
to evaluate \( e^v \), call the result \( q \), followed by the multiplication
\( w*q \), whose result is stored as \( r \). Then we add \( r+2 \) to get the
final result.  It might be more convenient to list these operations
after each other:

<ul>
  <li> \( u=v^2 \)</li>
  <li> \( p=\cos (v) \)</li>
  <li> \( w = u*p \)</li>
  <li> \( q = e^v \)</li>
  <li> \( r = w*q \)</li>
  <li> \( s=r +2 \)</li>
</ul>

Writing out the vectors \( u \), \( w \), \( p \), \( q \), and \( r \) in terms of a
general vector \( v=(v_0,\ldots,v_{n-1}) \) (do it!) shows that the result
of the expression <a href="#mjx-eqn-2">(2)</a> is the vector

$$
\begin{equation*} (v_0^2\cos(v_0)e^{v_0}+2,\ldots,v_{n-1}^2\cos(v_{n-1})e^{v_{n-1}}+2)\tp\end{equation*}
$$

That is, component no. \( i \) in the result vector equals the number
arising from applying the formula <a href="#mjx-eqn-2">(2)</a> to \( v_i \),
where the * multiplication is ordinary multiplication between two
numbers.

<p>
We can, alternatively, introduce the function

$$
\begin{equation*} f(x) = x^2\cos(x)e^x + 2\end{equation*}
$$

and use the result that \( f(v) \)
means applying \( f \) to each element
in \( v \). The result is the same as in the vector
expression <a href="#mjx-eqn-2">(2)</a>.

<p>
In Python programming it is important for speed (and convenience too)
that we can apply functions of one variable, like \( f(x) \), to
vectors. What this means mathematically is something we have tried to
explain in this subsection.  Doing <a href="#sec:plot:math:ex1">Exercise 5: Apply a function to a vector</a>
and <a href="#sec:plot:ex3">Exercise 6: Simulate by hand a vectorized expression</a> may help to grasp the ideas of vector computing,
and with more programming experience you will hopefully discover that
vector computing is very useful.  It is not necessary to have a
thorough understanding of vector computing in order to proceed with
the next sections.

<p>
Arrays are used to represent vectors in a program, but one can do more
with arrays than with vectors. Until the section <a href="#sec:plot:2Darrays">Higher-dimensional arrays</a> it
suffices to think of arrays as the same as vectors in a program.

<h1 id="___sec4">Arrays in Python programs <a name="___sec4"></a></h1>

This section introduces array programming in Python, but first we
create some lists and show how arrays differ from lists.

<h2 id="sec:plot:listdata">Using lists for collecting function data<a name="sec:plot:listdata"></a></h2>

Suppose we have a function \( f(x) \) and want to evaluate this function
at a number of \( x \) points \( x_0,x_1,\ldots,x_{n-1} \).  We could collect
the \( n \) pairs \( (x_i,f(x_i)) \) in a list, or we could collect all the
\( x_i \) values, for \( i=0,\ldots,n-1 \), in a list and all the associated
\( f(x_i) \) values in another list.  The following interactive session
demonstrates how to create these three types of lists:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>(x):
<span style="color: #666666">...</span>     <span style="color: #008000; font-weight: bold">return</span> x<span style="color: #666666">**3</span>       <span style="color: #408080; font-style: italic"># sample function</span>
<span style="color: #666666">...</span>
<span style="color: #666666">&gt;&gt;&gt;</span> n <span style="color: #666666">=</span> <span style="color: #666666">5</span>                 <span style="color: #408080; font-style: italic"># no of points along the x axis</span>
<span style="color: #666666">&gt;&gt;&gt;</span> dx <span style="color: #666666">=</span> <span style="color: #666666">1.0/</span>(n<span style="color: #666666">-1</span>)        <span style="color: #408080; font-style: italic"># spacing between x points in [0,1]</span>
<span style="color: #666666">&gt;&gt;&gt;</span> xlist <span style="color: #666666">=</span> [i<span style="color: #666666">*</span>dx <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(n)]
<span style="color: #666666">&gt;&gt;&gt;</span> ylist <span style="color: #666666">=</span> [f(x) <span style="color: #008000; font-weight: bold">for</span> x <span style="color: #AA22FF; font-weight: bold">in</span> xlist]
<span style="color: #666666">&gt;&gt;&gt;</span> pairs <span style="color: #666666">=</span> [[x, y] <span style="color: #008000; font-weight: bold">for</span> x, y <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">zip</span>(xlist, ylist)]
</pre></div>
<p>
Here we have used list comprehensions for achieving compact code. Make
sure that you understand what is going on in these list comprehensions
(if not, try to write the same code using standard <code>for</code> loops and
appending new list elements in each pass of the loops).

<p>
The list elements consist of objects of the same type: any element in
<code>pairs</code> is a list of two <code>float</code> objects, while any element in <code>xlist</code>
or <code>ylist</code> is a <code>float</code>. Lists are more flexible than that, because an
element can be an object of any type, e.g.,

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">mylist <span style="color: #666666">=</span> [<span style="color: #666666">2</span>, <span style="color: #666666">6.0</span>, <span style="color: #BA2121">&#39;tmp.pdf&#39;</span>, [<span style="color: #666666">0</span>,<span style="color: #666666">1</span>]]
</pre></div>
<p>
Here <code>mylist</code> holds an <code>int</code>, a <code>float</code>, a string, and a list. This
combination of diverse object types makes up what is known as
<em>heterogeneous</em> lists.  We can also easily remove elements from a list
or add new elements anywhere in the list.  This flexibility of lists
is in general convenient to have as a programmer, but in cases where
the elements are of the same type and the number of elements is fixed,
arrays can be used instead. The benefits of arrays are faster
computations, less memory demands, and extensive support for
mathematical operations on the data.  Because of greater efficiency
and mathematical convenience, arrays will be used to a large extent in
this document.  The great use of arrays is also prominent in other
programming environments such as MATLAB, Octave, and R, for instance.
Lists will be our choice instead of arrays when we need the
flexibility of adding or removing elements or when the elements may be
of different object types.

<h2 id="sec:plot:array:basics">Basics of numerical Python arrays<a name="sec:plot:array:basics"></a></h2>

An <em>array</em> object can be viewed as a variant of a list, but with the
following assumptions and features:

<ul>
  <li> All elements must be of the same type, preferably integer, real, or complex numbers, for efficient numerical computing and storage.</li>
  <li> The number of elements must be known when the array is created.</li>
  <li> Arrays are not part of standard Python - one needs an additional package called <em>Numerical Python</em>, often abbreviated as NumPy. The Python name of the package, to be used in <code>import</code> statements, is <code>numpy</code>.</li>
  <li> With <code>numpy</code>, a wide range of mathematical operations can be done directly on complete arrays, thereby removing the need for loops over array elements. This is commonly called <em>vectorization</em> %or <em>array computing</em> and may cause a dramatic speed-up of Python programs. Vectorization makes use of the vector computing concepts from the section <a href="#sec:plot:arraycomp">Vector arithmetics and vector functions</a>.</li>
  <li> Arrays with one index are often called vectors. Arrays with two indices are used as an efficient data structure for tables, instead of lists of lists. Arrays can also have three or more indices.</li>
</ul>

We have two remarks to the above list.  First, there is actually an
object type called <code>array</code> in standard Python, but this data type is
not so efficient for mathematical computations, and we will not use it
in this document.  Second, the number of elements in an array <em>can</em> be
changed, but at a substantial computational cost.

<p>
The following text lists some important functionality of NumPy arrays.
A more comprehensive treatment is found in the excellent <em>NumPy
Tutorial</em>, <em>NumPy User Guide</em>, <em>NumPy Reference</em>, <em>Guide to NumPy</em>,
and <em>NumPy for MATLAB Users</em>, all accessible at <a href="http://scipy.org" target="_self">scipy.org</a>.

<p>
The standard import statement for Numerical Python reads

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
</pre></div>
<p>
To convert a list <code>r</code> to an array,
we use the <code>array</code> function
from <code>numpy</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">a <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array(r)
</pre></div>
<p>
To create a new array of length <code>n</code>, filled with zeros, we write

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">a <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(n)
</pre></div>
<p>
The array elements are of a type that corresponds to Python's
<code>float</code> type. A second argument to <code>np.zeros</code> can be used to
specify other element types, e.g., <code>int</code>.
A similar function,

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">a <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(c)
</pre></div>
<p>
generates an array of zeros where the length is that of the array <code>c</code>
and the element type is the same as those in <code>c</code>.  Arrays with more
than one index are treated in the section <a href="#sec:plot:2Darrays">Higher-dimensional arrays</a>.

<p>
Often one wants an array to have \( n \) elements with uniformly
distributed values in an interval \( [p,q] \). The <code>numpy</code> function
<code>linspace</code> creates such arrays:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">a <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(p, q, n)
</pre></div>
<p>
Array elements are accessed by square brackets as for lists:
<code>a[i]</code>. Slices also work as for lists, for example, <code>a[1:-1]</code> picks
out all elements except the first and the last, but contrary to lists,
<code>a[1:-1]</code> is not a copy of the data in <code>a</code>. Hence,

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">b <span style="color: #666666">=</span> a[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]
b[<span style="color: #666666">2</span>] <span style="color: #666666">=</span> <span style="color: #666666">0.1</span>
</pre></div>
<p>
will also change <code>a[3]</code> to <code>0.1</code>.  A slice <code>a[i:j:s]</code> picks out the
elements starting with index <code>i</code> and stepping <code>s</code> indices at the time
up to, but not including, <code>j</code>. Omitting <code>i</code> implies <code>i=0</code>, and
omitting <code>j</code> implies <code>j=n</code> if <code>n</code> is the number of elements in the
array.  For example, <code>a[0:-1:2]</code> picks out every two elements up to,
but not including, the last element, while <code>a[::4]</code> picks out every
four elements in the whole array.

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Remarks on importing NumPy.</b>
The statement

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
</pre></div>
<p>
with subsequent prefixing of all NumPy functions and variables by <code>np</code>,
has evolved as a standard syntax in the Python scientific computing
community. However, to make Python programs look closer to MATLAB
and ease the transition to and from that language, one can do

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
</pre></div>
<p>
to get rid of the prefix (this is evolved as the standard in
<em>interactive</em> Python shells). This author prefers mathematical
functions from <code>numpy</code> to be written without the prefix to
make the formulas as close as possible to the mathematics.
So, \( f(x)=\sinh(x-1)\sin(w t) \) would be coded as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> sinh, sin

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>(x):
    <span style="color: #008000; font-weight: bold">return</span> sinh(x<span style="color: #666666">-1</span>)<span style="color: #666666">*</span>sin(w<span style="color: #666666">*</span>t)
</pre></div>
<p>
or one may take the less recommended
lazy approach <code>from numpy import *</code> and fill up
the program with <em>a lot</em> of functions and variables from <code>numpy</code>.
</div>


<h2 id="___sec7">Computing coordinates and function values <a name="___sec7"></a></h2>

With these basic operations at hand, we can continue the session from
the previous section and make arrays out of the lists <code>xlist</code> and
<code>ylist</code>:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #666666">&gt;&gt;&gt;</span> x2 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array(xlist)      <span style="color: #408080; font-style: italic"># turn list xlist into array x2</span>
<span style="color: #666666">&gt;&gt;&gt;</span> y2 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array(ylist)
<span style="color: #666666">&gt;&gt;&gt;</span> x2
array([ <span style="color: #666666">0.</span>  ,  <span style="color: #666666">0.25</span>,  <span style="color: #666666">0.5</span> ,  <span style="color: #666666">0.75</span>,  <span style="color: #666666">1.</span>  ])
<span style="color: #666666">&gt;&gt;&gt;</span> y2
array([ <span style="color: #666666">0.</span>      ,  <span style="color: #666666">0.015625</span>,  <span style="color: #666666">0.125</span>   ,  <span style="color: #666666">0.421875</span>,  <span style="color: #666666">1.</span>      ])
</pre></div>
<p>
Instead of first making a list and then converting the list to an
array, we can compute the arrays directly.  The equally spaced
coordinates in <code>x2</code> are naturally computed by the <code>np.linspace</code>
function. The <code>y2</code> array can be created by <code>np.zeros</code>, to ensure that
<code>y2</code> has the right length <code>len(x2)</code>, and then we can run a <code>for</code> loop
to fill in all elements in <code>y2</code> with <code>f</code> values:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> n <span style="color: #666666">=</span> <span style="color: #008000">len</span>(xlist)
<span style="color: #666666">&gt;&gt;&gt;</span> x2 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, n)
<span style="color: #666666">&gt;&gt;&gt;</span> y2 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(n)
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">xrange</span>(n):
<span style="color: #666666">...</span>     y2[i] <span style="color: #666666">=</span> f(x2[i])
<span style="color: #666666">...</span>
<span style="color: #666666">&gt;&gt;&gt;</span> y2
array([ <span style="color: #666666">0.</span>      ,  <span style="color: #666666">0.015625</span>,  <span style="color: #666666">0.125</span>   ,  <span style="color: #666666">0.421875</span>,  <span style="color: #666666">1.</span>      ])
</pre></div>
<p>
Note that we here in the <code>for</code> loop have used <code>xrange</code> instead of
<code>range</code>. The former is faster for long loops because it avoids
generating <em>and storing</em> a list of integers, it just generates the
values one by one. Hence, we prefer <code>xrange</code> over <code>range</code> for loops
over long arrays.  In Python version 3.x, <code>range</code> is the same as
<code>xrange</code>.

<p>
Creating an array of a given length is frequently referred to as
<em>allocating</em> the array. It simply means that a part of the computer's
memory is marked for being occupied by this array.  Mathematical
computations will often fill up most of the computer's memory by
allocating long arrays.

<p>
We can shorten the previous code by creating the <code>y2</code> data in a list
comprehension, but list comprehensions produce lists, not arrays, so
we need to transform the list object to an array object:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> x2 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, n)
<span style="color: #666666">&gt;&gt;&gt;</span> y2 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array([f(xi) <span style="color: #008000; font-weight: bold">for</span> xi <span style="color: #AA22FF; font-weight: bold">in</span> x2])
</pre></div>
<p>
Nevertheless, there is a much faster way of computing <code>y2</code> as the next
paragraph explains.

<h2 id="sec:plot:vectorization">Vectorization<a name="sec:plot:vectorization"></a></h2>

Loops over very long arrays may run slowly. A great advantage with
arrays is that we can get rid of the loops and apply <code>f</code> directly to
the whole array:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> y2 <span style="color: #666666">=</span> f(x2)
<span style="color: #666666">&gt;&gt;&gt;</span> y2
array([ <span style="color: #666666">0.</span>      ,  <span style="color: #666666">0.015625</span>,  <span style="color: #666666">0.125</span>   ,  <span style="color: #666666">0.421875</span>,  <span style="color: #666666">1.</span>      ])
</pre></div>
<p>
The magic that makes <code>f(x2)</code> work builds on the vector computing
concepts from the section <a href="#sec:plot:arraycomp">Vector arithmetics and vector functions</a>.  Instead of calling
<code>f(x2)</code> we can equivalently write the function formula <code>x2**3</code>
directly.

<p>
The point is that <code>numpy</code> implements vector arithmetics <em>for arrays</em>
of any dimension. Moreover, <code>numpy</code> provides its own versions of
mathematical functions like <code>cos</code>, <code>sin</code>, <code>exp</code>, <code>log</code>, etc., which
work for array arguments and apply the mathematical function to each
element. The following code, computes each array element separately:

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> sin, cos, exp
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, <span style="color: #666666">2</span>, <span style="color: #666666">201</span>)
r <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(<span style="color: #008000">len</span>(x))
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">xrange</span>(<span style="color: #008000">len</span>(x)):
    r[i] <span style="color: #666666">=</span> sin(np<span style="color: #666666">.</span>pi<span style="color: #666666">*</span>x[i])<span style="color: #666666">*</span>cos(x[i])<span style="color: #666666">*</span>exp(<span style="color: #666666">-</span>x[i]<span style="color: #666666">**2</span>) <span style="color: #666666">+</span> <span style="color: #666666">2</span> <span style="color: #666666">+</span> x[i]<span style="color: #666666">**2</span>
</pre></div>
<p>
while here is a corresponding code that operates on arrays directly:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">r <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sin(np<span style="color: #666666">.</span>pi<span style="color: #666666">*</span>x)<span style="color: #666666">*</span>np<span style="color: #666666">.</span>cos(x)<span style="color: #666666">*</span>np<span style="color: #666666">.</span>exp(<span style="color: #666666">-</span>x<span style="color: #666666">**2</span>) <span style="color: #666666">+</span> <span style="color: #666666">2</span> <span style="color: #666666">+</span> x<span style="color: #666666">**2</span>
</pre></div>
<p>
Many will prefer to see such formulas without the <code>np</code> prefix:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> sin, cos, exp, pi
r <span style="color: #666666">=</span> sin(pi<span style="color: #666666">*</span>x)<span style="color: #666666">*</span>cos(x)<span style="color: #666666">*</span>exp(<span style="color: #666666">-</span>x<span style="color: #666666">**2</span>) <span style="color: #666666">+</span> <span style="color: #666666">2</span> <span style="color: #666666">+</span> x<span style="color: #666666">**2</span>
</pre></div>
<p>
An important thing to understand is that <code>sin</code> from the <code>math</code> module
is different from the <code>sin</code> function provided by <code>numpy</code>.  The former
does not allow array arguments, while the latter accepts both real
numbers and arrays.

<p>
Replacing a loop like the one above, for computing <code>r[i]</code>, by a
vector/array expression like <code>sin(x)*cos(x)*exp(-x**2) + 2 + x**2</code>, is
called <em>vectorization</em>.  The loop version is often referred to as
<em>scalar code</em>.  For example,

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">math</span>
x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N);  y <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N)
dx <span style="color: #666666">=</span> <span style="color: #666666">2.0/</span>(N<span style="color: #666666">-1</span>) <span style="color: #408080; font-style: italic"># spacing of x coordinates</span>
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N):
    x[i] <span style="color: #666666">=</span> <span style="color: #666666">-1</span> <span style="color: #666666">+</span> dx<span style="color: #666666">*</span>i
    y[i] <span style="color: #666666">=</span> math<span style="color: #666666">.</span>exp(<span style="color: #666666">-</span>x[i])<span style="color: #666666">*</span>x[i]
</pre></div>
<p>
is scalar code, while the corresponding vectorized version reads

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">-1</span>, <span style="color: #666666">1</span>, N)
y <span style="color: #666666">=</span> np<span style="color: #666666">.</span>exp(<span style="color: #666666">-</span>x)<span style="color: #666666">*</span>x
</pre></div>
<p>
We remark that list comprehensions,

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">x <span style="color: #666666">=</span> array([<span style="color: #666666">-1</span> <span style="color: #666666">+</span> dx<span style="color: #666666">*</span>i <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N)])
y <span style="color: #666666">=</span> array([np<span style="color: #666666">.</span>exp(<span style="color: #666666">-</span>xi)<span style="color: #666666">*</span>xi <span style="color: #008000; font-weight: bold">for</span> xi <span style="color: #AA22FF; font-weight: bold">in</span> x])
</pre></div>
<p>
result in scalar code because we still have explicit, slow Python
<code>for</code> loops operating on scalar quantities.  The requirement of
vectorized code is that there are no explicit Python <code>for</code> loops. The
loops required to compute each array element are performed in fast C
or Fortran code in the <code>numpy</code> package.

<p>
Most Python functions intended for a scalar argument <code>x</code>, like

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>(x):
    <span style="color: #008000; font-weight: bold">return</span> x<span style="color: #666666">**4*</span>exp(<span style="color: #666666">-</span>x)
</pre></div>
<p>
automatically work for an array argument <code>x</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">-3</span>, <span style="color: #666666">3</span>, <span style="color: #666666">101</span>)
y <span style="color: #666666">=</span> f(x)
</pre></div>
<p>
provided that the <code>exp</code> function in the definition of <code>f</code> accepts an
array argument.  This means that <code>exp</code> must have been imported as
<code>from numpy import *</code> or explicitly as <code>from numpy import exp</code>.  One
can, of course, prefix <code>exp</code> as in <code>np.exp</code>, at the loss of a less
attractive mathematical syntax in the formula.

<p>
When a Python function <code>f(x)</code> works for an array argument <code>x</code>, we say
that the function <code>f</code> is vectorized. Provided that the mathematical
expressions in <code>f</code> involve arithmetic operations and basic
mathematical functions from the <code>math</code> module, <code>f</code> will be
automatically vectorized by just importing the functions from <code>numpy</code>
instead of <code>math</code>.  However, if the expressions inside <code>f</code> involve
<code>if</code> tests, the code needs a rewrite to work with arrays.  The section <a href="#sec:plot:pwisefunc">Piecewisely defined functions</a> presents examples where we have to do special
actions in order to vectorize functions.

<p>
Vectorization is very important for speeding up Python programs that
perform heavy computations with arrays. Moreover, vectorization gives
more compact code that is easier to read.  Vectorization is
particularly important for statistical simulations, as demonstrated in
the
document <a href="http://tcse6.on.net/random" target="_self">Random numbers and simple games</a> <a href="#Langtangen_TCSE6_random">[1]</a>.

<h1 id="sec:plot:curveplots">Curve plotting<a name="sec:plot:curveplots"></a></h1>

Visualizing a function \( f(x) \) is done by drawing the curve \( y=f(x) \) in
an \( xy \) coordinate system. When we use a computer to do this task, we
say that we <em>plot</em> the curve.  Technically, we plot a curve by drawing
straight lines between \( n \) points on the curve. The more points we
use, the smoother the curve appears.

<p>
Suppose we want to plot the function \( f(x) \) for \( a\leq x\leq b \).
First we pick out \( n \) $x$ coordinates in the interval \( [a,b] \), say we
name these \( x_0,x_1,\ldots,x_{n-1} \). Then we evaluate \( y_i=f(x_i) \) for
\( i=0,1,\ldots,{n-1} \). The points \( (x_i,y_i) \), \( i=0,1,\ldots,{n-1} \),
now lie on the curve \( y=f(x) \). Normally, we choose the \( x_i \)
coordinates to be equally spaced, i.e.,

$$
\begin{equation*} x_i = a + ih,\quad h = {b-a\over n-1}\tp\end{equation*}
$$

If we store the \( x_i \) and \( y_i \) values in two arrays <code>x</code> and <code>y</code>, we
can plot the curve by a command like <code>plot(x,y)</code>.

<p>
Sometimes the names of the independent variable and the function
differ from \( x \) and \( f \), but the plotting procedure is the same. Our
first example of curve plotting demonstrates this fact by involving a
function of \( t \).

<h2 id="sec:plot:pylab">Matplotlib; pylab<a name="sec:plot:pylab"></a></h2>

The standard package for curve plotting in Python is Matplotlib.
First we exemplify Matplotlib using <code>matplotlib.pylab</code>, which enables
a syntax very close to that of MATLAB. This is a great advantage since
many readers may have experience with plotting in MATLAB, or they will
certainly meet MATLAB sometime in their scientific work.

<h3 id="___sec11">A basic plot <a name="___sec11"></a></h3>

Let us plot the curve \( y = t^2\exp(-t^2) \) for \( t \) values between 0 and
3.  First we generate equally spaced coordinates for \( t \), say 51
values (50 intervals). Then we compute the corresponding \( y \) values at
these points, before we call the <code>plot(t,y)</code> command to make the curve
plot.  Here is the complete program:

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pylab</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>(t):
    <span style="color: #008000; font-weight: bold">return</span> t<span style="color: #666666">**2*</span>exp(<span style="color: #666666">-</span>t<span style="color: #666666">**2</span>)

t <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, <span style="color: #666666">3</span>, <span style="color: #666666">31</span>)    <span style="color: #408080; font-style: italic"># 31 points between 0 and 3</span>
y <span style="color: #666666">=</span> zeros(<span style="color: #008000">len</span>(t))         <span style="color: #408080; font-style: italic"># allocate y with float elements</span>
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">xrange</span>(<span style="color: #008000">len</span>(t)):
    y[i] <span style="color: #666666">=</span> f(t[i])

plot(t, y)
show()
</pre></div>
<p>
The <code>from matplotlib.pylab import *</code> performs a <code>from numpy import *</code>
import as well as an import of all Matplotlib commands that resemble
MATLAB-style syntax.  In this program we pre-allocate the <code>y</code> array
and fill it with values, element by element, in a Python
loop. Alternatively, we may operate on the whole <code>t</code> array at once,
which yields faster and shorter code:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">y <span style="color: #666666">=</span> f(t)
</pre></div>
<p>
To include the plot in electronic documents, we need a hardcopy of the
figure in PDF, PNG, or another image format.  The <code>savefig</code> function
saves the plot to files in various image formats:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">savefig(<span style="color: #BA2121">&#39;tmp1.pdf&#39;</span>) <span style="color: #408080; font-style: italic"># produce PDF</span>
savefig(<span style="color: #BA2121">&#39;tmp1.png&#39;</span>) <span style="color: #408080; font-style: italic"># produce PNG</span>
</pre></div>
<p>
The filename extension determines the format: <code>.pdf</code> for PDF and
<code>.png</code> for PNG.  Figure <a href="#fig:plot1a:pylab">2</a> displays the resulting
plot.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 2:  A simple plot in PDF format (Matplotlib). <a name="fig:plot1a:pylab"></a> </p></center>
<p><img src="fig-plot/plot1a_pylab.png" align="bottom" width=400></p>
</center>

<h3 id="___sec12">Decorating the plot <a name="___sec12"></a></h3>

The \( x \) and \( y \) axes in curve plots should have labels, here \( t \) and
\( y \), respectively. Also, the curve should be identified with a label,
or legend as it is often called.  A title above the plot is also
common.  In addition, we may want to control the extent of the axes
(although most plotting programs will automatically adjust the axes to
the range of the data).  All such things are easily added after the
<code>plot</code> command:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">plot(t, y)
xlabel(<span style="color: #BA2121">&#39;t&#39;</span>)
ylabel(<span style="color: #BA2121">&#39;y&#39;</span>)
legend([<span style="color: #BA2121">&#39;t^2*exp(-t^2)&#39;</span>])
axis([<span style="color: #666666">0</span>, <span style="color: #666666">3</span>, <span style="color: #666666">-0.05</span>, <span style="color: #666666">0.6</span>])   <span style="color: #408080; font-style: italic"># [tmin, tmax, ymin, ymax]</span>
title(<span style="color: #BA2121">&#39;My First Matplotlib Demo&#39;</span>)
savefig(<span style="color: #BA2121">&#39;tmp2.pdf&#39;</span>)
show()
</pre></div>
<p>
Removing the <code>show()</code> call prevents the plot from being shown on the
screen, which is advantageous if the program's purpose is to make a
large number of plots in PDF or PNG format (you do not want all the
plot windows to appear on the screen and then kill all of them
manually).  This decorated plot is displayed in Figure
<a href="#fig:plot1c:pylab">3</a>.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 3:  A single curve with label, title, and axis adjusted (Matplotlib). <a name="fig:plot1c:pylab"></a> </p></center>
<p><img src="fig-plot/plot1c_pylab.png" align="bottom" width=400></p>
</center>

<h3 id="___sec13">Plotting multiple curves <a name="___sec13"></a></h3>

A common plotting task is to compare two or more curves, which
requires multiple curves to be drawn in the same plot.
Suppose we want to plot the two functions \( f_1(t)=t^2\exp(-t^2) \)
and \( f_2(t)=t^4\exp(-t^2) \). We can then just issue two <code>plot</code> commands,
one for each function. To make the syntax resemble MATLAB, we call
<code>hold('on')</code> after the first <code>plot</code> command to indicate that
subsequent <code>plot</code> commands are to draw the curves in the first plot.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f1</span>(t):
    <span style="color: #008000; font-weight: bold">return</span> t<span style="color: #666666">**2*</span>exp(<span style="color: #666666">-</span>t<span style="color: #666666">**2</span>)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f2</span>(t):
    <span style="color: #008000; font-weight: bold">return</span> t<span style="color: #666666">**2*</span>f1(t)

t <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, <span style="color: #666666">3</span>, <span style="color: #666666">51</span>)
y1 <span style="color: #666666">=</span> f1(t)
y2 <span style="color: #666666">=</span> f2(t)

plot(t, y1, <span style="color: #BA2121">&#39;r-&#39;</span>)
hold(<span style="color: #BA2121">&#39;on&#39;</span>)
plot(t, y2, <span style="color: #BA2121">&#39;bo&#39;</span>)
xlabel(<span style="color: #BA2121">&#39;t&#39;</span>)
ylabel(<span style="color: #BA2121">&#39;y&#39;</span>)
legend([<span style="color: #BA2121">&#39;t^2*exp(-t^2)&#39;</span>, <span style="color: #BA2121">&#39;t^4*exp(-t^2)&#39;</span>])
title(<span style="color: #BA2121">&#39;Plotting two curves in the same plot&#39;</span>)
show()
</pre></div>
<p>
In these <code>plot</code> commands, we have also specified the line type:
<code>r-</code> means red (<code>r</code>) line (<code>-</code>), while <code>bo</code>
means a blue (<code>b</code>) circle (<code>o</code>) at each data point.
Figure <a href="#fig:plot2a:pylab">4</a> shows the result.
The legends for each curve is specified in a list where the sequence
of strings correspond to the sequence of <code>plot</code> commands.
Doing a <code>hold('off')</code> makes the next <code>plot</code> command create a new
plot.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 4:  Two curves in the same plot (Matplotlib). <a name="fig:plot2a:pylab"></a> </p></center>
<p><img src="fig-plot/plot2a_pylab.png" align="bottom" width=400></p>
</center>

<h3 id="___sec14">Placing several plots in one figure <a name="___sec14"></a></h3>

We may also put plots together in a figure with <code>r</code> rows
and <code>c</code> columns of plots. The <code>subplot(r,c,a)</code>
does this, where <code>a</code> is a row-wise counter for the individual plots.
Here is an example with two rows of plots, and one plot in each row,
(see Figure <a href="#fig:subplot:pylab">5</a>):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">figure()  <span style="color: #408080; font-style: italic"># make separate figure</span>
subplot(<span style="color: #666666">2</span>, <span style="color: #666666">1</span>, <span style="color: #666666">1</span>)
t <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, <span style="color: #666666">3</span>, <span style="color: #666666">51</span>)
y1 <span style="color: #666666">=</span> f1(t)
y2 <span style="color: #666666">=</span> f2(t)

plot(t, y1, <span style="color: #BA2121">&#39;r-&#39;</span>, t, y2, <span style="color: #BA2121">&#39;bo&#39;</span>)
xlabel(<span style="color: #BA2121">&#39;t&#39;</span>)
ylabel(<span style="color: #BA2121">&#39;y&#39;</span>)
axis([t[<span style="color: #666666">0</span>], t[<span style="color: #666666">-1</span>], <span style="color: #008000">min</span>(y2)<span style="color: #666666">-0.05</span>, <span style="color: #008000">max</span>(y2)<span style="color: #666666">+0.5</span>])
legend([<span style="color: #BA2121">&#39;t^2*exp(-t^2)&#39;</span>, <span style="color: #BA2121">&#39;t^4*exp(-t^2)&#39;</span>])
title(<span style="color: #BA2121">&#39;Top figure&#39;</span>)

subplot(<span style="color: #666666">2</span>, <span style="color: #666666">1</span>, <span style="color: #666666">2</span>)
t3 <span style="color: #666666">=</span> t[::<span style="color: #666666">4</span>]
y3 <span style="color: #666666">=</span> f2(t3)

plot(t, y1, <span style="color: #BA2121">&#39;b-&#39;</span>, t3, y3, <span style="color: #BA2121">&#39;ys&#39;</span>)
xlabel(<span style="color: #BA2121">&#39;t&#39;</span>)
ylabel(<span style="color: #BA2121">&#39;y&#39;</span>)
axis([<span style="color: #666666">0</span>, <span style="color: #666666">4</span>, <span style="color: #666666">-0.2</span>, <span style="color: #666666">0.6</span>])
legend([<span style="color: #BA2121">&#39;t^2*exp(-t^2)&#39;</span>, <span style="color: #BA2121">&#39;t^4*exp(-t^2)&#39;</span>])
savefig(<span style="color: #BA2121">&#39;tmp4.pdf&#39;</span>)
show()
</pre></div>
<p>
The <code>figure()</code> call creates a new plot window on the screen.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 5:  Example on two plots in one figure (Matplotlib). <a name="fig:subplot:pylab"></a> </p></center>
<p><img src="fig-plot/plotsubplot_pylab.png" align="bottom" width=400></p>
</center>

<p>
All of the examples above on plotting with Matplotlib are collected in the
file <a href="http://tinyurl.com/pwyasaa/plot/mpl_pylab_examples.py" target="_self"><tt>mpl_pylab_examples.py</tt></a>.

<h2 id="sec:plot:pyplot">Matplotlib; pyplot<a name="sec:plot:pyplot"></a></h2>

The Matplotlib developers do not promote the <code>matplotlib.pylab</code>
interface. Instead, they recommend the <code>matplotlib.pyplot</code> module and
prefix Numerical Python and Matplotlib functionality by short forms of
their package names:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
</pre></div>
<p>
The commands in <code>matplotlib.pyplot</code> are similar to those in
<code>matplotlib.pylab</code>.
The plot in Figure <a href="#fig:plot1c:pylab">3</a> can typically be obtained
by prefixing the <code>pylab</code> commands with <code>plt</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">plt<span style="color: #666666">.</span>plot(t, y)
plt<span style="color: #666666">.</span>legend([<span style="color: #BA2121">&#39;t^2*exp(-t^2)&#39;</span>])
plt<span style="color: #666666">.</span>xlabel(<span style="color: #BA2121">&#39;t&#39;</span>)
plt<span style="color: #666666">.</span>ylabel(<span style="color: #BA2121">&#39;y&#39;</span>)
plt<span style="color: #666666">.</span>axis([<span style="color: #666666">0</span>, <span style="color: #666666">3</span>, <span style="color: #666666">-0.05</span>, <span style="color: #666666">0.6</span>])   <span style="color: #408080; font-style: italic"># [tmin, tmax, ymin, ymax]</span>
plt<span style="color: #666666">.</span>title(<span style="color: #BA2121">&#39;My First Matplotlib Demo&#39;</span>)
plt<span style="color: #666666">.</span>show()
plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp2.pdf&#39;</span>) <span style="color: #408080; font-style: italic"># produce PDF</span>
</pre></div>
<p>
Instead of giving plot data and legends separately, it is more common
to write

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">plt<span style="color: #666666">.</span>plot(t, y, label<span style="color: #666666">=</span><span style="color: #BA2121">&#39;t^2*exp(-t^2)&#39;</span>)
</pre></div>
<p>
However, in this document we shall stick to the <code>legend</code> command since
this makes the transition to/from MATLAB easier.

<p>
Figure <a href="#fig:plot2a:pylab">4</a> can be produced by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f1</span>(t):
    <span style="color: #008000; font-weight: bold">return</span> t<span style="color: #666666">**2*</span>np<span style="color: #666666">.</span>exp(<span style="color: #666666">-</span>t<span style="color: #666666">**2</span>)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f2</span>(t):
    <span style="color: #008000; font-weight: bold">return</span> t<span style="color: #666666">**2*</span>f1(t)

t <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, <span style="color: #666666">3</span>, <span style="color: #666666">51</span>)
y1 <span style="color: #666666">=</span> f1(t)
y2 <span style="color: #666666">=</span> f2(t)

plt<span style="color: #666666">.</span>plot(t, y1, <span style="color: #BA2121">&#39;r-&#39;</span>)
plt<span style="color: #666666">.</span>plot(t, y2, <span style="color: #BA2121">&#39;bo&#39;</span>)
plt<span style="color: #666666">.</span>xlabel(<span style="color: #BA2121">&#39;t&#39;</span>)
plt<span style="color: #666666">.</span>ylabel(<span style="color: #BA2121">&#39;y&#39;</span>)
plt<span style="color: #666666">.</span>legend([<span style="color: #BA2121">&#39;t^2*exp(-t^2)&#39;</span>, <span style="color: #BA2121">&#39;t^4*exp(-t^2)&#39;</span>])
plt<span style="color: #666666">.</span>title(<span style="color: #BA2121">&#39;Plotting two curves in the same plot&#39;</span>)
plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp3.pdf&#39;</span>)
plt<span style="color: #666666">.</span>show()
</pre></div>
<p>
Putting multiple plots in a figure follows the same set-up with
<code>subplot</code> as shown
for <code>pylab</code>, except that commands are prefixed by <code>plt</code>.
The complete example, along with the codes listed above, are found in
the file <a href="http://tinyurl.com/pwyasaa/input/mpl_pyplot_examples.py" target="_self"><tt>mpl_pyplot_examples.py</tt></a>.

<p>
The <code>plt</code> prefix is not a requirement for using <code>matplotlib.pyplot</code>,
as one can equally well do <code>from matplotlib.pyplot import *</code> and
get access to the same functions as shown in the section <a href="#sec:plot:pylab">Matplotlib; pylab</a> for the <code>pylab</code> functions.

<p>
Once you have created a basic plot, there are numerous possibilities
for fine-tuning the figure, i.e., adjusting tick marks on the axis,
inserting text, etc. The Matplotlib website is full of instructive
examples on what you can do with this excellent package.

<h2 id="sec:plot:SciTools">SciTools and Easyviz<a name="sec:plot:SciTools"></a></h2>

Matplotlib has become the <em>de facto</em> standard for curve plotting in
Python, but there are several other alternative packages, especially
if we also consider plotting of 2D/3D scalar and vector fields.
Python has interfaces to many leading visualization packages: MATLAB,
Gnuplot, Grace, OpenDX, and VTK. Even basic plotting with these
packages has very different syntax, and deciding what package and
syntax to go with was and still is a challenge. As a response to this
challenge, Easyviz was created to provide a common uniform interface
to all the mentioned visualization packages (including
Matplotlib). The syntax of this interface was made very close to that
of MATLAB, since most scientists and engineers have experience with
MATLAB or most probably will be using it in some context. (In general,
the Python syntax used in the examples in this document is constructed
to ease the transition to and from MATLAB.)

<p>
Easyviz is part of the SciTools package, which consists of a set of
Python tools building on Numerical Python, ScientificPython, the
comprehensive SciPy environment, and other packages for scientific
computing with Python.  SciTools contains in particular software
related to the document <a href="#TCSE3">[2]</a> and the present text. Installation
is straightforward as described on the web page <a href="http://code.google.com/p/scitools" target="_self"><tt>http://code.google.com/p/scitools</tt></a>.

<h3 id="___sec17">Importing SciTools and Easyviz <a name="___sec17"></a></h3>

A standard import of SciTools is

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">scitools.std</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
</pre></div>
<p>
The advantage of this statement is that it, with a minimum of typing,
imports a lot of useful modules for numerical Python programming:
Easyviz for MATLAB-style plotting, all of <code>numpy</code> (<code>from numpy import
*</code>), all of <code>scipy</code> (<code>from scipy import *</code>) if available, the
<code>StringFunction</code> tool (see the document <a href="http://tcse6.on.net/input" target="_self">User input and error
handling</a> <a href="#Langtangen_TCSE6_input">[3]</a>),
many mathematical functions and tools in SciTools, plus commonly
applied modules such as <code>sys</code>, <code>os</code>, and <code>math</code>.  The imported
standard mathematical functions (<code>sqrt</code>, <code>sin</code>, <code>asin</code>, <code>exp</code>, etc.)
are from <code>numpy.lib.scimath</code> and deal transparently with real and
complex input/output (as the corresponding MATLAB functions):

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">scitools.std</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #666666">&gt;&gt;&gt;</span> a <span style="color: #666666">=</span> array([<span style="color: #666666">-4.</span>, <span style="color: #666666">4</span>])
<span style="color: #666666">&gt;&gt;&gt;</span> sqrt(a)                 <span style="color: #408080; font-style: italic"># need complex output</span>
array([ <span style="color: #666666">0.+2.j</span>,  <span style="color: #666666">2.+0.j</span>])
<span style="color: #666666">&gt;&gt;&gt;</span> a <span style="color: #666666">=</span> array([<span style="color: #666666">16.</span>, <span style="color: #666666">4</span>])
<span style="color: #666666">&gt;&gt;&gt;</span> sqrt(a)                 <span style="color: #408080; font-style: italic"># can reduce to real output</span>
array([ <span style="color: #666666">4.</span>,  <span style="color: #666666">2.</span>])
</pre></div>
<p>
The inverse trigonometric functions have different names in <code>math</code> and
<code>numpy</code>, a fact that prevents an expression written for scalars, using
<code>math</code> names, to be immediately valid for arrays.  Therefore, the
<code>from scitools.std import *</code> action also imports the names <code>asin</code>,
<code>acos</code>, and <code>atan</code> for the <code>numpy</code> or <code>scipy</code>
names <code>arcsin</code>, <code>arccos</code>, and
<code>arctan</code> functions, to ease vectorization of mathematical expressions
involving inverse trigonometric functions.

<p>
The downside of the &quot;star import&quot; from <code>scitools.std</code> is twofold.
First, it fills up your program or interactive session with the names
of several hundred functions. Second, when using a particular
function, you do not know the package it comes from. Both problems are
solved by doing an import of the type used in the section <a href="#sec:plot:pyplot">Matplotlib; pyplot</a>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scitools.std</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">st</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
</pre></div>
<p>
All of the SciTools and Easyviz functions must then be prefixed by
<code>st</code>.  Although the <code>numpy</code> functions are available through the <code>st</code>
prefix, we recommend using the <code>np</code> prefix to clearly see where
functionality comes from.

<p>
Since the Easyviz syntax for plotting is very close to that of MATLAB,
it is also very close to the syntax of Matplotlib shown earlier. This
will be demonstrated in the forthcoming examples. The advantage of
using Easyviz is that the underlying plotting package, used to create
the graphics and known as a <em>backend</em>, can trivially be replaced by
another package. If users of your Python software have not installed a
particular visualization package, the software can still be used with
another alternative (which might be considerably easier to
install). By default, Easyviz now employs Matplotlib for plotting.
Other popular alternatives are Gnuplot and MATLAB. For 2D/3D scalar
and vector fields, VTK is a popular backend for Easyviz.

<p>
We shall next redo the curve plotting examples from the section <a href="#sec:plot:pylab">Matplotlib; pylab</a>
using Easyviz syntax.

<h3 id="___sec18">A basic plot <a name="___sec18"></a></h3>

Plotting the curve \( y = t^2\exp(-t^2) \) for \( t\in [0,3] \), using 31
equally spaced points (30 intervals) is performed by like this:

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">scitools.std</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>(t):
    <span style="color: #008000; font-weight: bold">return</span> t<span style="color: #666666">**2*</span>exp(<span style="color: #666666">-</span>t<span style="color: #666666">**2</span>)

t <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, <span style="color: #666666">3</span>, <span style="color: #666666">31</span>)
y <span style="color: #666666">=</span> f(t)
plot(t, y, <span style="color: #BA2121">&#39;-&#39;</span>)
</pre></div>
<p>
To save the plot in a file, we use the <code>savefig</code> function, which takes
the filename as argument:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">savefig(<span style="color: #BA2121">&#39;tmp1.pdf&#39;</span>) <span style="color: #408080; font-style: italic"># produce PDF</span>
savefig(<span style="color: #BA2121">&#39;tmp1.eps&#39;</span>) <span style="color: #408080; font-style: italic"># produce PostScript</span>
savefig(<span style="color: #BA2121">&#39;tmp1.png&#39;</span>) <span style="color: #408080; font-style: italic"># produce PNG</span>
</pre></div>
<p>
The filename extension determines the format:
<code>.pdf</code> for PDF, <code>.ps</code> or
<code>.eps</code> for PostScript, and <code>.png</code> for PNG.
A synonym for the <code>savefig</code> function is <code>hardcopy</code>.

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>What if the plot window quickly disappears?</b>
On some platforms, some backends may result in a plot that is shown in
just a fraction of a second on the screen before the plot window
disappears (the Gnuplot backend on Windows machines and
the Matplotlib backend constitute two examples). To make the window
stay on the screen, add

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span style="color: #008000">raw_input</span>(<span style="color: #BA2121">&#39;Press the Return key to quit: &#39;</span>)
</pre></div>
<p>
at the end of the program. The plot window is killed when the program
terminates, and this statement postpones the termination until the user
hits the Return key.
</div>


<h3 id="___sec19">Decorating the plot <a name="___sec19"></a></h3>

Let us plot the same curve, but now with a legend, a plot title,
labels on the axes, and specified ranges of the axes:

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">scitools.std</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>(t):
    <span style="color: #008000; font-weight: bold">return</span> t<span style="color: #666666">**2*</span>exp(<span style="color: #666666">-</span>t<span style="color: #666666">**2</span>)

t <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, <span style="color: #666666">3</span>, <span style="color: #666666">31</span>)
y <span style="color: #666666">=</span> f(t)
plot(t, y, <span style="color: #BA2121">&#39;-&#39;</span>)
xlabel(<span style="color: #BA2121">&#39;t&#39;</span>)
ylabel(<span style="color: #BA2121">&#39;y&#39;</span>)
legend(<span style="color: #BA2121">&#39;t^2*exp(-t^2)&#39;</span>)
axis([<span style="color: #666666">0</span>, <span style="color: #666666">3</span>, <span style="color: #666666">-0.05</span>, <span style="color: #666666">0.6</span>])   <span style="color: #408080; font-style: italic"># [tmin, tmax, ymin, ymax]</span>
title(<span style="color: #BA2121">&#39;My First Easyviz Demo&#39;</span>)
</pre></div>
<p>
Easyviz has also introduced a more Pythonic <code>plot</code> command where all
the plot properties can be set at once through keyword arguments:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">plot(t, y, <span style="color: #BA2121">&#39;-&#39;</span>,
     xlabel<span style="color: #666666">=</span><span style="color: #BA2121">&#39;t&#39;</span>,
     ylabel<span style="color: #666666">=</span><span style="color: #BA2121">&#39;y&#39;</span>,
     legend<span style="color: #666666">=</span><span style="color: #BA2121">&#39;t^2*exp(-t^2)&#39;</span>,
     axis<span style="color: #666666">=</span>[<span style="color: #666666">0</span>, <span style="color: #666666">3</span>, <span style="color: #666666">-0.05</span>, <span style="color: #666666">0.6</span>],
     title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;My First Easyviz Demo&#39;</span>,
     savefig<span style="color: #666666">=</span><span style="color: #BA2121">&#39;tmp1.pdf&#39;</span>,
     show<span style="color: #666666">=</span><span style="color: #008000">True</span>)
</pre></div>
<p>
With <code>show=False</code> one can avoid the plot window on the screen and
just make the plot file.

<p>
Note that we in the curve legend write <code>t</code> square as <code>t^2</code> ({\LaTeX}
style) rather than <code>t**2</code> (program style). Whichever form you choose
is up to you, but the {\LaTeX} form sometimes looks better in some
plotting programs (Matplotlib and Gnuplot are two examples).

<h3 id="___sec20">Plotting multiple curves <a name="___sec20"></a></h3>

Next we want to compare the two functions \( f_1(t)=t^2\exp(-t^2) \) and
\( f_2(t)=t^4\exp(-t^2) \). Writing two <code>plot</code> commands after each other
makes two separate plots.  To make the second curve appear together
with the first one, we need to issue a <code>hold('on')</code> call after the
first <code>plot</code> command.  All subsequent <code>plot</code> commands will then draw
curves in the same plot, until <code>hold('off')</code> is called.

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">scitools.std</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f1</span>(t):
    <span style="color: #008000; font-weight: bold">return</span> t<span style="color: #666666">**2*</span>exp(<span style="color: #666666">-</span>t<span style="color: #666666">**2</span>)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f2</span>(t):
    <span style="color: #008000; font-weight: bold">return</span> t<span style="color: #666666">**2*</span>f1(t)

t <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, <span style="color: #666666">3</span>, <span style="color: #666666">51</span>)
y1 <span style="color: #666666">=</span> f1(t)
y2 <span style="color: #666666">=</span> f2(t)

plot(t, y1, <span style="color: #BA2121">&#39;r-&#39;</span>)
hold(<span style="color: #BA2121">&#39;on&#39;</span>)
plot(t, y2, <span style="color: #BA2121">&#39;b-&#39;</span>)

xlabel(<span style="color: #BA2121">&#39;t&#39;</span>)
ylabel(<span style="color: #BA2121">&#39;y&#39;</span>)
legend(<span style="color: #BA2121">&#39;t^2*exp(-t^2)&#39;</span>, <span style="color: #BA2121">&#39;t^4*exp(-t^2)&#39;</span>)
title(<span style="color: #BA2121">&#39;Plotting two curves in the same plot&#39;</span>)
savefig(<span style="color: #BA2121">&#39;tmp3.pdf&#39;</span>)
</pre></div>
<p>
The sequence of the multiple legends is such that the first legend
corresponds to the first curve, the second legend to the second curve,
and so forth.

<p>
Instead of separate calls to <code>plot</code> and the use of <code>hold('on')</code>,
we can do everything at once and just send several curves to <code>plot</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">plot(t, y1, <span style="color: #BA2121">&#39;r-&#39;</span>, t, y2, <span style="color: #BA2121">&#39;b-&#39;</span>, xlabel<span style="color: #666666">=</span><span style="color: #BA2121">&#39;t&#39;</span>, ylabel<span style="color: #666666">=</span><span style="color: #BA2121">&#39;y&#39;</span>,
     legend<span style="color: #666666">=</span>(<span style="color: #BA2121">&#39;t^2*exp(-t^2)&#39;</span>, <span style="color: #BA2121">&#39;t^4*exp(-t^2)&#39;</span>),
     title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Plotting two curves in the same plot&#39;</span>,
     savefig<span style="color: #666666">=</span><span style="color: #BA2121">&#39;tmp3.pdf&#39;</span>)
</pre></div>
<p>
Throughout this document, we very often make use of this type of
compact <code>plot</code> command, which also only requires an import of
the form <code>from scitools.std import plot</code>.

<h3 id="___sec21">Changing backend <a name="___sec21"></a></h3>

Easyviz applies Matplotlib for plotting by default, so the resulting
figures so far will be similar to those of Figure
<a href="#fig:plot1a:pylab">2</a>-<a href="#fig:plot2a:pylab">4</a>.

<p>
However, we can use other backends (plotting packages) for creating
the graphics.  The specification of what package to use is defined in
a configuration file (see the heading <em>Setting Parameters in the
Configuration File</em> in the Easyviz documentation), or on the command
line:

<p>

<!-- code=text (!bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; python myprog.py --SCITOOLS_easyviz_backend gnuplot
</pre></div>
<p>
Now, the plotting commands in <code>myprog.py</code> will make use of Gnuplot
to create the graphics, with a slightly different result than that
created by Matplotlib (compare Figures <a href="#fig:plot2a:pylab">4</a> and
<a href="#fig:plot2a">6</a>). A nice feature of Gnuplot is that the line types
are automatically changed if we save a figure to file, such that
the lines are easily distinguishable in a black-and-white plot.
With Matplotlib one has to carefully set the line types to make
them effective on a grayscale.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 6:  Two curves in the same plot (Gnuplot). <a name="fig:plot2a"></a> </p></center>
<p><img src="fig-plot/plot2a_thick.png" align="bottom" width=400></p>
</center>

<h3 id="___sec22">Placing several plots in one figure <a name="___sec22"></a></h3>

Finally, we redo the example from the section <a href="#sec:plot:pylab">Matplotlib; pylab</a> where
two plots are combined into one figure, using the <code>subplot</code> command:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">figure()
subplot(<span style="color: #666666">2</span>, <span style="color: #666666">1</span>, <span style="color: #666666">1</span>)
t <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, <span style="color: #666666">3</span>, <span style="color: #666666">51</span>)
y1 <span style="color: #666666">=</span> f1(t)
y2 <span style="color: #666666">=</span> f2(t)
plot(t, y1, <span style="color: #BA2121">&#39;r-&#39;</span>, t, y2, <span style="color: #BA2121">&#39;bo&#39;</span>, xlabel<span style="color: #666666">=</span><span style="color: #BA2121">&#39;t&#39;</span>, ylabel<span style="color: #666666">=</span><span style="color: #BA2121">&#39;y&#39;</span>,
     legend<span style="color: #666666">=</span>(<span style="color: #BA2121">&#39;t^2*exp(-t^2)&#39;</span>, <span style="color: #BA2121">&#39;t^4*exp(-t^2)&#39;</span>),
     axis<span style="color: #666666">=</span>[t[<span style="color: #666666">0</span>], t[<span style="color: #666666">-1</span>], <span style="color: #008000">min</span>(y2)<span style="color: #666666">-0.05</span>, <span style="color: #008000">max</span>(y2)<span style="color: #666666">+0.5</span>],
     title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Top figure&#39;</span>)

subplot(<span style="color: #666666">2</span>, <span style="color: #666666">1</span>, <span style="color: #666666">2</span>)
t3 <span style="color: #666666">=</span> t[::<span style="color: #666666">4</span>]
y3 <span style="color: #666666">=</span> f2(t3)

plot(t, y1, <span style="color: #BA2121">&#39;b-&#39;</span>, t3, y3, <span style="color: #BA2121">&#39;ys&#39;</span>,
     xlabel<span style="color: #666666">=</span><span style="color: #BA2121">&#39;t&#39;</span>, ylabel<span style="color: #666666">=</span><span style="color: #BA2121">&#39;y&#39;</span>,
     axis<span style="color: #666666">=</span>[<span style="color: #666666">0</span>, <span style="color: #666666">4</span>, <span style="color: #666666">-0.2</span>, <span style="color: #666666">0.6</span>],
     legend<span style="color: #666666">=</span>(<span style="color: #BA2121">&#39;t^2*exp(-t^2)&#39;</span>, <span style="color: #BA2121">&#39;t^4*exp(-t^2)&#39;</span>))
savefig(<span style="color: #BA2121">&#39;tmp4.pdf&#39;</span>)
</pre></div>
<p>
Note that <code>figure()</code> must be used if you want a program to make
different plot windows on the screen: each <code>figure()</code> call
creates a new, separate plot.

<p>
All of the Easyviz examples above are found in the file
<a href="http://tinyurl.com/pwyasaa/input/easyviz_examples.py" target="_self"><tt>easyviz_examples.py</tt></a>.
We remark that Easyviz is just a thin layer of
code providing access to the most common plotting functionality for
curves as well as 2D/3D scalar and vector fields. Fine-tuning of
plots, e.g., specifying tick marks on the axes, is not supported,
simply because most of the curve plots in the daily work can be made
without such functionality.  For fine-tuning the plot with special
commands, you need to grab an object in Easyviz that communicates
directly with the underlying plotting package used to create the
graphics.  With this object you can issue package-specific commands
and do whatever the underlying package allows you do. This is
explained in the <a href="https://scitools.googlecode.com/hg/doc/easyviz/easyviz.html" target="_self">Easyviz manual</a>, which
also comes up by running <code>pydoc scitools.easyviz</code>.  As soon as you
have digested the very basics of plotting, you are strongly recommend
to read through the curve plotting part of the Easyviz manual.

<h2 id="easyviz:movie">Making animations<a name="easyviz:movie"></a></h2>

A sequence of plots can be combined into an animation on the
screen and stored in a
video file.
The standard procedure is to generate a series of individual plots
and to show them in sequence to obtain an animation effect.
Plots store in files can be combined to a video file.

<h3 id="___sec24">Example <a name="___sec24"></a></h3>

The function

$$
\begin{equation*}
f(x; m, s) = (2\pi)^{-1/2}s^{-1}\exp{\left[-\frac{1}{2}\left({x-m\over s}\right)^2\right]}
\end{equation*}
$$

is known as the Gaussian function or the probability density function
of the normal (or Gaussian) distribution.  This bell-shaped function
is wide for large \( s \) and peak-formed for small \( s \), see Figure
<a href="#fig:plot4">7</a>. The function is symmetric around \( x=m \) (\( m=0 \) in the
figure).  Our goal is to make an animation where we see how this
function evolves as \( s \) is decreased. In Python we implement the
formula above as a function <code>f(x, m, s)</code>.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 7:  Different shapes of a Gaussian function. <a name="fig:plot4"></a> </p></center>
<p><img src="fig-plot/plot4_thick.png" align="bottom" width=400></p>
</center>

<p>
The animation is created by varying \( s \) in a loop and for each \( s \)
issue a <code>plot</code> command. A moving curve is then visible on the screen.
One can also make a video that can be played as any other
computer movie using a standard movie player.
To this end, each plot
is saved to a file, and all the files are combined together using some
suitable tool to be explained later. Before going into
programming detail there is one key point to emphasize.

<p>
<div class="alert alert-block alert-danger alert-text-normal"><b>Keep the extent of axes fixed during animations!</b>
The underlying plotting program will normally adjust the axis to the
maximum and minimum values of the curve if we do not specify the axis
ranges explicitly. For an animation such automatic axis adjustment is
misleading - any axis range must be fixed to avoid a jumping
axis.
</div>


<p>
The relevant values for the \( y \) axis range in the present example
is the minimum and
maximum value of \( f \). The minimum value is zero, while the maximum
value appears for \( x=m \) and increases with decreasing \( s \). The range
of the \( y \) axis must therefore be \( [0,f(m; m, \min s)] \).

<p>
The function \( f \) is defined for all \( -\infty < x < \infty \), but the
function value is very small already \( 3s \) away from \( x=m \). We may
therefore limit the \( x \) coordinates to \( [m-3s,m+3s] \).

<h3 id="___sec25">Animation in Easyviz <a name="___sec25"></a></h3>

We start with using Easyviz for animation since this is almost
identical to making standard static plots, and you can choose the
plotting engine you want to use, say Gunplot or Matplotlib.  The
Easyviz recipe for animating the Gaussian function as \( s \) goes
from 2 to 0.2 looks as follows.

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">scitools.std</span> <span style="color: #008000; font-weight: bold">import</span> sqrt, pi, exp, linspace, plot, movie
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">time</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>(x, m, s):
    <span style="color: #008000; font-weight: bold">return</span> (<span style="color: #666666">1.0/</span>(sqrt(<span style="color: #666666">2*</span>pi)<span style="color: #666666">*</span>s))<span style="color: #666666">*</span>exp(<span style="color: #666666">-0.5*</span>((x<span style="color: #666666">-</span>m)<span style="color: #666666">/</span>s)<span style="color: #666666">**2</span>)

m <span style="color: #666666">=</span> <span style="color: #666666">0</span>
s_min <span style="color: #666666">=</span> <span style="color: #666666">0.2</span>
s_max <span style="color: #666666">=</span> <span style="color: #666666">2</span>
x <span style="color: #666666">=</span> linspace(m <span style="color: #666666">-3*</span>s_max, m <span style="color: #666666">+</span> <span style="color: #666666">3*</span>s_max, <span style="color: #666666">1000</span>)
s_values <span style="color: #666666">=</span> linspace(s_max, s_min, <span style="color: #666666">30</span>)
<span style="color: #408080; font-style: italic"># f is max for x=m; smaller s gives larger max value</span>
max_f <span style="color: #666666">=</span> f(m, m, s_min)

<span style="color: #408080; font-style: italic"># Show the movie on the screen</span>
<span style="color: #408080; font-style: italic"># and make hardcopies of frames simultaneously.</span>

counter <span style="color: #666666">=</span> <span style="color: #666666">0</span>
<span style="color: #008000; font-weight: bold">for</span> s <span style="color: #AA22FF; font-weight: bold">in</span> s_values:
    y <span style="color: #666666">=</span> f(x, m, s)
    plot(x, y, <span style="color: #BA2121">&#39;-&#39;</span>, axis<span style="color: #666666">=</span>[x[<span style="color: #666666">0</span>], x[<span style="color: #666666">-1</span>], <span style="color: #666666">-0.1</span>, max_f],
         xlabel<span style="color: #666666">=</span><span style="color: #BA2121">&#39;x&#39;</span>, ylabel<span style="color: #666666">=</span><span style="color: #BA2121">&#39;f&#39;</span>, legend<span style="color: #666666">=</span><span style="color: #BA2121">&#39;s=</span><span style="color: #BB6688; font-weight: bold">%4.2f</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> s,
         savefig<span style="color: #666666">=</span><span style="color: #BA2121">&#39;tmp</span><span style="color: #BB6688; font-weight: bold">%04d</span><span style="color: #BA2121">.png&#39;</span> <span style="color: #666666">%</span> counter)
    counter <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
    <span style="color: #408080; font-style: italic">#time.sleep(0.2)  # can insert a pause to control movie speed</span>
</pre></div>
<p>
Note that the \( s \) values are decreasing (<code>linspace</code> handles this
automatically if the start value is greater than the stop value).
Also note that we, simply because we think it is visually more
attractive, let the \( y \) axis go from -0.1 although the \( f \) function is
always greater than zero. The complete code is found in the file
<a href="http://tinyurl.com/pwyasaa/plot/movie1.py" target="_self"><tt>movie1.py</tt></a>.

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Notice.</b>
It is crucial to use the single, compound <code>plot</code> command shown above,
where axis, labels, legends, etc., are set in the same call. Splitting
up in individual calls to <code>plot</code>, <code>axis</code>, and so forth, results in
jumping curves and axis. Also, when visualizing more than one animated
curve at a time, make sure you send all data to a single <code>plot</code>
command.
</div>


<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Remark on naming plot files.</b>
For each frame (plot) in the movie we store the plot in a file,
with the purpose of combining all the files to an ordinary video file.
The different files need different names such that various methods
for listing the files will list them in the correct order.
To this end, we recommend using filenames
of the form <code>tmp0001.png</code>, <code>tmp0002.png</code>, <code>tmp0003.png</code>, etc.  The
printf format <code>04d</code> pads the integers with zeros such that <code>1</code> becomes
<code>0001</code>, <code>13</code> becomes <code>0013</code> and so on.  The expression <code>tmp*.png</code> will
now expand (by an alphabetic sort) to a list of all files in proper
order.

<p>
Without the padding with zeros, i.e., names of the form
<code>tmp1.png</code>, <code>tmp2.png</code>, ..., <code>tmp12.png</code>, etc., the alphabetic order
will give a wrong sequence of frames in the movie. For instance,
<code>tmp12.png</code> will appear before <code>tmp2.png</code>.
</div>


<h3 id="___sec26">Basic animation in Matplotlib <a name="___sec26"></a></h3>

Animation is Matplotib requires more than a loop over a parameter and
making a plot inside the loop. The set-up that is closest to standard static
plots is shown first, while the newer and more widely used tool
<code>FuncAnimation</code> is explained afterwards.

<p>
The first part of the program, where we define <code>f</code>, <code>x</code>, <code>s_values</code>,
and so forth, is the same regardless of the animation
technique. Therefore, we concentrate on the graphics part here:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
<span style="color: #666666">...</span>
<span style="color: #408080; font-style: italic"># Make a first plot</span>
plt<span style="color: #666666">.</span>ion()
y <span style="color: #666666">=</span> f(x, m, s_max)
lines <span style="color: #666666">=</span> plt<span style="color: #666666">.</span>plot(x, y)
plt<span style="color: #666666">.</span>axis([x[<span style="color: #666666">0</span>], x[<span style="color: #666666">-1</span>], <span style="color: #666666">-0.1</span>, max_f])
plt<span style="color: #666666">.</span>xlabel(<span style="color: #BA2121">&#39;x&#39;</span>)
plt<span style="color: #666666">.</span>ylabel(<span style="color: #BA2121">&#39;f&#39;</span>)

<span style="color: #408080; font-style: italic"># Show the movie, and make hardcopies of frames simulatenously</span>
counter <span style="color: #666666">=</span> <span style="color: #666666">0</span>
<span style="color: #008000; font-weight: bold">for</span> s <span style="color: #AA22FF; font-weight: bold">in</span> s_values:
    y <span style="color: #666666">=</span> f(x, m, s)
    lines[<span style="color: #666666">0</span>]<span style="color: #666666">.</span>set_ydata(y)
    plt<span style="color: #666666">.</span>legend([<span style="color: #BA2121">&#39;s=</span><span style="color: #BB6688; font-weight: bold">%4.2f</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> s])
    plt<span style="color: #666666">.</span>draw()
    plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp_</span><span style="color: #BB6688; font-weight: bold">%04d</span><span style="color: #BA2121">.png&#39;</span> <span style="color: #666666">%</span> counter)
    counter <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
</pre></div>
<p>
The <code>plt.ion()</code> call is important, so is the first plot, where we grab
the result of the <code>plot</code> command, which is a list of Matplotlib's
<code>Line2D</code> objects. The idea is then to update the data via
<code>lines[0].set_ydata</code> and show the plot via <code>plt.draw()</code> for each
frame. For multiple curves we must update the \( y \) data for each curve,
e.g.,

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">lines <span style="color: #666666">=</span> plot(x, y1, x, y2, x, y3)

<span style="color: #008000; font-weight: bold">for</span> parameter <span style="color: #AA22FF; font-weight: bold">in</span> parameters:
    y1 <span style="color: #666666">=</span> <span style="color: #666666">...</span>
    y2 <span style="color: #666666">=</span> <span style="color: #666666">...</span>
    y3 <span style="color: #666666">=</span> <span style="color: #666666">...</span>
    <span style="color: #008000; font-weight: bold">for</span> line, y <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">zip</span>(lines, [y1, y2, y3]):
        line<span style="color: #666666">.</span>set_ydata(y)
    plt<span style="color: #666666">.</span>draw()
</pre></div>
<p>
The file <a href="http://tinyurl.com/pwyasaa/plot/movie1_mpl1.py" target="_self"><tt>movie1_mpl1.py</tt></a>
contains the complete program for doing animation
with native Matplotlib syntax.

<h3 id="___sec27">Using FuncAnimation in Matplotlib <a name="___sec27"></a></h3>

The recommended approach to animation in Matplotlib is to use the
<code>FuncAnimation</code> tool:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib.animation</span> <span style="color: #008000; font-weight: bold">import</span> animation

anim <span style="color: #666666">=</span> animation<span style="color: #666666">.</span>FuncAnimation(
    fig, frame, all_args, interval<span style="color: #666666">=150</span>, init_func<span style="color: #666666">=</span>init, blit<span style="color: #666666">=</span><span style="color: #008000">True</span>)
</pre></div>
<p>
Here, <code>fig</code> is the <code>plt.figure()</code> object for the current figure,
<code>frame</code> is a user-defined function for plotting each frame,
<code>all_args</code> is a list of arguments for <code>frame</code>, <code>interval</code> is
the delay in ms between each frame, <code>init_func</code> is a function
called for defining the background plot in the animation, and
<code>blit=True</code> speeds up the animation.
For frame number <code>i</code>, <code>FuncAnimation</code> will call
<code>frame(all_args[i])</code>. Hence, the user's task is mostly to write the
<code>frame</code> function and construct the <code>all_args</code> arguments.

<p>
After having defined <code>m</code>, <code>s_max</code>, <code>s_min</code>, <code>s_values</code>, and <code>max_f</code>
as shown earlier, we have to make a first plot:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">fig <span style="color: #666666">=</span> plt<span style="color: #666666">.</span>figure()
plt<span style="color: #666666">.</span>axis([x[<span style="color: #666666">0</span>], x[<span style="color: #666666">-1</span>], <span style="color: #666666">-0.1</span>, max_f])
lines <span style="color: #666666">=</span> plt<span style="color: #666666">.</span>plot([], [])
plt<span style="color: #666666">.</span>xlabel(<span style="color: #BA2121">&#39;x&#39;</span>)
plt<span style="color: #666666">.</span>ylabel(<span style="color: #BA2121">&#39;f&#39;</span>)
</pre></div>
<p>
Notice that we save the return value of <code>plt.plot</code> in <code>lines</code> such that
we can conveniently update the data for the curve(s) in each frame.

<p>
The function for defining a background plot draws an empty plot
in this example:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">init</span>():
    lines[<span style="color: #666666">0</span>]<span style="color: #666666">.</span>set_data([], [])  <span style="color: #408080; font-style: italic"># empty plot</span>
    <span style="color: #008000; font-weight: bold">return</span> lines
</pre></div>
<p>
The function that defines the individual plots in the animation
basically computes <code>y</code> from <code>f</code> and updates the data of the curve:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">frame</span>(args):
    frame_no, s, x, lines <span style="color: #666666">=</span> args
    y <span style="color: #666666">=</span> f(x, m, s)
    lines[<span style="color: #666666">0</span>]<span style="color: #666666">.</span>set_data(x, y)
    <span style="color: #008000; font-weight: bold">return</span> lines
</pre></div>
<p>
Multiple curves can be updated as shown earlier.

<p>
We are now ready to call <code>animation.FuncAnimation</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">anim <span style="color: #666666">=</span> animation<span style="color: #666666">.</span>FuncAnimation(
    fig, frame, all_args, interval<span style="color: #666666">=150</span>, init_func<span style="color: #666666">=</span>init, blit<span style="color: #666666">=</span><span style="color: #008000">True</span>)
</pre></div>
<p>
A common next action is to make a video file, here in
the MP4 format with 5 frames per second:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">anim<span style="color: #666666">.</span>save(<span style="color: #BA2121">&#39;movie1.mp4&#39;</span>, fps<span style="color: #666666">=5</span>)   <span style="color: #408080; font-style: italic"># movie in MP4 format</span>
</pre></div>
<p>
Finally, we must <code>plt.show()</code> as always to watch any plots on
the screen.

<p>
The video making requires additional software on the computer, such as
<code>ffmpeg</code>, and can fail. One gets more control over the potentially
fragile movie making process by explicitly saving plots to
file and explicitly running movie making programs like <code>ffmeg</code>
later. Such programs are explained in the section <a href="#sec:plot:video">Making videos</a>.

<p>
The complete code showing the basic use of
<code>FuncAnimation</code> is available in <a href="http://tinyurl.com/pwyasaa/plot/movie1_FuncAnimation.py" target="_self"><tt>movie1_FuncAnimation.py</tt></a>.
There is also a <a href="http://jakevdp.github.io/blog/2012/08/18/matplotlib-animation-tutorial/" target="_self">Matlab Animation
Tutorial</a>
with more basic information, plus a set of animation examples on <a href="http://matplotlib.org/examples" target="_self"><tt>http://matplotlib.org/examples</tt></a>.

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Remove old plot files!</b>
We strongly recommend removing previously generated plot files before a
new set of files is made. Otherwise, the movie may get old and new
files mixed up. The following Python code removes all files of the
form <code>tmp*.png</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">glob</span><span style="color: #666666">,</span> <span style="color: #0000FF; font-weight: bold">os</span>
<span style="color: #008000; font-weight: bold">for</span> filename <span style="color: #AA22FF; font-weight: bold">in</span> glob<span style="color: #666666">.</span>glob(<span style="color: #BA2121">&#39;tmp*.png&#39;</span>):
    os<span style="color: #666666">.</span>remove(filename)
</pre></div>
<p>
These code lines should be inserted at the beginning of programs
or functions performing animations.
</div>


<p>
Instead of deleting the individual plotfiles,
one may store all plot files in a subfolder
and later delete the subfolder. Here is a suitable code segment:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">shutil</span><span style="color: #666666">,</span> <span style="color: #0000FF; font-weight: bold">os</span>
subdir <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;temp&#39;</span>            <span style="color: #408080; font-style: italic"># subfolder name for plot files</span>
<span style="color: #008000; font-weight: bold">if</span> os<span style="color: #666666">.</span>path<span style="color: #666666">.</span>isdir(subdir):  <span style="color: #408080; font-style: italic"># does the subfolder already exist?</span>
    shutil<span style="color: #666666">.</span>rmtree(subdir)  <span style="color: #408080; font-style: italic"># delete the whole folder</span>
os<span style="color: #666666">.</span>mkdir(subdir)           <span style="color: #408080; font-style: italic"># make new subfolder</span>
os<span style="color: #666666">.</span>chdir(subdir)           <span style="color: #408080; font-style: italic"># move to subfolder</span>
<span style="color: #408080; font-style: italic"># ... perform all the plotting, make movie ...</span>
os<span style="color: #666666">.</span>chdir(os<span style="color: #666666">.</span>pardir)        <span style="color: #408080; font-style: italic"># optional: move up to parent folder</span>
</pre></div>
<p>
Note that Python and many other languages use the word directory
instead of folder.  Consequently, the name of functions dealing with
folders have a name containing <code>dir</code> for directory.

<h2 id="sec:plot:video">Making videos<a name="sec:plot:video"></a></h2>

Suppose we have a set of frames in an animation, saved
as plot files <code>tmp_*.png</code>. The filenames are generated by
the printf syntax <code>'tmp_%04d.png' % i</code>, using a frame counter <code>i</code>
that goes from 0 to some value. The corresponding files are then
<code>tmp_0000.png</code>, <code>tmp_0001.png</code>, <code>tmp_0002.png</code>, and so on.
Several tools can be used to create videos in common formats from
the individual frames in the plot files.

<h3 id="___sec29">Animated GIF file <a name="___sec29"></a></h3>

The <a href="http://www.imagemagick.org/" target="_self">ImageMagick</a> software suite contains
a program <code>convert</code> for making animated GIF files:

<p>

<!-- code=text (!bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; convert -delay 50 tmp_*.png movie.gif
</pre></div>
<p>
The delay between frames, here 50, is measured in units of 1/100 s.
The resulting animated GIF file <code>movie.gif</code> can be viewed by another
program in the ImageMagick suite: <code>animate movie.gif</code>, but the
most common way of displaying animated GIF files is to include them
in web pages. Writing the HTML code

<p>

<!-- code=html (!bc htmlcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">&lt;img</span> <span style="color: #7D9029">src=</span><span style="color: #BA2121">&quot;movie.gif&quot;</span><span style="color: #008000; font-weight: bold">&gt;</span>
</pre></div>
<p>
in some file with extension <code>.html</code> and loading this file into a
web browser will play the movie repeatedly.
You may try this out <a href="http://hplgit.github.io/scipro-primer/video/gaussian.html" target="_self">online</a>.

<h3 id="___sec30">MP4, Ogg, WebM, and Flash videos <a name="___sec30"></a></h3>

The modern video formats that are best suited for being displayed
in web browsers are MP4, Ogg, WebM, and Flash. The program <code>ffmpeg</code>, or
the almost equivalent <code>avconv</code>, is a common tool to create such
movies. Creating a flash video is done by

<p>

<!-- code=text (!bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; ffmpeg -r 5 -i tmp_%04d.png -vcodec flv movie.flv
</pre></div>
<p>
The <code>-r</code> option specifies the number of frames per second, here 5,
the <code>-i</code> option
specifies the printf string that was used to make the names of the
individual plot files, <code>-vcodec</code> is the video codec for Flash,
which is called <code>flv</code>, and the final argument is the name of the
video file. On Debian Linux systems, such as Ubuntu, you use
the <code>avconv</code> program instead of <code>ffmpeg</code>.

<p>
Other formats are created in the same way, but we need to
specify the codec and use the right extension in the video file:

<p>

<div class="row">
  <div class="col-xs-3">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center"><b>                 Format                 </b></td> <td align="center"><b>           Codec and filename           </b></td> </tr>
</thead>
<tbody>
<tr><td align="left">   Flash                                       </td> <td align="left">   <code>-vcodec flv movie.flv</code>          </td> </tr>
<tr><td align="left">   MP4                                         </td> <td align="left">   <code>-vcodec libx264 movie.mp4</code>      </td> </tr>
<tr><td align="left">   Webm                                        </td> <td align="left">   <code>-vcodec libvpx movie.webm</code>      </td> </tr>
<tr><td align="left">   Ogg                                         </td> <td align="left">   <code>-vcodec libtheora movie.ogg</code>    </td> </tr>
</tbody>
    </table>
  </div>
</div> <!-- col-xs-3 -->
<p>
Video files are normally trivial to play in graphical file
browser: double lick
the filename or right-click and choose a player. On Linux systems there
are several players that can be run from the command line, e.g.,
<code>vlc</code>, <code>mplayer</code>, <code>gxine</code>, and <code>totem</code>.

<p>
It is easy to create the video file from a Python program since we
can run any operating system command in (e.g.) <code>os.system</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">cmd <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;convert -delay 50 tmp_*.png movie.gif&#39;</span>
os<span style="color: #666666">.</span>system(cmd)
</pre></div>
<p>
It might happen that your downloaded and installed version of
<code>ffmpeg</code> fails to generate videos in some of the mentioned
formats. The reason is that <code>ffmpeg</code> depends on many other
packages that may be missing on your system.
Getting <code>ffmpeg</code> to work with the <code>libx264</code> codec
for making MP4 files is often challenging. On Debian-based
Linux systems, such as Ubuntu, the installation procedure at
the time of this writing goes like

<p>

<!-- code=text (!bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; sudo apt-get install lib-avtools libavcodec-extra-53 \ 
          libx264-dev
</pre></div>

<h2 id="___sec31">Curve plots in pure text <a name="___sec31"></a></h2>

Sometimes it can be desirable to show a graph in pure ASCII text,
e.g., as part of a trial run of a program included in the program
itself, or a graph that can be illustrative in a doc string. For such
purposes we have slightly extended a module by Imri Goldberg
(<code>aplotter.py</code>) and included it as a module in SciTools.  Running
<code>pydoc</code> on <code>scitools.aplotter</code> describes the capabilities of this type
of primitive plotting. Here we just give an example of what it can do:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #666666">&gt;&gt;&gt;</span> x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">-2</span>, <span style="color: #666666">2</span>, <span style="color: #666666">81</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> y <span style="color: #666666">=</span> np<span style="color: #666666">.</span>exp(<span style="color: #666666">-0.5*</span>x<span style="color: #666666">**2</span>)<span style="color: #666666">*</span>np<span style="color: #666666">.</span>cos(np<span style="color: #666666">.</span>pi<span style="color: #666666">*</span>x)
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">scitools.aplotter</span> <span style="color: #008000; font-weight: bold">import</span> plot
<span style="color: #666666">&gt;&gt;&gt;</span> plot(x, y)
                                        <span style="color: #666666">|</span>
                                       <span style="color: #666666">-+1</span>
                                     <span style="color: #666666">//</span> <span style="color: #666666">|</span>\\ 
                                    <span style="color: #666666">/</span>   <span style="color: #666666">|</span>  \ 
                                   <span style="color: #666666">/</span>    <span style="color: #666666">|</span>   \ 
                                  <span style="color: #666666">/</span>     <span style="color: #666666">|</span>   \ 
                                  <span style="color: #666666">/</span>     <span style="color: #666666">|</span>    \ 
                                 <span style="color: #666666">/</span>      <span style="color: #666666">|</span>     \ 
                                <span style="color: #666666">/</span>       <span style="color: #666666">|</span>      \ 
                               <span style="color: #666666">/</span>        <span style="color: #666666">|</span>      \ 
   <span style="color: #666666">-------</span>\                    <span style="color: #666666">/</span>        <span style="color: #666666">|</span>       \ 
<span style="color: #666666">---+-------</span>\\<span style="color: #666666">-----------------/---------+--------</span>\<span style="color: #666666">-----------------/</span>
   <span style="color: #666666">-2</span>        \                <span style="color: #666666">/</span>         <span style="color: #666666">|</span>        \                <span style="color: #666666">/</span>
              \\              <span style="color: #666666">/</span>         <span style="color: #666666">|</span>         \             <span style="color: #666666">//</span>
                \            <span style="color: #666666">/</span>          <span style="color: #666666">|</span>         \            <span style="color: #666666">/</span>
                 \\         <span style="color: #666666">/</span>           <span style="color: #666666">|</span>          \         <span style="color: #666666">//</span>
                   \       <span style="color: #666666">/</span>            <span style="color: #666666">|</span>           \       <span style="color: #666666">/</span>
                    \    <span style="color: #666666">//</span>             <span style="color: #666666">|</span>            \<span style="color: #666666">-</span>    <span style="color: #666666">//</span>
                     <span style="color: #666666">----</span>               <span style="color: #666666">-0.63</span>          <span style="color: #666666">---/</span>
                                        <span style="color: #666666">|</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #408080; font-style: italic"># plot circles at data points only:</span>
<span style="color: #666666">&gt;&gt;&gt;</span> plot(x, y, dot<span style="color: #666666">=</span><span style="color: #BA2121">&#39;o&#39;</span>, plot_slope<span style="color: #666666">=</span><span style="color: #008000">False</span>)
                                        <span style="color: #666666">|</span>
                                       o<span style="color: #666666">+1</span>
                                     oo <span style="color: #666666">|</span>oo
                                    o   <span style="color: #666666">|</span>  o
                                   o    <span style="color: #666666">|</span>   o
                                        <span style="color: #666666">|</span>
                                  o     <span style="color: #666666">|</span>    o
                                 o      <span style="color: #666666">|</span>     o
                                o       <span style="color: #666666">|</span>      o
                                        <span style="color: #666666">|</span>
   oooooooo                    o        <span style="color: #666666">|</span>       o
<span style="color: #666666">---+-------</span>oo<span style="color: #666666">-----------------</span>o<span style="color: #666666">---------+--------</span>o<span style="color: #666666">-----------------</span>o
   <span style="color: #666666">-2</span>        o                          <span style="color: #666666">|</span>                         o
              oo              o         <span style="color: #666666">|</span>         o             oo
                o            o          <span style="color: #666666">|</span>         o            o
                 oo         o           <span style="color: #666666">|</span>          o         oo
                   o       o            <span style="color: #666666">|</span>           o       o
                    o    oo             <span style="color: #666666">|</span>            oo    oo
                     oooo               <span style="color: #666666">-0.63</span>          oooo
                                        <span style="color: #666666">|</span>
<span style="color: #666666">&gt;&gt;&gt;</span> p <span style="color: #666666">=</span> plot(x, y, output<span style="color: #666666">=</span><span style="color: #008000">str</span>)   <span style="color: #408080; font-style: italic"># store plot in a string p</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">print</span> p
</pre></div>
<p>
(The last 13 characters of the output lines are here removed to make the lines
fit the maximum textwidth of this document.)

<h1 id="sec:plot:difficulties">Plotting difficulties<a name="sec:plot:difficulties"></a></h1>

The previous examples on plotting functions demonstrate how easy it is
to make graphs. Nevertheless, the shown techniques might easily fail
to plot some functions correctly unless we are careful.  Next we
address two types of difficult functions: piecewisely defined
functions and rapidly varying functions.

<h2 id="sec:plot:pwisefunc">Piecewisely defined functions<a name="sec:plot:pwisefunc"></a></h2>

A piecewisely defined function has different function definitions in
different intervals along the \( x \) axis. The resulting function, made
up of pieces, may have discontinuities in the function value or in
derivatives. We have to be very careful when plotting such functions,
as the next two examples will show. The problem is that the plotting
mechanism draws straight lines between coordinates on the function's
curve, and these straight lines may not yield a satisfactory
visualization of the function.  The first example has a discontinuity
in the function itself at one point, while the other example has a
discontinuity in the derivative at three points.

<h3 id="___sec34">Example: The Heaviside function <a name="___sec34"></a></h3>

Let us plot the Heaviside function

$$
\begin{equation*}
H(x) = \left\lbrace\begin{array}{ll}
0, & x < 0\\ 
1, & x\geq 0
\end{array}\right.
\end{equation*}
$$

The most natural way to proceed is first to define the function as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">H</span>(x):
    <span style="color: #008000; font-weight: bold">return</span> (<span style="color: #666666">0</span> <span style="color: #008000; font-weight: bold">if</span> x <span style="color: #666666">&lt;</span> <span style="color: #666666">0</span> <span style="color: #008000; font-weight: bold">else</span> <span style="color: #666666">1</span>)
</pre></div>
<p>
The standard plotting procedure where we define a coordinate array <code>x</code>
and call <code>y = H(x)</code> will not work for array arguments <code>x</code>, of reasons
to be explained in the section <a href="#sec:vec:Heaviside">Vectorization of the Heaviside function</a>.  However, we may
use techniques from that chapter to create a function <code>Hv(x)</code> that
works for array arguments.  Even with such a function we face
difficulties with plotting it.

<p>
Since the Heaviside function consists of two flat lines, one may think
that we do not need many points along the \( x \) axis to describe the
curve.  Let us try with nine points:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">-10</span>, <span style="color: #666666">10</span>, <span style="color: #666666">9</span>)
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">scitools.std</span> <span style="color: #008000; font-weight: bold">import</span> plot
plot(x, Hv(x), axis<span style="color: #666666">=</span>[x[<span style="color: #666666">0</span>], x[<span style="color: #666666">-1</span>], <span style="color: #666666">-0.1</span>, <span style="color: #666666">1.1</span>])
</pre></div>
<p>
However, so few \( x \) points are not able to describe the jump from 0 to
1 at \( x=0 \), as shown by the solid line in Figure
<a href="#fig:plot:Heaviside">8</a>a.  Using more points, say 50 between \( -10 \) and
\( 10 \),

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">x2 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">-10</span>, <span style="color: #666666">10</span>, <span style="color: #666666">50</span>)
plot(x, Hv(x), <span style="color: #BA2121">&#39;r&#39;</span>, x2, Hv(x2), <span style="color: #BA2121">&#39;b&#39;</span>,
     legend<span style="color: #666666">=</span>(<span style="color: #BA2121">&#39;5 points&#39;</span>, <span style="color: #BA2121">&#39;50 points&#39;</span>),
     axis<span style="color: #666666">=</span>[x[<span style="color: #666666">0</span>], x[<span style="color: #666666">-1</span>], <span style="color: #666666">-0.1</span>, <span style="color: #666666">1.1</span>])
</pre></div>
<p>
makes the curve look better. However, the step is still not strictly
vertical.  More points will improve the situation. Nevertheless, the
best is to draw two flat lines directly: from \( (-10,0) \) to \( (0,0) \),
then to \( (0,1) \) and then to \( (10,1) \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">plot([<span style="color: #666666">-10</span>, <span style="color: #666666">0</span>, <span style="color: #666666">0</span>, <span style="color: #666666">10</span>], [<span style="color: #666666">0</span>, <span style="color: #666666">0</span>, <span style="color: #666666">1</span>, <span style="color: #666666">1</span>],
     axis<span style="color: #666666">=</span>[x[<span style="color: #666666">0</span>], x[<span style="color: #666666">-1</span>], <span style="color: #666666">-0.1</span>, <span style="color: #666666">1.1</span>])
</pre></div>
<p>
The result is shown in Figure <a href="#fig:plot:Heaviside">8</a>b.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 8:  Plot of the Heaviside function using 9 equally spaced \( x \) points (left) and with a double point at \( x=0 \) (right). <a name="fig:plot:Heaviside"></a> </p></center>
<p><img src="fig-plot/Heaviside.png" align="bottom" width=400></p>
</center>

<p>
Some will argue that the plot of \( H(x) \) should not contain the vertical
line from \( (0,0) \) to \( (0,1) \), but only two horizontal lines. To make
such a plot, we must draw two distinct curves, one for each horizontal
line:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">plot([<span style="color: #666666">-10</span>,<span style="color: #666666">0</span>], [<span style="color: #666666">0</span>,<span style="color: #666666">0</span>], <span style="color: #BA2121">&#39;r-&#39;</span>, [<span style="color: #666666">0</span>,<span style="color: #666666">10</span>], [<span style="color: #666666">1</span>,<span style="color: #666666">1</span>], <span style="color: #BA2121">&#39;r-&#39;</span>,
     axis<span style="color: #666666">=</span>[x[<span style="color: #666666">0</span>], x[<span style="color: #666666">-1</span>], <span style="color: #666666">-0.1</span>, <span style="color: #666666">1.1</span>])
</pre></div>
<p>
Observe that we must specify the same line style for both lines
(curves), otherwise they would by default get different colors on the
screen or different line types in a hardcopy of the plot.  We remark,
however, that discontinuous functions like \( H(x) \) are often visualized
with vertical lines at the jumps, as we do in Figure
<a href="#fig:plot:Heaviside">8</a>b.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 9:  Plot of a hat function. The solid line shows the exact function, while the dashed line arises from using inappropriate points along the \( x \) axis. <a name="fig:plot:Hat"></a> </p></center>
<p><img src="fig-plot/Hat1.png" align="bottom" width=400></p>
</center>

<h3 id="___sec35">Example: A hat function <a name="___sec35"></a></h3>

Let us plot the hat function \( N(x) \), shown as the solid line in Figure
<a href="#fig:plot:Hat">9</a>. This function is a piecewise linear function. The
implementation of \( N(x) \) must use <code>if</code> tests to locate where we are
along the \( x \) axis and then evaluate the right linear piece of \( N(x) \).
A straightforward implementation with plain <code>if</code> tests does not work
with array arguments <code>x</code>, but the section <a href="#sec:vec:hatfunc">Vectorization of a hat function</a> explains
how to make a vectorized version <code>Nv(x)</code> that works for array
arguments as well.  Anyway, both the scalar and the vectorized
versions face challenges when it comes to plotting.

<p>
A first approach to plotting could be

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">-2</span>, <span style="color: #666666">4</span>, <span style="color: #666666">6</span>)
plot(x, Nv(x), <span style="color: #BA2121">&#39;r&#39;</span>, axis<span style="color: #666666">=</span>[x[<span style="color: #666666">0</span>], x[<span style="color: #666666">-1</span>], <span style="color: #666666">-0.1</span>, <span style="color: #666666">1.1</span>])
</pre></div>
<p>
This results in the dashed line in Figure <a href="#fig:plot:Hat">9</a>.
What is the problem? The problem lies in the computation of the
<code>x</code> vector, which does not contain the points \( x=1 \) and \( x=2 \)
where the function makes significant changes. The result is that
the hat is flattened. Making an <code>x</code> vector with all
critical points in the function definitions, \( x=0,1,2 \), provides
the necessary remedy, either

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">-2</span>, <span style="color: #666666">4</span>, <span style="color: #666666">7</span>)
</pre></div>
<p>
or the simple

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">x <span style="color: #666666">=</span> [<span style="color: #666666">-2</span>, <span style="color: #666666">0</span>, <span style="color: #666666">1</span>, <span style="color: #666666">2</span>, <span style="color: #666666">4</span>]
</pre></div>
<p>
Any of these <code>x</code> alternatives and a <code>plot(x, Nv(x))</code>
will result in the solid line in Figure <a href="#fig:plot:Hat">9</a>,
which is the correct visualization of the \( N(x) \) function.

<p>
As in the case of the Heaviside function, it is perhaps best
to drop using vectorized evaluations and just draw straight
lines between the critical points of the function (since the
function is linear):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">x <span style="color: #666666">=</span> [<span style="color: #666666">-2</span>, <span style="color: #666666">0</span>, <span style="color: #666666">1</span>, <span style="color: #666666">2</span>, <span style="color: #666666">4</span>]
y <span style="color: #666666">=</span> [N(xi) <span style="color: #008000; font-weight: bold">for</span> xi <span style="color: #AA22FF; font-weight: bold">in</span> x]
plot(x, y, <span style="color: #BA2121">&#39;r&#39;</span>, axis<span style="color: #666666">=</span>[x[<span style="color: #666666">0</span>], x[<span style="color: #666666">-1</span>], <span style="color: #666666">-0.1</span>, <span style="color: #666666">1.1</span>])
</pre></div>

<h2 id="sec:plot:sin1x">Rapidly varying functions<a name="sec:plot:sin1x"></a></h2>

Let us now visualize the function
\( f(x) = \sin (1/x) \), using 10 and 1000 points:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>(x):
    <span style="color: #008000; font-weight: bold">return</span> sin(<span style="color: #666666">1.0/</span>x)

<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">scitools.std</span> <span style="color: #008000; font-weight: bold">import</span> linspace, plot
x1 <span style="color: #666666">=</span> linspace(<span style="color: #666666">-1</span>, <span style="color: #666666">1</span>, <span style="color: #666666">10</span>)
x2 <span style="color: #666666">=</span> linspace(<span style="color: #666666">-1</span>, <span style="color: #666666">1</span>, <span style="color: #666666">1000</span>)
plot(x1, f(x1), label<span style="color: #666666">=</span><span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121"> points&#39;</span> <span style="color: #666666">%</span> <span style="color: #008000">len</span>(x))
plot(x2, f(x2), label<span style="color: #666666">=</span><span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121"> points&#39;</span> <span style="color: #666666">%</span> <span style="color: #008000">len</span>(x))
</pre></div>
<p>
The two plots are shown in Figure <a href="#fig:plot:sin1overx">10</a>.
Using only 10 points gives a completely wrong picture of this
function, because the function oscillates faster and faster as we
approach the origin. With 1000 points we get an impression of these
oscillations, but the accuracy of the plot in the vicinity of the
origin is still poor. A plot with 100000 points has better
accuracy, in principle, but the extremely fast oscillations near
the origin just drowns in black ink (you can try it out yourself).

<p>
Another problem with the \( f(x)=\sin (1/x) \) function is that it is easy
to define an <code>x</code> vector containing \( x=0 \), such that we get division
by zero. Mathematically, the \( f(x) \) function has a singularity at \( x=0 \):
it is difficult to define \( f(0) \), so one should exclude this point from
the function definition and work with a domain \( x\in [-1,-\epsilon]\cup
[\epsilon,1] \), with \( \epsilon \) chosen small.

<p>
The lesson learned from these examples is clear. You must investigate
the function to be visualized and make sure that you use an
appropriate set of \( x \) coordinates along the curve.  A relevant first
step is to double the number of \( x \) coordinates and check if this
changes the plot.  If not, you probably have an adequate set of \( x \)
coordinates.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 10:  Plot of the function \( \sin(1/x) \) with 10 points (left) and 1000 points (right). <a name="fig:plot:sin1overx"></a> </p></center>
<p><img src="fig-plot/sin1overx.png" align="bottom" width=400></p>
</center>

<h1 id="sec:plot:if:vectorize">More advanced vectorization of functions<a name="sec:plot:if:vectorize"></a></h1>

So far we have seen that vectorization of a Python function <code>f(x)</code>
implementing some mathematical function \( f(x) \) seems trivial: <code>f(x)</code>
works right away with an array argument <code>x</code> and, in that case, returns
an array where \( f \) is applied to each element in <code>x</code>.  When the
expression for \( f(x) \) is given in terms of a string and the
<code>StringFunction</code> tool is used to generate the corresponding Python
function <code>f(x)</code>, one extra step must be performed to vectorize the
Python function. This step is explained in the section <a href="#sec:plot:StringFunction:vectorize">Vectorization of StringFunction objects</a>.

<p>
The described vectorization works well as long as the expression
\( f(x) \) is a mathematical formula without any <code>if</code> test. As soon as we
have <code>if</code> tests (conditional mathematical expressions) the
vectorization becomes more challenging.  Some useful techniques are
explained through two examples in the sections <a href="#sec:vec:Heaviside">Vectorization of the Heaviside function</a> and
<a href="#sec:vec:hatfunc">Vectorization of a hat function</a>.  The described techniques are considered
advanced material and only necessary when the time spent on evaluating
a function at a very large set of points needs to be significantly
decreased.

<h2 id="sec:plot:StringFunction:vectorize">Vectorization of StringFunction objects<a name="sec:plot:StringFunction:vectorize"></a></h2>

The <code>StringFunction</code> object from <code>scitools.std</code> can
convert a formula, available as a string, to a callable Python
function (see the document <a href="http://tcse6.on.net/input" target="_self">User input and error handling</a> <a href="#Langtangen_TCSE6_input">[3]</a>).
However, the function cannot work with array arguments unless we explicitly tell
the <code>StringFunction</code>
object to do so. The recipe is very simple. Say <code>f</code>
is some
<code>StringFunction</code> object.
To allow array arguments we are required to call
<code>f.vectorize(globals())</code> once:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
x <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, <span style="color: #666666">30</span>)
<span style="color: #408080; font-style: italic"># f(x) will in general not work</span>

f<span style="color: #666666">.</span>vectorize(<span style="color: #008000">globals</span>())
values <span style="color: #666666">=</span> f(x)            <span style="color: #408080; font-style: italic"># f works with array arguments</span>
</pre></div>
<p>
It is important that you import everything from <code>numpy</code> (or
<code>scitools.std</code>) <em>before</em> calling <code>f.vectorize</code>, exactly as shown.

<p>
You may take the <code>f.vectorize</code> call as a magic recipe.  Still, some
readers want to know what problem <code>f.vectorize</code> solves. Inside the
<code>StringFunction</code> module we need to have access to mathematical
functions for expressions like <code>sin(x)*exp(x)</code> to be evaluated. These
mathematical functions are by default taken from the <code>math</code> module and
hence they do not work with array arguments.  If the user, in the main
program, has imported mathematical functions that work with array
arguments, these functions are registered in a dictionary returned
from <code>globals()</code>. By the <code>f.vectorize</code> call we supply the
<code>StringFunction</code> module with the user's global namespace so that the
evaluation of the string expression can make use of the mathematical
functions for arrays from the user's program.  Unless you use
<code>np.sin(x)*np.cos(x)</code> etc. in the string formulas, make sure you do a
<code>from numpy import *</code> so that the function names are defined without
any prefix.

<p>
Even after calling <code>f.vectorize(globals())</code>, a <code>StringFunction</code> object
may face problems with vectorization. One example is a piecewise
constant function as specified by a string expression <code>'1 if x > 2
else 0'</code>. The section <a href="#sec:vec:Heaviside">Vectorization of the Heaviside function</a> explains why <code>if</code> tests fail
for arrays and what the remedies are.

<h2 id="sec:vec:Heaviside">Vectorization of the Heaviside function<a name="sec:vec:Heaviside"></a></h2>

We consider the widely used Heaviside function defined by

$$
\begin{equation*}
H(x) = \left\lbrace\begin{array}{ll}
0, & x < 0\\ 
1, & x\geq 0
\end{array}\right.
\end{equation*}
$$

The most compact way if implementing this function is

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">H</span>(x):
    <span style="color: #008000; font-weight: bold">return</span> (<span style="color: #666666">0</span> <span style="color: #008000; font-weight: bold">if</span> x <span style="color: #666666">&lt;</span> <span style="color: #666666">0</span> <span style="color: #008000; font-weight: bold">else</span> <span style="color: #666666">1</span>)
</pre></div>
<p>
Trying to call <code>H(x)</code> with an array argument <code>x</code>
fails:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">H</span>(x): <span style="color: #008000; font-weight: bold">return</span> (<span style="color: #666666">0</span> <span style="color: #008000; font-weight: bold">if</span> x <span style="color: #666666">&lt;</span> <span style="color: #666666">0</span> <span style="color: #008000; font-weight: bold">else</span> <span style="color: #666666">1</span>)
<span style="color: #666666">...</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #666666">&gt;&gt;&gt;</span> x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">-10</span>, <span style="color: #666666">10</span>, <span style="color: #666666">5</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> x
array([<span style="color: #666666">-10.</span>,  <span style="color: #666666">-5.</span>,   <span style="color: #666666">0.</span>,   <span style="color: #666666">5.</span>,  <span style="color: #666666">10.</span>])
<span style="color: #666666">&gt;&gt;&gt;</span> H(x)
<span style="color: #666666">...</span>
<span style="color: #D2413A; font-weight: bold">ValueError</span>: The truth value of an array <span style="color: #008000; font-weight: bold">with</span> more than
one element <span style="color: #AA22FF; font-weight: bold">is</span> ambiguous<span style="color: #666666">.</span> Use a<span style="color: #666666">.</span>any() <span style="color: #AA22FF; font-weight: bold">or</span> a<span style="color: #666666">.</span>all()
</pre></div>
<p>
The problem is related to the test <code>x < 0</code>, which results
in an array of boolean values, while the <code>if</code> test needs a
single boolean value (essentially taking <code>bool(x < 0)</code>):

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> b <span style="color: #666666">=</span> x <span style="color: #666666">&lt;</span> <span style="color: #666666">0</span>
<span style="color: #666666">&gt;&gt;&gt;</span> b
array([ <span style="color: #008000">True</span>,  <span style="color: #008000">True</span>, <span style="color: #008000">False</span>, <span style="color: #008000">False</span>, <span style="color: #008000">False</span>], dtype<span style="color: #666666">=</span><span style="color: #008000">bool</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000">bool</span>(b)  <span style="color: #408080; font-style: italic"># evaluate b in a boolean context</span>
<span style="color: #666666">...</span>
<span style="color: #D2413A; font-weight: bold">ValueError</span>: The truth value of an array <span style="color: #008000; font-weight: bold">with</span> more than
one element <span style="color: #AA22FF; font-weight: bold">is</span> ambiguous<span style="color: #666666">.</span> Use a<span style="color: #666666">.</span>any() <span style="color: #AA22FF; font-weight: bold">or</span> a<span style="color: #666666">.</span>all()
<span style="color: #666666">&gt;&gt;&gt;</span> b<span style="color: #666666">.</span>any()  <span style="color: #408080; font-style: italic"># True if any element in b is True</span>
<span style="color: #008000">True</span>
<span style="color: #666666">&gt;&gt;&gt;</span> b<span style="color: #666666">.</span>all()  <span style="color: #408080; font-style: italic"># True if all elements in b are True</span>
<span style="color: #008000">False</span>
</pre></div>
<p>
The <code>any</code> and <code>all</code> calls do not help us since we
want to take actions element by element depending on whether
<code>x[i] < 0</code> or not.

<p>
There are four ways to find a remedy to our problems with the <code>if x <
0</code> test: (i) we can write an explicit loop for computing the elements,
(ii) we can use a tool for automatically vectorize <code>H(x)</code>, (iii) we
can mix boolean and floating-point calculations, or (iv) we can
manually vectorize the <code>H(x)</code> function.  All four methods will be
illustrated next.

<h3 id="___sec40">Loop <a name="___sec40"></a></h3>

The following function works well for arrays if we insert
a simple loop over the array elements (such that <code>H(x)</code> operates
on scalars only):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">H_loop</span>(x):
    r <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(<span style="color: #008000">len</span>(x))
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">xrange</span>(<span style="color: #008000">len</span>(x)):
        r[i] <span style="color: #666666">=</span> H(x[i])
    <span style="color: #008000; font-weight: bold">return</span> r

<span style="color: #408080; font-style: italic"># Example:</span>
x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">-5</span>, <span style="color: #666666">5</span>, <span style="color: #666666">6</span>)
y <span style="color: #666666">=</span> H_loop(x)
</pre></div>

<h3 id="___sec41">Automatic vectorization <a name="___sec41"></a></h3>

Numerical Python contains a method for automatically vectorizing
a Python function <code>H(x)</code> that works with scalars
(pure numbers) as <code>x</code> argument:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
H_vec <span style="color: #666666">=</span> np<span style="color: #666666">.</span>vectorize(H)
</pre></div>
<p>
The <code>H_vec(x)</code> function will now work with vector/array arguments
<code>x</code>. Unfortunately, such automatically vectorized functions runs
at a fairly slow speed compared to the implementations below
(see the end of the section <a href="#sec:vec:hatfunc">Vectorization of a hat function</a> for specific timings).

<h3 id="___sec42">Mixing boolean and floating-point calculations <a name="___sec42"></a></h3>

It appears that a very simple solution to vectorizing the <code>H(x)</code>
function is to implement it as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">H</span>(x):
    <span style="color: #008000; font-weight: bold">return</span> x <span style="color: #666666">&gt;=</span> <span style="color: #666666">0</span>
</pre></div>
<p>
The return value is now a <code>bool</code> object, not an <code>int</code> or <code>float</code> as we
would mathematically expect to be the proper type of the
result. However, the <code>bool</code> object works well in both scalar and
vectorized operations as long as we involve the returned <code>H(x)</code> in
some arithmetic expression. The <code>True</code> and <code>False</code> values are then
interpreted as 1 and 0. Here is a demonstration:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">-1</span>, <span style="color: #666666">1</span>, <span style="color: #666666">5</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> H(x)
array([<span style="color: #008000">False</span>, <span style="color: #008000">False</span>,  <span style="color: #008000">True</span>,  <span style="color: #008000">True</span>,  <span style="color: #008000">True</span>], dtype<span style="color: #666666">=</span><span style="color: #008000">bool</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #666666">1*</span>H(x)
array([<span style="color: #666666">0</span>, <span style="color: #666666">0</span>, <span style="color: #666666">1</span>, <span style="color: #666666">1</span>, <span style="color: #666666">1</span>])
<span style="color: #666666">&gt;&gt;&gt;</span> H(x) <span style="color: #666666">-</span> <span style="color: #666666">2</span>
array([<span style="color: #666666">-2</span>, <span style="color: #666666">-2</span>, <span style="color: #666666">-1</span>, <span style="color: #666666">-1</span>, <span style="color: #666666">-1</span>])
<span style="color: #666666">&gt;&gt;&gt;</span>
<span style="color: #666666">&gt;&gt;&gt;</span> x <span style="color: #666666">=</span> <span style="color: #666666">0.2</span>   <span style="color: #408080; font-style: italic"># test scalar argument</span>
<span style="color: #666666">&gt;&gt;&gt;</span> H(x)
<span style="color: #008000">True</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #666666">1*</span>H(x)
<span style="color: #666666">1</span>
<span style="color: #666666">&gt;&gt;&gt;</span> H(x) <span style="color: #666666">-</span> <span style="color: #666666">2</span>
<span style="color: #666666">-1</span>
</pre></div>
<p>
If returning a boolean value is considered undesirable, we can turn
the <code>bool</code> object into the proper type by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">H</span>(x):
    r <span style="color: #666666">=</span> x <span style="color: #666666">&gt;=</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">isinstance</span>(x, (<span style="color: #008000">int</span>,<span style="color: #008000">float</span>)):
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">int</span>(r)
    <span style="color: #008000; font-weight: bold">elif</span> <span style="color: #008000">isinstance</span>(x, np<span style="color: #666666">.</span>ndarray):
        <span style="color: #008000; font-weight: bold">return</span> np<span style="color: #666666">.</span>asarray(r, dtype<span style="color: #666666">=</span>np<span style="color: #666666">.</span>int)
</pre></div>

<h3 id="___sec43">Manual vectorization <a name="___sec43"></a></h3>

By manual vectorization we normally mean translating the algorithm
into a set of calls to functions in the <code>numpy</code> package such that no
loops are visible in the Python code. The last version of the <code>H(x)</code>
is a manual vectorization, but now we shall look at a more general
technique when the result is not necessarily 0 or 1.  In general,
manual vectorization is non-trivial and requires knowledge of and
experience with the underlying library for array computations.
Fortunately, there is a simple <code>numpy</code> recipe for turning functions of
the form

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>(x):
    <span style="color: #008000; font-weight: bold">if</span> condition:
        r <span style="color: #666666">=</span> <span style="color: #666666">&lt;</span>expression1<span style="color: #666666">&gt;</span>
    <span style="color: #008000; font-weight: bold">else</span>:
        r <span style="color: #666666">=</span> <span style="color: #666666">&lt;</span>expression2<span style="color: #666666">&gt;</span>
    <span style="color: #008000; font-weight: bold">return</span> r
</pre></div>
<p>
into vectorized form:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f_vectorized</span>(x):
    x1 <span style="color: #666666">=</span> <span style="color: #666666">&lt;</span>expression1<span style="color: #666666">&gt;</span>
    x2 <span style="color: #666666">=</span> <span style="color: #666666">&lt;</span>expression2<span style="color: #666666">&gt;</span>
    r <span style="color: #666666">=</span> np<span style="color: #666666">.</span>where(condition, x1, x2)
    <span style="color: #008000; font-weight: bold">return</span> r
</pre></div>
<p>
The <code>np.where</code> function returns an array of the same length as
<code>condition</code>, whose % (for one-dimensional arrays <code>x1</code> and <code>x2</code>)
element no. <code>i</code> equals <code>x1[i]</code> if <code>condition[i]</code> is <code>True</code>, and
<code>x2[i]</code> otherwise.  With Python loops we can express this principle as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">my_where</span>(condition, x1, x2):
    r <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(<span style="color: #008000">len</span>(condition))   <span style="color: #408080; font-style: italic"># result</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">xrange</span>(condition):
        r[i] <span style="color: #666666">=</span> x1[i] <span style="color: #008000; font-weight: bold">if</span> condition[i] <span style="color: #008000; font-weight: bold">else</span> x2[i]
    <span style="color: #008000; font-weight: bold">return</span> r
</pre></div>
<p>
The <code>x1</code> and <code>x2</code> variables can be pure numbers too in the call
to <code>np.where</code>.

<p>
In our case we can use the <code>np.where</code> function as follows:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">Hv</span>(x):
    <span style="color: #008000; font-weight: bold">return</span> np<span style="color: #666666">.</span>where(x <span style="color: #666666">&lt;</span> <span style="color: #666666">0</span>, <span style="color: #666666">0.0</span>, <span style="color: #666666">1.0</span>)
</pre></div>
<p>
Instead of using <code>np.where</code> we can apply <em>boolean indexing</em>.  The idea
is that an array <code>a</code> allows to be indexed by an array <code>b</code> of boolean
values: <code>a[b]</code>.  The result <code>a[b]</code> is a new array with all the
elements <code>a[i]</code> where <code>b[i]</code> is <code>True</code>:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> a
array([  <span style="color: #666666">0.</span> ,   <span style="color: #666666">2.5</span>,   <span style="color: #666666">5.</span> ,   <span style="color: #666666">7.5</span>,  <span style="color: #666666">10.</span> ])
<span style="color: #666666">&gt;&gt;&gt;</span> b <span style="color: #666666">=</span> a <span style="color: #666666">&gt;</span> <span style="color: #666666">5</span>
<span style="color: #666666">&gt;&gt;&gt;</span> b
array([<span style="color: #008000">False</span>, <span style="color: #008000">False</span>, <span style="color: #008000">False</span>,  <span style="color: #008000">True</span>,  <span style="color: #008000">True</span>], dtype<span style="color: #666666">=</span><span style="color: #008000">bool</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> a[b]
array([  <span style="color: #666666">7.5</span>,  <span style="color: #666666">10.</span> ])
</pre></div>
<p>
We can assign new values to the elements in <code>a</code> where <code>b</code> is <code>True</code>:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> a[b]
array([  <span style="color: #666666">7.5</span>,  <span style="color: #666666">10.</span> ])
<span style="color: #666666">&gt;&gt;&gt;</span> a[b] <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array([<span style="color: #666666">-10</span>, <span style="color: #666666">-20</span>], dtype<span style="color: #666666">=</span>np<span style="color: #666666">.</span>float)
<span style="color: #666666">&gt;&gt;&gt;</span> a
array([  <span style="color: #666666">0.</span> ,   <span style="color: #666666">2.5</span>,   <span style="color: #666666">5.</span> , <span style="color: #666666">-10.</span> , <span style="color: #666666">-20.</span> ])
<span style="color: #666666">&gt;&gt;&gt;</span> a[b] <span style="color: #666666">=</span> <span style="color: #666666">-4</span>
<span style="color: #666666">&gt;&gt;&gt;</span> a
array([ <span style="color: #666666">0.</span> ,  <span style="color: #666666">2.5</span>,  <span style="color: #666666">5.</span> , <span style="color: #666666">-4.</span> , <span style="color: #666666">-4.</span> ])
</pre></div>
<p>
To implement the Heaviside function, we start with an array of zeros
and then assign 1 to the elements where <code>x >= 0</code>:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">Hv</span>(x):
    r <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(<span style="color: #008000">len</span>(x), dtype<span style="color: #666666">=</span>np<span style="color: #666666">.</span>int)
    r[x <span style="color: #666666">&gt;=</span> <span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">1</span>
    <span style="color: #008000; font-weight: bold">return</span> r
</pre></div>

<h2 id="sec:vec:hatfunc">Vectorization of a hat function<a name="sec:vec:hatfunc"></a></h2>

We now turn the attention to the hat function \( N(x) \) defined by

$$
\begin{equation*}
N(x) = \left\lbrace\begin{array}{ll}
0, & x < 0\\ 
x, & 0\leq x < 1\\ 
2-x, & 1\leq x < 2\\ 
0, & x \geq 2
\end{array}\right.
\end{equation*}
$$

The corresponding Python implementation <code>N(x)</code> is

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">N</span>(x):
    <span style="color: #008000; font-weight: bold">if</span> x <span style="color: #666666">&lt;</span> <span style="color: #666666">0</span>:
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">0.0</span>
    <span style="color: #008000; font-weight: bold">elif</span> <span style="color: #666666">0</span> <span style="color: #666666">&lt;=</span> x <span style="color: #666666">&lt;</span> <span style="color: #666666">1</span>:
        <span style="color: #008000; font-weight: bold">return</span> x
    <span style="color: #008000; font-weight: bold">elif</span> <span style="color: #666666">1</span> <span style="color: #666666">&lt;=</span> x <span style="color: #666666">&lt;</span> <span style="color: #666666">2</span>:
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">2</span> <span style="color: #666666">-</span> x
    <span style="color: #008000; font-weight: bold">elif</span> x <span style="color: #666666">&gt;=</span> <span style="color: #666666">2</span>:
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">0.0</span>
</pre></div>
<p>
Unfortunately, this <code>N(x)</code> function does not work with array arguments
<code>x</code>, because the boolean expressions, like <code>x < 0</code>, are arrays and
they cannot yield a single <code>True</code> or <code>False</code> value for the <code>if</code> tests,
as explained in the section <a href="#sec:vec:Heaviside">Vectorization of the Heaviside function</a>.

<p>
The simplest remedy is to use <code>np.vectorize</code> from the section <a href="#sec:vec:Heaviside">Vectorization of the Heaviside function</a>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">N_vec <span style="color: #666666">=</span> np<span style="color: #666666">.</span>vectorize(N)
</pre></div>
<p>
It is then important that <code>N(x)</code> returns <code>float</code> and not <code>int</code> values,
otherwise the vectorized version will produce <code>int</code> values and hence
be incorrect.

<p>
A manual rewrite, yielding a faster vectorized function, is more
demanding than for the Heaviside function because we now have multiple
branches in the <code>if</code> test.  One sketch is to replace

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">if</span> condition1:
   r <span style="color: #666666">=</span> <span style="color: #666666">&lt;</span>expression1<span style="color: #666666">&gt;</span>
<span style="color: #008000; font-weight: bold">elif</span> condition2:
   r <span style="color: #666666">=</span> <span style="color: #666666">&lt;</span>expression2<span style="color: #666666">&gt;</span>
<span style="color: #008000; font-weight: bold">elif</span> condition3:
   r <span style="color: #666666">=</span> <span style="color: #666666">&lt;</span>expression3<span style="color: #666666">&gt;</span>
<span style="color: #008000; font-weight: bold">else</span>:
   r <span style="color: #666666">=</span> <span style="color: #666666">&lt;</span>expression4<span style="color: #666666">&gt;</span>
</pre></div>
<p>
by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">x1 <span style="color: #666666">=</span> <span style="color: #666666">&lt;</span>expression1<span style="color: #666666">&gt;</span>
x2 <span style="color: #666666">=</span> <span style="color: #666666">&lt;</span>expression2<span style="color: #666666">&gt;</span>
x3 <span style="color: #666666">=</span> <span style="color: #666666">&lt;</span>expression3<span style="color: #666666">&gt;</span>
x4 <span style="color: #666666">=</span> <span style="color: #666666">&lt;</span>expression4<span style="color: #666666">&gt;</span>
r <span style="color: #666666">=</span> np<span style="color: #666666">.</span>where(condition1, x1, x4)  <span style="color: #408080; font-style: italic"># initialize with &quot;else&quot; expr.</span>
r <span style="color: #666666">=</span> np<span style="color: #666666">.</span>where(condition2, x2, r)
r <span style="color: #666666">=</span> np<span style="color: #666666">.</span>where(condition3, x3, r)
</pre></div>
<p>
Alternatively, we can use boolean indexing. Assuming that
<code><expressionX></code> is some expression involving an array <code>x</code> and coded as
a Python function <code>fX(x)</code> (<code>X</code> is <code>1</code>, <code>2</code>, <code>3</code>, or <code>4</code>), we can write

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">r <span style="color: #666666">=</span> f4(x)
r[condition1] <span style="color: #666666">=</span> f1(x[condition1])
r[condition2] <span style="color: #666666">=</span> f2(x[condition2])
r[condition3] <span style="color: #666666">=</span> f2(x[condition3])
</pre></div>
<p>
Specifically, when the function for scalar arguments <code>x</code> reads

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">N</span>(x):
    <span style="color: #008000; font-weight: bold">if</span> x <span style="color: #666666">&lt;</span> <span style="color: #666666">0</span>:
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">0.0</span>
    <span style="color: #008000; font-weight: bold">elif</span> <span style="color: #666666">0</span> <span style="color: #666666">&lt;=</span> x <span style="color: #666666">&lt;</span> <span style="color: #666666">1</span>:
        <span style="color: #008000; font-weight: bold">return</span> x
    <span style="color: #008000; font-weight: bold">elif</span> <span style="color: #666666">1</span> <span style="color: #666666">&lt;=</span> x <span style="color: #666666">&lt;</span> <span style="color: #666666">2</span>:
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">2</span> <span style="color: #666666">-</span> x
    <span style="color: #008000; font-weight: bold">elif</span> x <span style="color: #666666">&gt;=</span> <span style="color: #666666">2</span>:
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">0.0</span>
</pre></div>
<p>
a vectorized attempt would be

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">Nv</span>(x):
    r <span style="color: #666666">=</span> np<span style="color: #666666">.</span>where(x <span style="color: #666666">&lt;</span> <span style="color: #666666">0</span>,      <span style="color: #666666">0.0</span>,  <span style="color: #666666">0.0</span>)
    r <span style="color: #666666">=</span> np<span style="color: #666666">.</span>where(<span style="color: #666666">0</span> <span style="color: #666666">&lt;=</span> x <span style="color: #666666">&lt;</span> <span style="color: #666666">1</span>, x,    r)
    r <span style="color: #666666">=</span> np<span style="color: #666666">.</span>where(<span style="color: #666666">1</span> <span style="color: #666666">&lt;=</span> x <span style="color: #666666">&lt;</span> <span style="color: #666666">2</span>, <span style="color: #666666">2-</span>x,  r)
    r <span style="color: #666666">=</span> np<span style="color: #666666">.</span>where(x <span style="color: #666666">&gt;=</span> <span style="color: #666666">2</span>,     <span style="color: #666666">0.0</span>,  r)
    <span style="color: #008000; font-weight: bold">return</span> r
</pre></div>
<p>
The first and last line are not strictly necessary as we could just
start with a zero vector (making the insertion of zeros for the first
and last condition a redundant operation).

<p>
However, any condition like <code>0 <= x < 1</code>, which is equivalent to <code>0 <=
x and x < 1</code>, does not work because the <code>and</code> operator does not work
with array arguments. Fortunately, there is a simple solution to this
problem: the function <code>logical_and</code> in <code>numpy</code>.  A working <code>Nv</code>
function must apply <code>logical_and</code> instead in each condition:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">Nv1</span>(x):
    condition1 <span style="color: #666666">=</span> x <span style="color: #666666">&lt;</span> <span style="color: #666666">0</span>
    condition2 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>logical_and(<span style="color: #666666">0</span> <span style="color: #666666">&lt;=</span> x, x <span style="color: #666666">&lt;</span> <span style="color: #666666">1</span>)
    condition3 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>logical_and(<span style="color: #666666">1</span> <span style="color: #666666">&lt;=</span> x, x <span style="color: #666666">&lt;</span> <span style="color: #666666">2</span>)
    condition4 <span style="color: #666666">=</span> x <span style="color: #666666">&gt;=</span> <span style="color: #666666">2</span>

    r <span style="color: #666666">=</span> np<span style="color: #666666">.</span>where(condition1, <span style="color: #666666">0.0</span>, <span style="color: #666666">0.0</span>)
    r <span style="color: #666666">=</span> np<span style="color: #666666">.</span>where(condition2, x,   r)
    r <span style="color: #666666">=</span> np<span style="color: #666666">.</span>where(condition3, <span style="color: #666666">2-</span>x, r)
    r <span style="color: #666666">=</span> np<span style="color: #666666">.</span>where(condition4, <span style="color: #666666">0.0</span>, r)
    <span style="color: #008000; font-weight: bold">return</span> r
</pre></div>
<p>
With boolean indexing we get the alternative form

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">Nv2</span>(x):
    condition1 <span style="color: #666666">=</span> x <span style="color: #666666">&lt;</span> <span style="color: #666666">0</span>
    condition2 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>logical_and(<span style="color: #666666">0</span> <span style="color: #666666">&lt;=</span> x, x <span style="color: #666666">&lt;</span> <span style="color: #666666">1</span>)
    condition3 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>logical_and(<span style="color: #666666">1</span> <span style="color: #666666">&lt;=</span> x, x <span style="color: #666666">&lt;</span> <span style="color: #666666">2</span>)
    condition4 <span style="color: #666666">=</span> x <span style="color: #666666">&gt;=</span> <span style="color: #666666">2</span>

    r <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(<span style="color: #008000">len</span>(x))
    r[condition1] <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>
    r[condition2] <span style="color: #666666">=</span> x[condition2]
    r[condition3] <span style="color: #666666">=</span> <span style="color: #666666">2-</span>x[condition3]
    r[condition4] <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>
    <span style="color: #008000; font-weight: bold">return</span> r
</pre></div>
<p>
Again, the first and last assignment to <code>r</code> can be omitted in this
special case where we start with a zero vector.

<p>
The file <a href="http://tinyurl.com/pwyasaa/plot/hat.py" target="_self"><tt>hat.py</tt></a>
implements four vectorized versions of the <code>N(x)</code>
function: <code>N_loop</code>, which is a plain loop calling up <code>N(x)</code> for each
<code>x[i]</code> element in the array <code>x</code>; <code>N_vec</code>, which is the result of
automatic vectorization via <code>np.vectorize</code>; the <code>Nv1</code> function shown
above, which uses the <code>np.where</code> constructions; and the <code>Nv2</code> function,
which uses boolean indexing. With a length of <code>x</code> of 1,000,000, the
results on my computer (MacBook Air 11'', 2 1.6GHz Intel CPU, running
Ubuntu 12.04 in a VMWare virtual machine) became 4.8 s for <code>N_loop</code>, 1
s <code>N_vec</code>, 0.3 s for <code>Nv1</code>, and 0.08 s for <code>Nv2</code>. Boolean indexing is
clearly the fastest method.

<h1 id="sec:plot:numpy:more">More on numerical Python arrays<a name="sec:plot:numpy:more"></a></h1>

This section lists some more advanced but useful operations with
Numerical Python arrays.

<h2 id="___sec46">Copying arrays <a name="___sec46"></a></h2>

Let <code>x</code> be an array. The statement <code>a = x</code> makes <code>a</code> refer to the same
array as <code>x</code>. Changing <code>a</code> will then also affect <code>x</code>:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #666666">&gt;&gt;&gt;</span> x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array([<span style="color: #666666">1</span>, <span style="color: #666666">2</span>, <span style="color: #666666">3.5</span>])
<span style="color: #666666">&gt;&gt;&gt;</span> a <span style="color: #666666">=</span> x
<span style="color: #666666">&gt;&gt;&gt;</span> a[<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> <span style="color: #666666">3</span>  <span style="color: #408080; font-style: italic"># this changes x[-1] too!</span>
<span style="color: #666666">&gt;&gt;&gt;</span> x
array([ <span style="color: #666666">1.</span>,  <span style="color: #666666">2.</span>,  <span style="color: #666666">3.</span>])
</pre></div>
<p>
Changing <code>a</code> without changing <code>x</code> requires <code>a</code> to be a copy of <code>x</code>:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> a <span style="color: #666666">=</span> x<span style="color: #666666">.</span>copy()
<span style="color: #666666">&gt;&gt;&gt;</span> a[<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> <span style="color: #666666">9</span>
<span style="color: #666666">&gt;&gt;&gt;</span> a
array([ <span style="color: #666666">1.</span>,  <span style="color: #666666">2.</span>,  <span style="color: #666666">9.</span>])
<span style="color: #666666">&gt;&gt;&gt;</span> x
array([ <span style="color: #666666">1.</span>,  <span style="color: #666666">2.</span>,  <span style="color: #666666">3.</span>])
</pre></div>

<h2 id="___sec47">In-place arithmetics <a name="___sec47"></a></h2>

Let <code>a</code> and <code>b</code> be two arrays of the same shape.  The expression <code>a +=
b</code> means <code>a = a + b</code>, but this is not the complete story. In the
statement <code>a = a + b</code>, the sum <code>a + b</code> is first computed, yielding a
new array, and then the name <code>a</code> is bound to this new array. The old
array <code>a</code> is lost unless there are other names assigned to this array.
In the statement <code>a += b</code>, elements of <code>b</code> are added directly into the
elements of <code>a</code> (in memory). There is no hidden intermediate array as
in <code>a = a + b</code>.  This implies that <code>a += b</code> is more efficient than <code>a
= a + b</code> since Python avoids making an extra array.  We say that the
operators <code>+=</code>, <code>*=</code>, and so on, perform <em>in-place</em> arithmetics in
arrays.

<p>
Consider the compound array expression

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">a <span style="color: #666666">=</span> (<span style="color: #666666">3*</span>x<span style="color: #666666">**4</span> <span style="color: #666666">+</span> <span style="color: #666666">2*</span>x <span style="color: #666666">+</span> <span style="color: #666666">4</span>)<span style="color: #666666">/</span>(x <span style="color: #666666">+</span> <span style="color: #666666">1</span>)
</pre></div>
<p>
The computation actually goes as follows with seven hidden arrays for
storing intermediate results:

<ul>
  <li> <code>r1 = x**4</code></li>
  <li> <code>r2 = 3*r1</code></li>
  <li> <code>r3 = 2*x</code></li>
  <li> <code>r4 = r2 + r3</code></li>
  <li> <code>r5 = r4 + 4</code></li>
  <li> <code>r6 = x + 1</code></li>
  <li> <code>r7 = r5/r6</code></li>
  <li> <code>a = r7</code></li>
</ul>

With in-place arithmetics we can get away with creating three new
arrays, at a cost of a significantly less readable code:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">a <span style="color: #666666">=</span> x<span style="color: #666666">.</span>copy()
a <span style="color: #666666">**=</span> <span style="color: #666666">4</span>
a <span style="color: #666666">*=</span> <span style="color: #666666">3</span>
a <span style="color: #666666">+=</span> <span style="color: #666666">2*</span>x
a <span style="color: #666666">+=</span> <span style="color: #666666">4</span>
a <span style="color: #666666">/=</span> x <span style="color: #666666">+</span> <span style="color: #666666">1</span>
</pre></div>
<p>
The three extra arrays in this series of statement arise from copying
<code>x</code>, and computing the right-hand sides <code>2*x</code> and <code>x+1</code>.

<p>
Quite often in computational science and engineering, a huge number of
arithmetics is performed on very large arrays, and then saving memory
and array allocation time by doing in-place arithmetics is important.

<p>
The mix of assignment and in-place arithmetics makes it easy to make
unintended changes of more than one array. For example, this code
changes <code>x</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">a <span style="color: #666666">=</span> x
a <span style="color: #666666">+=</span> y
</pre></div>
<p>
since <code>a</code> refers to the same array as <code>x</code> and the change of
<code>a</code> is done in-place.

<h2 id="___sec48">Allocating arrays <a name="___sec48"></a></h2>

We have already seen that the <code>np.zeros</code> function is handy for making
a new array <code>a</code> of a given size. Very often the size and the type of
array elements have to match another existing array <code>x</code>. We can then
either copy the original array, e.g.,

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">a <span style="color: #666666">=</span> x<span style="color: #666666">.</span>copy()
</pre></div>
<p>
and fill elements in <code>a</code> with the right new values, or we can
say

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">a <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(x<span style="color: #666666">.</span>shape, x<span style="color: #666666">.</span>dtype)
</pre></div>
<p>
The attribute <code>x.dtype</code> holds the array element type (<code>dtype</code> for
data type), and as mentioned before, <code>x.shape</code> is a tuple with
the array dimensions.

<p>
Sometimes we may want to ensure that an object is an array, and if
not, turn it into an array. The <code>np.asarray</code> function is useful in
such cases:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">a <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(a)
</pre></div>
<p>
Nothing is copied if <code>a</code> already is an array, but if <code>a</code> is a list
or tuple, a new array with a copy of the data is created.

<h2 id="sec:plot:generalized:index">Generalized indexing<a name="sec:plot:generalized:index"></a></h2>

The section <a href="#sec:plot:array:basics">Basics of numerical Python arrays</a> shows how slices can be used to
extract and manipulate subarrays.  The slice <code>f:t:i</code> corresponds to
the index set <code>f, f+i, f+2*i, ...</code> up to, but not including, <code>t</code>.
Such an index set can be given explicitly too: <code>a[range(f,t,i)]</code>.
That is, the integer list from <code>range</code> can be used as a set of
indices.  In fact, any integer list or integer array can be used as
index:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> a <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">1</span>, <span style="color: #666666">8</span>, <span style="color: #666666">8</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> a
array([ <span style="color: #666666">1.</span>,  <span style="color: #666666">2.</span>,  <span style="color: #666666">3.</span>,  <span style="color: #666666">4.</span>,  <span style="color: #666666">5.</span>,  <span style="color: #666666">6.</span>,  <span style="color: #666666">7.</span>,  <span style="color: #666666">8.</span>])
<span style="color: #666666">&gt;&gt;&gt;</span> a[[<span style="color: #666666">1</span>,<span style="color: #666666">6</span>,<span style="color: #666666">7</span>]] <span style="color: #666666">=</span> <span style="color: #666666">10</span>
<span style="color: #666666">&gt;&gt;&gt;</span> a
array([  <span style="color: #666666">1.</span>,  <span style="color: #666666">10.</span>,   <span style="color: #666666">3.</span>,   <span style="color: #666666">4.</span>,   <span style="color: #666666">5.</span>,   <span style="color: #666666">6.</span>,  <span style="color: #666666">10.</span>,  <span style="color: #666666">10.</span>])
<span style="color: #666666">&gt;&gt;&gt;</span> a[<span style="color: #008000">range</span>(<span style="color: #666666">2</span>,<span style="color: #666666">8</span>,<span style="color: #666666">3</span>)] <span style="color: #666666">=</span> <span style="color: #666666">-2</span>   <span style="color: #408080; font-style: italic"># same as a[2:8:3] = -2</span>
<span style="color: #666666">&gt;&gt;&gt;</span> a
array([  <span style="color: #666666">1.</span>,  <span style="color: #666666">10.</span>,  <span style="color: #666666">-2.</span>,   <span style="color: #666666">4.</span>,   <span style="color: #666666">5.</span>,  <span style="color: #666666">-2.</span>,  <span style="color: #666666">10.</span>,  <span style="color: #666666">10.</span>])
</pre></div>
<p>
We can also use boolean arrays to generate an index set. The indices
in the set will correspond to the indices for which the boolean array
has <code>True</code> values. This functionality allows expressions like
<code>a[x<m]</code>. Here are two examples, continuing the previous interactive
session:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> a[a <span style="color: #666666">&lt;</span> <span style="color: #666666">0</span>]            <span style="color: #408080; font-style: italic"># pick out the negative elements of a</span>
array([<span style="color: #666666">-2.</span>, <span style="color: #666666">-2.</span>])
<span style="color: #666666">&gt;&gt;&gt;</span> a[a <span style="color: #666666">&lt;</span> <span style="color: #666666">0</span>] <span style="color: #666666">=</span> a<span style="color: #666666">.</span>max()
<span style="color: #666666">&gt;&gt;&gt;</span> a
array([  <span style="color: #666666">1.</span>,  <span style="color: #666666">10.</span>,  <span style="color: #666666">10.</span>,   <span style="color: #666666">4.</span>,   <span style="color: #666666">5.</span>,  <span style="color: #666666">10.</span>,  <span style="color: #666666">10.</span>,  <span style="color: #666666">10.</span>])
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #408080; font-style: italic"># Replace elements where a is 10 by the first</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #408080; font-style: italic"># elements from another array/list:</span>
<span style="color: #666666">&gt;&gt;&gt;</span> a[a <span style="color: #666666">==</span> <span style="color: #666666">10</span>] <span style="color: #666666">=</span> [<span style="color: #666666">10</span>, <span style="color: #666666">20</span>, <span style="color: #666666">30</span>, <span style="color: #666666">40</span>, <span style="color: #666666">50</span>, <span style="color: #666666">60</span>, <span style="color: #666666">70</span>]
<span style="color: #666666">&gt;&gt;&gt;</span> a
array([  <span style="color: #666666">1.</span>,  <span style="color: #666666">10.</span>,  <span style="color: #666666">20.</span>,   <span style="color: #666666">4.</span>,   <span style="color: #666666">5.</span>,  <span style="color: #666666">30.</span>,  <span style="color: #666666">40.</span>,  <span style="color: #666666">50.</span>])
</pre></div>
<p>
Generalized indexing using integer arrays or lists is important for
vectorized initialization of array elements.  The syntax for
generalized indexing of higher-dimensional arrays is slightly
different, see the section <a href="#sec:plot:2D:arrays">Two-dimensional numerical Python arrays</a>.

<h2 id="___sec50">Testing for the array type <a name="___sec50"></a></h2>

Inside an interactive Python shell you can easily check an object's type
using the <code>type</code>
function (see the section ref{sec:formulas:typeconversion}).
In case of a Numerical Python array, the type name is <code>ndarray</code>:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> a <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">-1</span>, <span style="color: #666666">1</span>, <span style="color: #666666">3</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> a
array([<span style="color: #666666">-1.</span>,  <span style="color: #666666">0.</span>,  <span style="color: #666666">1.</span>])
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000">type</span>(a)
<span style="color: #666666">&lt;</span><span style="color: #008000">type</span> <span style="color: #BA2121">&#39;numpy.ndarray&#39;</span><span style="color: #666666">&gt;</span>
</pre></div>
<p>
Sometimes you need to test if a variable is an <code>ndarray</code> or a <code>float</code>
or <code>int</code>. The <code>isinstance</code> function can be used this purpose:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000">isinstance</span>(a, np<span style="color: #666666">.</span>ndarray)
<span style="color: #008000">True</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000">isinstance</span>(a, (<span style="color: #008000">float</span>,<span style="color: #008000">int</span>))  <span style="color: #408080; font-style: italic"># float or int?</span>
<span style="color: #008000">False</span>
</pre></div>
<p>
A typical use of <code>isinstance</code> and <code>type</code> to check on object's type is
shown next.

<h3 id="___sec51">Example: Vectorizing a constant function <a name="___sec51"></a></h3>

Suppose we have a constant function,

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>(x):
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">2</span>
</pre></div>
<p>
This function accepts an array argument <code>x</code>, but will return a <code>float</code>
while a vectorized version of the function should return an array of
the same shape as <code>x</code> where each element has the value 2.  The
vectorized version can be realized as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fv</span>(x):
    <span style="color: #008000; font-weight: bold">return</span> np<span style="color: #666666">.</span>zeros(x<span style="color: #666666">.</span>shape, x<span style="color: #666666">.</span>dtype) <span style="color: #666666">+</span> <span style="color: #666666">2</span>
</pre></div>
<p>
The optimal vectorized function would be one that works for both
a scalar and an array argument. We must then test on the argument type:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>(x):
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">isinstance</span>(x, (<span style="color: #008000">float</span>, <span style="color: #008000">int</span>)):
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">2</span>
    <span style="color: #008000; font-weight: bold">elif</span> <span style="color: #008000">isinstance</span>(x, np<span style="color: #666666">.</span>ndarray):
        <span style="color: #008000; font-weight: bold">return</span> np<span style="color: #666666">.</span>zeros(x<span style="color: #666666">.</span>shape, x<span style="color: #666666">.</span>dtype) <span style="color: #666666">+</span> <span style="color: #666666">2</span>
    <span style="color: #008000; font-weight: bold">else</span>:
        <span style="color: #008000; font-weight: bold">raise</span> <span style="color: #D2413A; font-weight: bold">TypeError</span>\ 
        (<span style="color: #BA2121">&#39;x must be int, float or ndarray, not </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> <span style="color: #008000">type</span>(x))
</pre></div>

<h2 id="___sec52">Compact syntax for array generation <a name="___sec52"></a></h2>

There is a special compact syntax <code>r_[f:t:s]</code> for the <code>linspace</code>
function:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> a <span style="color: #666666">=</span> r_[<span style="color: #666666">-5</span>:<span style="color: #666666">5</span>:<span style="color: #666666">11j</span>]  <span style="color: #408080; font-style: italic"># same as linspace(-5, 5, 11)</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">print</span> a
[<span style="color: #666666">-5.</span> <span style="color: #666666">-4.</span> <span style="color: #666666">-3.</span> <span style="color: #666666">-2.</span> <span style="color: #666666">-1.</span>  <span style="color: #666666">0.</span>  <span style="color: #666666">1.</span>  <span style="color: #666666">2.</span>  <span style="color: #666666">3.</span>  <span style="color: #666666">4.</span>  <span style="color: #666666">5.</span>]
</pre></div>
<p>
Here, <code>11j</code> means 11 coordinates (between -5 and 5, including the
upper limit 5). That is, the number of elements in the array is given
with the imaginary number syntax.

<h2 id="___sec53">Shape manipulation <a name="___sec53"></a></h2>

The <code>shape</code> attribute in array objects holds the shape, i.e., the size
of each dimension. A function <code>size</code> returns the total number of
elements in an array.  Here are a few equivalent ways of changing the
shape of an array:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> a <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">-1</span>, <span style="color: #666666">1</span>, <span style="color: #666666">6</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">print</span> a
[<span style="color: #666666">-1.</span>  <span style="color: #666666">-0.6</span> <span style="color: #666666">-0.2</span>  <span style="color: #666666">0.2</span>  <span style="color: #666666">0.6</span>  <span style="color: #666666">1.</span> ]
<span style="color: #666666">&gt;&gt;&gt;</span> a<span style="color: #666666">.</span>shape
(<span style="color: #666666">6</span>,)
<span style="color: #666666">&gt;&gt;&gt;</span> a<span style="color: #666666">.</span>size
<span style="color: #666666">6</span>
<span style="color: #666666">&gt;&gt;&gt;</span> a<span style="color: #666666">.</span>shape <span style="color: #666666">=</span> (<span style="color: #666666">2</span>, <span style="color: #666666">3</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> a <span style="color: #666666">=</span> a<span style="color: #666666">.</span>reshape(<span style="color: #666666">2</span>, <span style="color: #666666">3</span>)    <span style="color: #408080; font-style: italic"># alternative</span>
<span style="color: #666666">&gt;&gt;&gt;</span> a<span style="color: #666666">.</span>shape
(<span style="color: #666666">2</span>, <span style="color: #666666">3</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">print</span> a
[[<span style="color: #666666">-1.</span>  <span style="color: #666666">-0.6</span> <span style="color: #666666">-0.2</span>]
 [ <span style="color: #666666">0.2</span>  <span style="color: #666666">0.6</span>  <span style="color: #666666">1.</span> ]]
<span style="color: #666666">&gt;&gt;&gt;</span> a<span style="color: #666666">.</span>size                 <span style="color: #408080; font-style: italic"># total no of elements</span>
<span style="color: #666666">6</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000">len</span>(a)                 <span style="color: #408080; font-style: italic"># no of rows</span>
<span style="color: #666666">2</span>
<span style="color: #666666">&gt;&gt;&gt;</span> a<span style="color: #666666">.</span>shape <span style="color: #666666">=</span> (a<span style="color: #666666">.</span>size,)    <span style="color: #408080; font-style: italic"># reset shape</span>
</pre></div>
<p>
Note that <code>len(a)</code> always returns the length of the first
dimension of an array.

<h1 id="sec:plot:2Darrays">Higher-dimensional arrays<a name="sec:plot:2Darrays"></a></h1>

<h2 id="___sec55">Matrices and arrays <a name="___sec55"></a></h2>

Vectors appeared when mathematicians needed to calculate with a list
of numbers.  When they needed a table (or a list of lists in Python
terminology), they invented the concept of <em>matrix</em> (singular) and
<em>matrices</em> (plural).  A table of numbers has the numbers ordered into
rows and columns. One example is

$$
\begin{equation*}
\left\lbrack\begin{array}{cccc}
0 & 12 & -1 & 5\\ 
-1 & -1 & -1 & 0\\ 
11 & 5 & 5 & -2
\end{array}\right\rbrack
\end{equation*}
$$

This table with three rows and four columns is called a \( 3\times4 \)
matrix (mathematicians don't like this sentence, but it suffices for
our purposes).  If the symbol \( A \) is associated with this matrix,
\( A_{i,j} \) denotes the number in row number \( i \) and column number \( j \).
Counting rows and columns from 0, we have, for instance, \( A_{0,0}=0 \)
and \( A_{2,3}=-2 \). We can write a general \( m\times n \) matrix \( A \) as

$$
\begin{equation*}
\left\lbrack\begin{array}{ccc}
A_{0,0} & \cdots &  A_{0,n-1}\\ 
\vdots & \ddots &  \vdots\\ 
A_{m-1,0} & \cdots & A_{m-1,n-1}
\end{array}\right\rbrack
\end{equation*}
$$

Matrices can be added and subtracted. They can also be multiplied by a
scalar (a number), and there is a concept of length or size.  The
formulas are quite similar to those presented for vectors, but the
exact form is not important here.

<p>
We can generalize the concept of table and matrix to <em>array</em>, which
holds quantities with in general \( d \) indices.  Equivalently we say
that the array has rank \( d \).  For \( d=3 \), an array \( A \) has elements
with three indices: \( A_{p,q,r} \).  If \( p \) goes from 0 to \( n_p-1 \), \( q \)
from 0 to \( n_q-1 \), and \( r \) from 0 to \( n_r-1 \), the \( A \) array has
\( n_p\times n_q\times n_r \) elements in total.  We may speak about the
<em>shape</em> of the array, which is a \( d \)-vector holding the number of
elements in each &quot;array direction&quot;, i.e., the number of elements for
each index. For the mentioned \( A \) array, the shape is \( (n_p,n_q,n_r) \).

<p>
The special case of \( d=1 \) is a vector, and \( d=2 \) corresponds to a
matrix.  When we program we may skip thinking about vectors and
matrices (if you are not so familiar with these concepts from a
mathematical point of view) and instead just work with arrays. The
number of indices corresponds to what is convenient in the programming
problem we try to solve.

<h2 id="sec:plot:2D:arrays">Two-dimensional numerical Python arrays<a name="sec:plot:2D:arrays"></a></h2>

Consider a nested list <code>table</code> of two-pairs <code>[C, F]</code>
(see the section ref{sec:basic:nestedlists})
constructed by

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> Cdegrees <span style="color: #666666">=</span> [<span style="color: #666666">-30</span> <span style="color: #666666">+</span> i<span style="color: #666666">*10</span> <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">3</span>)]
<span style="color: #666666">&gt;&gt;&gt;</span> Fdegrees <span style="color: #666666">=</span> [<span style="color: #666666">9./5*</span>C <span style="color: #666666">+</span> <span style="color: #666666">32</span> <span style="color: #008000; font-weight: bold">for</span> C <span style="color: #AA22FF; font-weight: bold">in</span> Cdegrees]
<span style="color: #666666">&gt;&gt;&gt;</span> table <span style="color: #666666">=</span> [[C, F] <span style="color: #008000; font-weight: bold">for</span> C, F <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">zip</span>(Cdegrees, Fdegrees)]
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">print</span> table
[[<span style="color: #666666">-30</span>, <span style="color: #666666">-22.0</span>], [<span style="color: #666666">-20</span>, <span style="color: #666666">-4.0</span>], [<span style="color: #666666">-10</span>, <span style="color: #666666">14.0</span>]]
</pre></div>
<p>
This nested list can be turned into an array,

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> table2 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array(table)
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">print</span> table2
[[<span style="color: #666666">-30.</span> <span style="color: #666666">-22.</span>]
 [<span style="color: #666666">-20.</span>  <span style="color: #666666">-4.</span>]
 [<span style="color: #666666">-10.</span>  <span style="color: #666666">14.</span>]]
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000">type</span>(table2)
<span style="color: #666666">&lt;</span><span style="color: #008000">type</span> <span style="color: #BA2121">&#39;numpy.ndarray&#39;</span><span style="color: #666666">&gt;</span>
</pre></div>
<p>
We say that <code>table2</code> is a <em>two-dimensional</em> array, or an array
of rank 2.

<p>
The <code>table</code> list and the <code>table2</code> array are stored very differently in
memory. The <code>table</code> variable refers to a list object containing three
elements.  Each of these elements is a reference to a separate list
object with two elements, where each element refers to a separate
<code>float</code> object.  The <code>table2</code> variable is a reference to a single
array object that again refers to a consecutive sequence of bytes in
memory where the six floating-point numbers are stored. The data
associated with <code>table2</code> are found in one chunk in the computer's
memory, while the data associated with <code>table</code> are scattered around in
memory. On today's machines, it is much more expensive to find data in
memory than to compute with the data. Arrays make the data fetching
more efficient, and this is major reason for using arrays.  However,
this efficiency gain is only present for very large arrays, not for a
\( 3\times 2 \) array.

<p>
Indexing a nested list is done in two steps, first the outer list is
indexed, giving access to an element that is another list, and then
this latter list is indexed:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> table[<span style="color: #666666">1</span>][<span style="color: #666666">0</span>]     <span style="color: #408080; font-style: italic"># table[1] is [-20,4], whose index 0 holds -20</span>
<span style="color: #666666">-20</span>
</pre></div>
<p>
This syntax works for two-dimensional arrays too:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> table2[<span style="color: #666666">1</span>][<span style="color: #666666">0</span>]
<span style="color: #666666">-20.0</span>
</pre></div>
<p>
but there is another syntax that is more common for arrays:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> table2[<span style="color: #666666">1</span>,<span style="color: #666666">0</span>]
<span style="color: #666666">-20.0</span>
</pre></div>
<p>
A two-dimensional array reflects a table and has a certain number of
rows and columns. We refer to rows as the <em>first dimension</em> of the
array and columns as the <em>second dimension</em>. These two dimensions are
available as <code>table2.shape</code>:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> table2<span style="color: #666666">.</span>shape
(<span style="color: #666666">3</span>, <span style="color: #666666">2</span>)
</pre></div>
<p>
Here, 3 is the number of rows and 2 is the number of columns.

<p>
A loop over all the elements in a two-dimensional array is usually
expressed as two <em>nested</em> <code>for</code> loops, one for each index:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(table2<span style="color: #666666">.</span>shape[<span style="color: #666666">0</span>]):
<span style="color: #666666">...</span>     <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(table2<span style="color: #666666">.</span>shape[<span style="color: #666666">1</span>]):
<span style="color: #666666">...</span>         <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;table2[</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">,</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">] = </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (i, j, table2[i,j])
<span style="color: #666666">...</span>
table2[<span style="color: #666666">0</span>,<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">-30</span>
table2[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>] <span style="color: #666666">=</span> <span style="color: #666666">-22</span>
table2[<span style="color: #666666">1</span>,<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">-20</span>
table2[<span style="color: #666666">1</span>,<span style="color: #666666">1</span>] <span style="color: #666666">=</span> <span style="color: #666666">-4</span>
table2[<span style="color: #666666">2</span>,<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">-10</span>
table2[<span style="color: #666666">2</span>,<span style="color: #666666">1</span>] <span style="color: #666666">=</span> <span style="color: #666666">14</span>
</pre></div>
<p>
An alternative (but less efficient) way of visiting each element in an
array with any number of dimensions makes use of a single <code>for</code> loop:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">for</span> index_tuple, value <span style="color: #AA22FF; font-weight: bold">in</span> np<span style="color: #666666">.</span>ndenumerate(table2):
<span style="color: #666666">...</span>     <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;index </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> has value </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> \ 
<span style="color: #666666">...</span>           (index_tuple, table2[index_tuple])
<span style="color: #666666">...</span>
index (<span style="color: #666666">0</span>,<span style="color: #666666">0</span>) has value <span style="color: #666666">-30</span>
index (<span style="color: #666666">0</span>,<span style="color: #666666">1</span>) has value <span style="color: #666666">-22</span>
index (<span style="color: #666666">1</span>,<span style="color: #666666">0</span>) has value <span style="color: #666666">-20</span>
index (<span style="color: #666666">1</span>,<span style="color: #666666">1</span>) has value <span style="color: #666666">-4</span>
index (<span style="color: #666666">2</span>,<span style="color: #666666">0</span>) has value <span style="color: #666666">-10</span>
index (<span style="color: #666666">2</span>,<span style="color: #666666">1</span>) has value <span style="color: #666666">14</span>
</pre></div>
<p>
In the same way as we can extract sublists of lists, we can extract
subarrays of arrays using slices.

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">table2[<span style="color: #666666">0</span>:table2<span style="color: #666666">.</span>shape[<span style="color: #666666">0</span>], <span style="color: #666666">1</span>]  <span style="color: #408080; font-style: italic"># 2nd column (index 1)</span>
array([<span style="color: #666666">-22.</span>,  <span style="color: #666666">-4.</span>,  <span style="color: #666666">14.</span>])

<span style="color: #666666">&gt;&gt;&gt;</span> table2[<span style="color: #666666">0</span>:, <span style="color: #666666">1</span>]             <span style="color: #408080; font-style: italic"># same</span>
array([<span style="color: #666666">-22.</span>,  <span style="color: #666666">-4.</span>,  <span style="color: #666666">14.</span>])

<span style="color: #666666">&gt;&gt;&gt;</span> table2[:, <span style="color: #666666">1</span>]              <span style="color: #408080; font-style: italic"># same</span>
array([<span style="color: #666666">-22.</span>,  <span style="color: #666666">-4.</span>,  <span style="color: #666666">14.</span>])
</pre></div>
<p>
To illustrate array slicing further, we create a bigger array:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> t <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">1</span>, <span style="color: #666666">30</span>, <span style="color: #666666">30</span>)<span style="color: #666666">.</span>reshape(<span style="color: #666666">5</span>, <span style="color: #666666">6</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> t
array([[  <span style="color: #666666">1.</span>,   <span style="color: #666666">2.</span>,   <span style="color: #666666">3.</span>,   <span style="color: #666666">4.</span>,   <span style="color: #666666">5.</span>,   <span style="color: #666666">6.</span>],
       [  <span style="color: #666666">7.</span>,   <span style="color: #666666">8.</span>,   <span style="color: #666666">9.</span>,  <span style="color: #666666">10.</span>,  <span style="color: #666666">11.</span>,  <span style="color: #666666">12.</span>],
       [ <span style="color: #666666">13.</span>,  <span style="color: #666666">14.</span>,  <span style="color: #666666">15.</span>,  <span style="color: #666666">16.</span>,  <span style="color: #666666">17.</span>,  <span style="color: #666666">18.</span>],
       [ <span style="color: #666666">19.</span>,  <span style="color: #666666">20.</span>,  <span style="color: #666666">21.</span>,  <span style="color: #666666">22.</span>,  <span style="color: #666666">23.</span>,  <span style="color: #666666">24.</span>],
       [ <span style="color: #666666">25.</span>,  <span style="color: #666666">26.</span>,  <span style="color: #666666">27.</span>,  <span style="color: #666666">28.</span>,  <span style="color: #666666">29.</span>,  <span style="color: #666666">30.</span>]])

<span style="color: #666666">&gt;&gt;&gt;</span> t[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>:<span style="color: #666666">2</span>, <span style="color: #666666">2</span>:]
array([[  <span style="color: #666666">9.</span>,  <span style="color: #666666">10.</span>,  <span style="color: #666666">11.</span>,  <span style="color: #666666">12.</span>],
       [ <span style="color: #666666">21.</span>,  <span style="color: #666666">22.</span>,  <span style="color: #666666">23.</span>,  <span style="color: #666666">24.</span>]])
</pre></div>
<p>
To understand the slice, look at the original <code>t</code> array and pick out
the two rows corresponding to the first slice <code>1:-1:2</code>,

<p>

<!-- code=text (!bc ccq) typeset with pygments style "default" -->
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">       [  7.,   8.,   9.,  10.,  11.,  12.]
       [ 19.,  20.,  21.,  22.,  23.,  24.]
</pre></div>
</blockquote><p>
Among the rows, pick the columns corresponding to the second slice <code>2:</code>,

<p>

<!-- code=text (!bc ccq) typeset with pygments style "default" -->
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">       [  9.,  10.,  11.,  12.]
       [ 21.,  22.,  23.,  24.]
</pre></div>
</blockquote><p>
Another example is

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> t[:<span style="color: #666666">-2</span>, :<span style="color: #666666">-1</span>:<span style="color: #666666">2</span>]
array([[  <span style="color: #666666">1.</span>,   <span style="color: #666666">3.</span>,   <span style="color: #666666">5.</span>],
       [  <span style="color: #666666">7.</span>,   <span style="color: #666666">9.</span>,  <span style="color: #666666">11.</span>],
       [ <span style="color: #666666">13.</span>,  <span style="color: #666666">15.</span>,  <span style="color: #666666">17.</span>]])
</pre></div>
<p>
Generalized indexing as described for one-dimensional arrays in
the section <a href="#sec:plot:generalized:index">Generalized indexing</a> requires a more comprehensive
syntax for higher-dimensional arrays.  Say we want to extract a
subarray of <code>t</code> that consists of the rows with indices 0 and 3 and the
columns with indices 1 and 2:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> t[np<span style="color: #666666">.</span>ix_([<span style="color: #666666">0</span>,<span style="color: #666666">3</span>], [<span style="color: #666666">1</span>,<span style="color: #666666">2</span>])]
array([[  <span style="color: #666666">2.</span>,   <span style="color: #666666">3.</span>],
       [ <span style="color: #666666">20.</span>,  <span style="color: #666666">21.</span>]])
<span style="color: #666666">&gt;&gt;&gt;</span> t[np<span style="color: #666666">.</span>ix_([<span style="color: #666666">0</span>,<span style="color: #666666">3</span>], [<span style="color: #666666">1</span>,<span style="color: #666666">2</span>])] <span style="color: #666666">=</span> <span style="color: #666666">0</span>
<span style="color: #666666">&gt;&gt;&gt;</span> t
array([[  <span style="color: #666666">1.</span>,   <span style="color: #666666">0.</span>,   <span style="color: #666666">0.</span>,   <span style="color: #666666">4.</span>,   <span style="color: #666666">5.</span>,   <span style="color: #666666">6.</span>],
       [  <span style="color: #666666">7.</span>,   <span style="color: #666666">8.</span>,   <span style="color: #666666">9.</span>,  <span style="color: #666666">10.</span>,  <span style="color: #666666">11.</span>,  <span style="color: #666666">12.</span>],
       [ <span style="color: #666666">13.</span>,  <span style="color: #666666">14.</span>,  <span style="color: #666666">15.</span>,  <span style="color: #666666">16.</span>,  <span style="color: #666666">17.</span>,  <span style="color: #666666">18.</span>],
       [ <span style="color: #666666">19.</span>,   <span style="color: #666666">0.</span>,   <span style="color: #666666">0.</span>,  <span style="color: #666666">22.</span>,  <span style="color: #666666">23.</span>,  <span style="color: #666666">24.</span>],
       [ <span style="color: #666666">25.</span>,  <span style="color: #666666">26.</span>,  <span style="color: #666666">27.</span>,  <span style="color: #666666">28.</span>,  <span style="color: #666666">29.</span>,  <span style="color: #666666">30.</span>]])
</pre></div>
<p>
Recall that slices only gives a view to the array, not a copy of the values:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> a <span style="color: #666666">=</span> t[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>:<span style="color: #666666">2</span>, <span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]
<span style="color: #666666">&gt;&gt;&gt;</span> a
array([[  <span style="color: #666666">8.</span>,   <span style="color: #666666">9.</span>,  <span style="color: #666666">10.</span>,  <span style="color: #666666">11.</span>],
       [  <span style="color: #666666">0.</span>,   <span style="color: #666666">0.</span>,  <span style="color: #666666">22.</span>,  <span style="color: #666666">23.</span>]])
<span style="color: #666666">&gt;&gt;&gt;</span> a[:,:] <span style="color: #666666">=</span> <span style="color: #666666">-99</span>
<span style="color: #666666">&gt;&gt;&gt;</span> a
array([[<span style="color: #666666">-99.</span>, <span style="color: #666666">-99.</span>, <span style="color: #666666">-99.</span>, <span style="color: #666666">-99.</span>],
       [<span style="color: #666666">-99.</span>, <span style="color: #666666">-99.</span>, <span style="color: #666666">-99.</span>, <span style="color: #666666">-99.</span>]])
<span style="color: #666666">&gt;&gt;&gt;</span> t  <span style="color: #408080; font-style: italic"># is t changed to? yes!</span>
array([[  <span style="color: #666666">1.</span>,   <span style="color: #666666">0.</span>,   <span style="color: #666666">0.</span>,   <span style="color: #666666">4.</span>,   <span style="color: #666666">5.</span>,   <span style="color: #666666">6.</span>],
       [  <span style="color: #666666">7.</span>, <span style="color: #666666">-99.</span>, <span style="color: #666666">-99.</span>, <span style="color: #666666">-99.</span>, <span style="color: #666666">-99.</span>,  <span style="color: #666666">12.</span>],
       [ <span style="color: #666666">13.</span>,  <span style="color: #666666">14.</span>,  <span style="color: #666666">15.</span>,  <span style="color: #666666">16.</span>,  <span style="color: #666666">17.</span>,  <span style="color: #666666">18.</span>],
       [ <span style="color: #666666">19.</span>, <span style="color: #666666">-99.</span>, <span style="color: #666666">-99.</span>, <span style="color: #666666">-99.</span>, <span style="color: #666666">-99.</span>,  <span style="color: #666666">24.</span>],
       [ <span style="color: #666666">25.</span>,  <span style="color: #666666">26.</span>,  <span style="color: #666666">27.</span>,  <span style="color: #666666">28.</span>,  <span style="color: #666666">29.</span>,  <span style="color: #666666">30.</span>]])
</pre></div>

<h2 id="sec:plot:array2comp">Array computing<a name="sec:plot:array2comp"></a></h2>

The operations on vectors in the section <a href="#sec:plot:arraycomp">Vector arithmetics and vector functions</a> can quite
straightforwardly be extended to arrays of any dimension.  Consider
the definition of applying a function \( f(v) \) to a vector \( v \): we apply
the function to each element \( v_i \) in \( v \).  For a two-dimensional
array \( A \) with elements \( A_{i,j} \), \( i=0,\ldots,m \), \( j=0,\ldots,n \), the
same definition yields

$$
\begin{equation*} f(A) = (f(A_{0,0}),\ldots,f(A_{m-1,0}),f(A_{1,0}),
\ldots,f(A_{m-1,n-1}))\tp \end{equation*}
$$

For an array \( B \) with any rank, \( f(B) \) means applying \( f \) to
each array entry.

<p>
The asterisk operation from the section <a href="#sec:plot:arraycomp">Vector arithmetics and vector functions</a> is also
naturally extended to arrays: \( A*B \) means multiplying an element in
\( A \) by the corresponding element in \( B \), i.e., element \( (i,j) \) in
\( A*B \) is \( A_{i,j}B_{i,j} \).  This definition naturally extends to
arrays of any rank, provided the two arrays have the same shape.

<p>
Adding a scalar to an array implies adding the scalar to each element
in the array. Compound expressions involving arrays, e.g.,
\( \exp(-A^2)*A +1 \), work as for vectors. One can in fact just imagine
that all the array elements are stored after each other in a long
vector (this is actually the way the array elements are stored in the
computer's memory), and the array operations can then easily be
defined in terms of the vector operations from the section <a href="#sec:plot:arraycomp">Vector arithmetics and vector functions</a>.

<h3 id="___sec58">Remark <a name="___sec58"></a></h3>

Readers with knowledge of matrix computations may get confused by the
meaning of \( A^2 \) in matrix computing and \( A^2 \) in array computing. The
former is a matrix-matrix product, while the latter means squaring all
elements of \( A \). Which rule to apply, depends on the context, i.e.,
whether we are doing linear algebra or vectorized arithmetics. In
mathematical typesetting, \( A^2 \) can be written as \( AA \), while the
array computing expression \( A^2 \) can be alternatively written as
\( A*A \).  In a program, <code>A*A</code> and <code>A**2</code> are identical computations,
meaning squaring all elements (array arithmetics). With NumPy arrays
the matrix-matrix product is obtained by <code>dot(A, A)</code>. The
matrix-vector product \( Ax \), where \( x \) is a vector, is computed by
<code>dot(A, x)</code>. However, with matrix objects (see the section <a href="#sec:plot:numpy:matrix">Matrix objects</a>) <code>A*A</code> implies the mathematical matrix
multiplication \( AA \).

<p>
We shall leave this subject of notational confusion between array computing and
linear algebra here since this book will not further understanding and
the confusion is seldom serious in program code if one has a good
overview of the mathematics that is to be carried out.

<h2 id="___sec59">Two-dimensional arrays and functions of two variables <a name="___sec59"></a></h2>

Given a function of two variables, say

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>(x, y):
    <span style="color: #008000; font-weight: bold">return</span> sin(sqrt(x<span style="color: #666666">**2</span> <span style="color: #666666">+</span> y<span style="color: #666666">**2</span>))
</pre></div>
<p>
we can plot this function by writing

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">scitools.std</span> <span style="color: #008000; font-weight: bold">import</span> sin, sqrt, linspace, ndgrid, mesh
x <span style="color: #666666">=</span> y <span style="color: #666666">=</span> linspace(<span style="color: #666666">-5</span>, <span style="color: #666666">5</span>, <span style="color: #666666">21</span>)  <span style="color: #408080; font-style: italic"># coordinates in x and y direction</span>
xv, yv <span style="color: #666666">=</span> ndgrid(x, y)
z <span style="color: #666666">=</span> f(xv, yv)
mesh(xv, yv, z)
</pre></div>
<p>
There are two new things here: (i) the call to <code>ndgrid</code>, which is
necessary to transform one-dimensional coordinate arrays in the \( x \)
and \( y \) direction into arrays valid for evaluating <code>f</code> over a
two-dimensional grid; and (ii) the plot function whose name now is
<code>mesh</code>, which is one out of many plot functions for two-dimensional
functions. Another plot type you can try out is

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">surf(xv, yv, z)
</pre></div>
<p>
More material on visualizing \( f(x,y) \) functions is found in the
section <em>Visualizing Scalar Fields</em> in the Easyviz tutorial.  This
tutorial can be reached through the command <code>pydoc scitools.easyviz</code>
in a terminal window or from <a href="http://code.google.com/p/scitools" target="_self"><tt>code.google.com/p/scitools</tt></a>.

<h2 id="sec:plot:numpy:matrix">Matrix objects<a name="sec:plot:numpy:matrix"></a></h2>

This section only makes sense if you are familiar with basic linear
algebra and the matrix concept.  The arrays created so far have been
of type <code>ndarray</code>.  NumPy also has a matrix type called <code>matrix</code> or
<code>mat</code> for one- and two-dimensional arrays. One-dimensional arrays are
then extended with one extra dimension such that they become matrices,
i.e., either a row vector or a column vector:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #666666">&gt;&gt;&gt;</span> x1 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array([<span style="color: #666666">1</span>, <span style="color: #666666">2</span>, <span style="color: #666666">3</span>], <span style="color: #008000">float</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> x2 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>matrix(x1)               <span style="color: #408080; font-style: italic"># or mat(x1)</span>
<span style="color: #666666">&gt;&gt;&gt;</span> x2                               <span style="color: #408080; font-style: italic"># row vector</span>
matrix([[ <span style="color: #666666">1.</span>,  <span style="color: #666666">2.</span>,  <span style="color: #666666">3.</span>]])
<span style="color: #666666">&gt;&gt;&gt;</span> x3 <span style="color: #666666">=</span> mat(x)<span style="color: #666666">.</span>transpose()          <span style="color: #408080; font-style: italic"># column vector</span>
<span style="color: #666666">&gt;&gt;&gt;</span> x3
matrix([[ <span style="color: #666666">1.</span>],
        [ <span style="color: #666666">2.</span>],
        [ <span style="color: #666666">3.</span>]])

<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000">type</span>(x3)
<span style="color: #666666">&lt;</span><span style="color: #008000; font-weight: bold">class</span> &#39;<span style="color: #0000FF; font-weight: bold">numpy</span><span style="color: #666666">.</span>matrixlib<span style="color: #666666">.</span>defmatrix<span style="color: #666666">.</span>matrix<span style="color: #BA2121">&#39;&gt;</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000">isinstance</span>(x3, np<span style="color: #666666">.</span>matrix)
<span style="color: #008000">True</span>
</pre></div>
<p>
A special feature of <code>matrix</code> objects is that the multiplication
operator represents the matrix-matrix, vector-matrix, or matrix-vector
product as we know from linear algebra:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> A <span style="color: #666666">=</span> eye(<span style="color: #666666">3</span>)                    <span style="color: #408080; font-style: italic"># identity matrix</span>
<span style="color: #666666">&gt;&gt;&gt;</span> A
array([[ <span style="color: #666666">1.</span>,  <span style="color: #666666">0.</span>,  <span style="color: #666666">0.</span>],
       [ <span style="color: #666666">0.</span>,  <span style="color: #666666">1.</span>,  <span style="color: #666666">0.</span>],
       [ <span style="color: #666666">0.</span>,  <span style="color: #666666">0.</span>,  <span style="color: #666666">1.</span>]])
<span style="color: #666666">&gt;&gt;&gt;</span> A <span style="color: #666666">=</span> mat(A)
<span style="color: #666666">&gt;&gt;&gt;</span> A
matrix([[ <span style="color: #666666">1.</span>,  <span style="color: #666666">0.</span>,  <span style="color: #666666">0.</span>],
        [ <span style="color: #666666">0.</span>,  <span style="color: #666666">1.</span>,  <span style="color: #666666">0.</span>],
        [ <span style="color: #666666">0.</span>,  <span style="color: #666666">0.</span>,  <span style="color: #666666">1.</span>]])
<span style="color: #666666">&gt;&gt;&gt;</span> y2 <span style="color: #666666">=</span> x2<span style="color: #666666">*</span>A                     <span style="color: #408080; font-style: italic"># vector-matrix product</span>
<span style="color: #666666">&gt;&gt;&gt;</span> y2
matrix([[ <span style="color: #666666">1.</span>,  <span style="color: #666666">2.</span>,  <span style="color: #666666">3.</span>]])
<span style="color: #666666">&gt;&gt;&gt;</span> y3 <span style="color: #666666">=</span> A<span style="color: #666666">*</span>x3                     <span style="color: #408080; font-style: italic"># matrix-vector product</span>
<span style="color: #666666">&gt;&gt;&gt;</span> y3
matrix([[ <span style="color: #666666">1.</span>],
        [ <span style="color: #666666">2.</span>],
        [ <span style="color: #666666">3.</span>]])
</pre></div>
<p>
One should note here that the multiplication operator between standard
<code>ndarray</code> objects is quite different, as the next interactive
session demonstrates.

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> A<span style="color: #666666">*</span>x1                          <span style="color: #408080; font-style: italic"># no matrix-array product!</span>
Traceback (most recent call last):
<span style="color: #666666">...</span>
<span style="color: #D2413A; font-weight: bold">ValueError</span>: matrices are <span style="color: #AA22FF; font-weight: bold">not</span> aligned

<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #408080; font-style: italic"># try array*array product:</span>
<span style="color: #666666">&gt;&gt;&gt;</span> A <span style="color: #666666">=</span> (zeros(<span style="color: #666666">9</span>) <span style="color: #666666">+</span> <span style="color: #666666">1</span>)<span style="color: #666666">.</span>reshape(<span style="color: #666666">3</span>,<span style="color: #666666">3</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> A
array([[ <span style="color: #666666">1.</span>,  <span style="color: #666666">1.</span>,  <span style="color: #666666">1.</span>],
       [ <span style="color: #666666">1.</span>,  <span style="color: #666666">1.</span>,  <span style="color: #666666">1.</span>],
       [ <span style="color: #666666">1.</span>,  <span style="color: #666666">1.</span>,  <span style="color: #666666">1.</span>]])
<span style="color: #666666">&gt;&gt;&gt;</span> A<span style="color: #666666">*</span>x1                      <span style="color: #408080; font-style: italic"># [A[0,:]*x1, A[1,:]*x1, A[2,:]*x1]</span>
array([[ <span style="color: #666666">1.</span>,  <span style="color: #666666">2.</span>,  <span style="color: #666666">3.</span>],
       [ <span style="color: #666666">1.</span>,  <span style="color: #666666">2.</span>,  <span style="color: #666666">3.</span>],
       [ <span style="color: #666666">1.</span>,  <span style="color: #666666">2.</span>,  <span style="color: #666666">3.</span>]])
<span style="color: #666666">&gt;&gt;&gt;</span> B <span style="color: #666666">=</span> A <span style="color: #666666">+</span> <span style="color: #666666">1</span>
<span style="color: #666666">&gt;&gt;&gt;</span> A<span style="color: #666666">*</span>B                       <span style="color: #408080; font-style: italic"># element-wise product</span>
array([[ <span style="color: #666666">2.</span>,  <span style="color: #666666">2.</span>,  <span style="color: #666666">2.</span>],
       [ <span style="color: #666666">2.</span>,  <span style="color: #666666">2.</span>,  <span style="color: #666666">2.</span>],
       [ <span style="color: #666666">2.</span>,  <span style="color: #666666">2.</span>,  <span style="color: #666666">2.</span>]])
<span style="color: #666666">&gt;&gt;&gt;</span> A <span style="color: #666666">=</span> mat(A);  B <span style="color: #666666">=</span> mat(B)
<span style="color: #666666">&gt;&gt;&gt;</span> A<span style="color: #666666">*</span>B                       <span style="color: #408080; font-style: italic"># matrix-matrix product</span>
matrix([[ <span style="color: #666666">6.</span>,  <span style="color: #666666">6.</span>,  <span style="color: #666666">6.</span>],
        [ <span style="color: #666666">6.</span>,  <span style="color: #666666">6.</span>,  <span style="color: #666666">6.</span>],
        [ <span style="color: #666666">6.</span>,  <span style="color: #666666">6.</span>,  <span style="color: #666666">6.</span>]])
</pre></div>
<p>
Readers who are familiar with MATLAB, or intend to use Python and
MATLAB together, should seriously think about programming with
<code>matrix</code> objects instead of <code>ndarray</code> objects, because the <code>matrix</code>
type behaves quite similar to matrices and vectors in MATLAB.
Nevertheless, <code>matrix</code> cannot be used for arrays of larger dimension
than two.

<h1 id="___sec61">Summary <a name="___sec61"></a></h1>

<h2 id="___sec62">Chapter topics <a name="___sec62"></a></h2>

This document has introduced computing with arrays and plotting
curve data stored in arrays. The Numerical Python package contains
lots of functions for array computing, including the ones listed in
the table below.  Plotting has been done with tools that closely
resemble the syntax of MATLAB.

<p>

<div class="row">
  <div class="col-xs-3">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center"><b>                                   Construction                                  </b></td> <td align="center"><b>                                     Meaning                                     </b></td> </tr>
</thead>
<tbody>
<tr><td align="left">   <code>array(ld)</code>                                                               </td> <td align="left">   copy list data <code>ld</code> to a <code>numpy</code> array                         </td> </tr>
<tr><td align="left">   <code>asarray(d)</code>                                                              </td> <td align="left">   make array of data <code>d</code> (no data copy if already array)                    </td> </tr>
<tr><td align="left">   <code>zeros(n)</code>                                                                </td> <td align="left">   make a <code>float</code> vector/array of length <code>n</code>, with zeros          </td> </tr>
<tr><td align="left">   <code>zeros(n, int)</code>                                                           </td> <td align="left">   make an <code>int</code> vector/array of length <code>n</code> with zeros            </td> </tr>
<tr><td align="left">   <code>zeros((m,n))</code>                                                            </td> <td align="left">   make a two-dimensional <code>float</code> array with shape (<code>m</code>,`n`)      </td> </tr>
<tr><td align="left">   <code>zeros_like(x)</code>                                                           </td> <td align="left">   make array of same shape and element type as <code>x</code>                          </td> </tr>
<tr><td align="left">   <code>linspace(a,b,m)</code>                                                         </td> <td align="left">   uniform sequence of <code>m</code> numbers in \( [a,b] \)                            </td> </tr>
<tr><td align="left">   <code>a.shape</code>                                                                 </td> <td align="left">   tuple containing <code>a</code>'s shape                                              </td> </tr>
<tr><td align="left">   <code>a.size</code>                                                                  </td> <td align="left">   total no of elements in <code>a</code>                                               </td> </tr>
<tr><td align="left">   <code>len(a)</code>                                                                  </td> <td align="left">   length of a one-dim. array <code>a</code> (same as <code>a.shape[0]</code>)          </td> </tr>
<tr><td align="left">   <code>a.dtype</code>                                                                 </td> <td align="left">   the type of elements in <code>a</code>                                               </td> </tr>
<tr><td align="left">   <code>a.reshape(3,2)</code>                                                          </td> <td align="left">   return <code>a</code> reshaped as \( 3\times 2 \) array                              </td> </tr>
<tr><td align="left">   <code>a[i]</code>                                                                    </td> <td align="left">   vector indexing                                                                      </td> </tr>
<tr><td align="left">   <code>a[i,j]</code>                                                                  </td> <td align="left">   two-dim. array indexing                                                              </td> </tr>
<tr><td align="left">   <code>a[1:k]</code>                                                                  </td> <td align="left">   slice: reference data with indices <code>1</code>,\ldots,`k-1`                       </td> </tr>
<tr><td align="left">   <code>a[1:8:3]</code>                                                                </td> <td align="left">   slice: reference data with indices <code>1</code>, <code>4</code>,\ldots,`7`         </td> </tr>
<tr><td align="left">   <code>b = a.copy()</code>                                                            </td> <td align="left">   copy an array                                                                        </td> </tr>
<tr><td align="left">   <code>sin(a), exp(a), ...</code>                                                     </td> <td align="left">   <code>numpy</code> functions applicable to arrays                                    </td> </tr>
<tr><td align="left">   <code>c = concatenate((a, b))</code>                                                 </td> <td align="left">   <code>c</code> contains <code>a</code> with <code>b</code> appended                  </td> </tr>
<tr><td align="left">   <code>c = where(cond, a1, a2)</code>                                                 </td> <td align="left">   <code>c[i] = a1[i]</code> if <code>cond[i]</code>, else <code>c[i] = a2[i]</code>    </td> </tr>
<tr><td align="left">   <code>isinstance(a, ndarray)</code>                                                  </td> <td align="left">   is <code>True</code> if <code>a</code> is an array                                   </td> </tr>
</tbody>
    </table>
  </div>
</div> <!-- col-xs-3 -->

<h3 id="___sec63">Array computing <a name="___sec63"></a></h3>

When we apply a Python function <code>f(x)</code> to a Numerical Python array
<code>x</code>, the result is the same as if we apply <code>f</code> to each element in <code>x</code>
separately.  However, when <code>f</code> contains <code>if</code> statements, these are in
general invalid if an array <code>x</code> enters the boolean expression.  We
then have to rewrite the function, often by applying the <code>where</code>
function from Numerical Python.

<h3 id="___sec64">Plotting curves <a name="___sec64"></a></h3>

The sections <a href="#sec:plot:pylab">Matplotlib; pylab</a> and <a href="#sec:plot:pyplot">Matplotlib; pyplot</a> provide a
quick overview of how to plot curves with the aid of Matplotlib.
The same examples coded with the Easyviz plotting interface
appear in the section <a href="#sec:plot:SciTools">SciTools and Easyviz</a>.

<h3 id="___sec65">Making movies <a name="___sec65"></a></h3>

Each frame in a movie must be a hardcopy of a plot in PNG format.
These plot files should have names containing a counter padded with
leading zeros. One example may be <code>tmp_0000.png</code>, <code>tmp_0001.png</code>,
<code>tmp_0002.png</code>.  Having the plot files with names on this form, we can
make an animated GIF movie in the file <code>movie.gif</code>, with two frames
per second, by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">os<span style="color: #666666">.</span>system(<span style="color: #BA2121">&#39;convert -delay 50 tmp_*.png movie.gif&#39;</span>)
</pre></div>
<p>
Alternatively, we may combine the plot files to a Flash video:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">os<span style="color: #666666">.</span>system(<span style="color: #BA2121">&#39;ffmpeg -r 5 -i tmp_</span><span style="color: #BB6688; font-weight: bold">%04d</span><span style="color: #BA2121">.png -vcodec flv movie.flv&#39;</span>)
</pre></div>
<p>
Other formats can be made using other codecs, see
the section <a href="#sec:plot:video">Making videos</a>.

<h3 id="___sec66">Terminology <a name="___sec66"></a></h3>

The important topics in this document are

<ul>
 <li> array computing</li>
 <li> vectorization</li>
 <li> plotting</li>
 <li> animations</li>
</ul>

<h2 id="sec:plot:summarizing">Example: Animating a function<a name="sec:plot:summarizing"></a></h2>

<h3 id="___sec68">Problem <a name="___sec68"></a></h3>

In this document's summarizing example we shall visualize how the
temperature varies downward in the earth as the surface temperature
oscillates between high day and low night values. One question may be:
What is the temperature change 10 m down in the ground if the surface
temperature varies between 2 C in the night and 15 C in the day?

<p>
Let the \( z \) axis point downwards, towards the center of the earth, and
let \( z=0 \) correspond to the earth's surface. The temperature at some
depth \( z \) in the ground at time \( t \) is denoted by \( T(z,t) \).  If the
surface temperature has a periodic variation around some mean value
\( T_0 \), according to

$$
\begin{equation*} T(0,t)=T_0+ A\cos (\omega t),\end{equation*}
$$

one can find, from a mathematical model for heat conduction,
that the temperature
at an arbitrary depth is

$$
\begin{equation}
T(z,t) = T_0 + Ae^{-az}\cos (\omega t - az),\quad a =\sqrt{\omega\over 2k}\tp
\tag{3}
\end{equation}
$$

The parameter \( k \) reflects the ground's ability to conduct
heat (\( k \) is called the <em>thermal diffusivity</em> or
the <em>heat conduction coefficient</em>).

<p>
The task is to make an animation of how the temperature profile in the
ground, i.e., \( T \) as a function of \( z \), varies in time.  Let \( \omega \)
correspond to a time period of 24 hours.  The mean temperature \( T_0 \)
is taken as 10 C, and the maximum variation \( A \) is assumed to be 10 C.
The heat conduction coefficient \( k \) may be set as \( 1\hbox{
mm}^2/\hbox{s} \) (which is \( 10^{-6} \hbox{ m}^2/\hbox{s} \) in proper SI
units).

<h3 id="___sec69">Solution <a name="___sec69"></a></h3>

To animate \( T(z,t) \) in time, we need to make a loop over points in
time, and in each pass in the loop we must save a plot of \( T \), as a
function of \( z \), to file. The plot files can then be combined to a
movie.  The algorithm becomes

<ul>
 <li> for \( t_i=i\Delta t \), \( i=0,1,2\ldots,n \):</li>

<ul>
   <li> plot the curve \( y(z)=T(z,t_i) \)</li>
   <li> store the plot in a file</li>
</ul>

 <li> combine all the plot files into a movie</li>
</ul>

It can be wise to make a general <code>animate</code> function where we just feed
in some \( f(x,t) \) function and make all the plot files.  If <code>animate</code>
has arguments for setting the labels on the axis and the extent of the
\( y \) axis, we can easily use <code>animate</code> also for a function \( T(z,t) \) (we
just use \( z \) as the name for the \( x \) axis and \( T \) as the name for the
\( y \) axis in the plot). Recall that it is important to fix the extent
of the \( y \) axis in a plot when we make animations, otherwise most
plotting programs will automatically fit the extent of the axis to the
current data, and the tick marks on the \( y \) axis will jump up and down
during the movie. The result is a wrong visual impression of the
function.

<p>
The names of the plot files must have a common stem appended with some
frame number, and the frame number should have a fixed number of
digits, such as 0001, 0002, etc. (if not, the sequence of the plot
files will not be correct when we specify the collection of files with
an asterisk for the frame numbers, e.g., as in <code>tmp*.png</code>).  We
therefore include an argument to <code>animate</code> for setting the name stem
of the plot files. By default, the stem is <code>tmp_</code>, resulting in the
filenames <code>tmp_0000.png</code>, <code>tmp_0001.png</code>, <code>tmp_0002.png</code>, and so
forth.  Other convenient arguments for the <code>animate</code> function are the
initial time in the plot, the time lag \( \Delta t \) between the plot
frames, and the coordinates along the \( x \) axis.  The <code>animate</code>
function then takes the form

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">animate</span>(tmax, dt, x, function, ymin, ymax, t0<span style="color: #666666">=0</span>,
            xlabel<span style="color: #666666">=</span><span style="color: #BA2121">&#39;x&#39;</span>, ylabel<span style="color: #666666">=</span><span style="color: #BA2121">&#39;y&#39;</span>, filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;tmp_&#39;</span>):
    t <span style="color: #666666">=</span> t0
    counter <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">while</span> t <span style="color: #666666">&lt;=</span> tmax:
        y <span style="color: #666666">=</span> function(x, t)
        plot(x, y, <span style="color: #BA2121">&#39;-&#39;</span>,
             axis<span style="color: #666666">=</span>[x[<span style="color: #666666">0</span>], x[<span style="color: #666666">-1</span>], ymin, ymax],
             title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;time=</span><span style="color: #BB6688; font-weight: bold">%2d</span><span style="color: #BA2121"> h&#39;</span> <span style="color: #666666">%</span> (t<span style="color: #666666">/3600.0</span>),
             xlabel<span style="color: #666666">=</span>xlabel, ylabel<span style="color: #666666">=</span>ylabel,
             savefig<span style="color: #666666">=</span>filename <span style="color: #666666">+</span> <span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%04d</span><span style="color: #BA2121">.png&#39;</span> <span style="color: #666666">%</span> counter)
        savefig(<span style="color: #BA2121">&#39;tmp_</span><span style="color: #BB6688; font-weight: bold">%04d</span><span style="color: #BA2121">.pdf&#39;</span> <span style="color: #666666">%</span> counter)
        t <span style="color: #666666">+=</span> dt
        counter <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
</pre></div>
<p>
The \( T(z,t) \) function is easy to implement, but we need to decide
whether the parameters \( A \), \( \omega \), \( T_0 \), and \( k \) shall be
arguments to the Python implementation of \( T(z,t) \) or if they shall be
global variables. Since the <code>animate</code> function expects that the
function to be plotted has only two arguments, we must implement
\( T(z,t) \) as <code>T(z,t)</code> in Python and let the other parameters be global
variables
(the sections ref{sec:class:func1} and ref{sec:class:func2}
explain this problem in more detail and present a better implementation).
The <code>T(z,t)</code> implementation
then reads

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">T</span>(z, t):
    <span style="color: #408080; font-style: italic"># T0, A, k, and omega are global variables</span>
    a <span style="color: #666666">=</span> sqrt(omega<span style="color: #666666">/</span>(<span style="color: #666666">2*</span>k))
    <span style="color: #008000; font-weight: bold">return</span> T0 <span style="color: #666666">+</span> A<span style="color: #666666">*</span>exp(<span style="color: #666666">-</span>a<span style="color: #666666">*</span>z)<span style="color: #666666">*</span>cos(omega<span style="color: #666666">*</span>t <span style="color: #666666">-</span> a<span style="color: #666666">*</span>z)
</pre></div>
<p>
Suppose we plot \( T(z,t) \) at \( n \) points for \( z\in [0,D] \).  We make such
plots for \( t\in [0,t_{\max}] \) with a time lag \( \Delta t \) between the
them.  The frames in the movie are now made by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># set T0, A, k, omega, D, n, tmax, dt</span>
z <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, D, n)
animate(tmax, dt, z, T, T0<span style="color: #666666">-</span>A, T0<span style="color: #666666">+</span>A, <span style="color: #666666">0</span>, <span style="color: #BA2121">&#39;z&#39;</span>, <span style="color: #BA2121">&#39;T&#39;</span>)
</pre></div>
<p>
We have here set the extent of the \( y \) axis in the plot as
\( [T_0-A,T_0+A] \), which is in accordance with the \( T(z,t) \) function.

<p>
The call to <code>animate</code> above creates a set of files with names
of the form <code>tmp_*.png</code>. Out of these files we can create an
animated GIF movie or a video in, e.g., Flash format by
running operating systems commands with <code>convert</code> and <code>avconv</code> (or
<code>ffmpeg</code>):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">os<span style="color: #666666">.</span>system(<span style="color: #BA2121">&#39;convert -delay 50 tmp_*.png movie.gif&#39;</span>)
os<span style="color: #666666">.</span>system(<span style="color: #BA2121">&#39;avconv -r 5 -i tmp_</span><span style="color: #BB6688; font-weight: bold">%04d</span><span style="color: #BA2121">.png -vcodec flv movie.flv&#39;</span>)
</pre></div>
<p>
See the section <a href="#sec:plot:video">Making videos</a> for how to create videos in
other formats.

<p>
It now remains to assign proper values to all the global variables in
the program: <code>n</code>, <code>D</code>, <code>T0</code>, <code>A</code>, <code>omega</code>, <code>dt</code>, <code>tmax</code>, and <code>k</code>.  The
oscillation period is 24 hours, and \( \omega \) is related to the period
\( P \) of the cosine function by \( \omega = 2\pi /P \) (realize that \( \cos
(t2\pi/P) \) has period \( P \)).  We then express \( P=24 \) h as \( 24\cdot
60\cdot 60 \) s and compute \( \omega \) as \( 2\pi/P \approx 7\cdot
10^{-5}\hbox{ s}^{-1} \).  The total simulation time can be 3 periods,
i.e., \( t_{\max} = 3P \).  The \( T(z,t) \) function decreases exponentially
with the depth \( z \) so there is no point in having the maximum depth
\( D \) larger than the depth where \( T \) is visually zero, say 0.001. We
have that \( e^{-aD}=0.001 \) when \( D=-a^{-1}\ln 0.001 \), so we can use
this estimate in the program.  The proper initialization of all
parameters can then be expressed as follows:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">k <span style="color: #666666">=</span> <span style="color: #666666">1E-6</span>        <span style="color: #408080; font-style: italic"># thermal diffusivity (in m*m/s)</span>
P <span style="color: #666666">=</span> <span style="color: #666666">24*60*60.</span>   <span style="color: #408080; font-style: italic"># oscillation period of 24 h (in seconds)</span>
omega <span style="color: #666666">=</span> <span style="color: #666666">2*</span>pi<span style="color: #666666">/</span>P
dt <span style="color: #666666">=</span> P<span style="color: #666666">/24</span>       <span style="color: #408080; font-style: italic"># time lag: 1 h</span>
tmax <span style="color: #666666">=</span> <span style="color: #666666">3*</span>P      <span style="color: #408080; font-style: italic"># 3 day/night simulation</span>
T0 <span style="color: #666666">=</span> <span style="color: #666666">10</span>         <span style="color: #408080; font-style: italic"># mean surface temperature in Celsius</span>
A <span style="color: #666666">=</span> <span style="color: #666666">10</span>          <span style="color: #408080; font-style: italic"># amplitude of the temperature variations in Celsius</span>
a <span style="color: #666666">=</span> sqrt(omega<span style="color: #666666">/</span>(<span style="color: #666666">2*</span>k))
D <span style="color: #666666">=</span> <span style="color: #666666">-</span>(<span style="color: #666666">1/</span>a)<span style="color: #666666">*</span>log(<span style="color: #666666">0.001</span>) <span style="color: #408080; font-style: italic"># max depth</span>
n <span style="color: #666666">=</span> <span style="color: #666666">501</span>         <span style="color: #408080; font-style: italic"># no of points in the z direction</span>
</pre></div>
<p>
Note that it is very important to use consistent units. Here we
express all units in terms of meter, second, and Kelvin or Celsius.

<p>
We encourage you to run the program
<a href="http://tinyurl.com/pwyasaa/plot/heatwave.py" target="_self"><tt>heatwave.py</tt></a> to see the
movie. The hardcopy of the movie is in the file <code>movie.gif</code>.
Figure <a href="#fig:plot:heatwave:fig1">11</a> displays two snapshots in time of
the \( T(z,t) \) function.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 11:  Plot of the temperature \( T(z,t) \) in the ground for two different \( t \) values. <a name="fig:plot:heatwave:fig1"></a> </p></center>
<p><img src="fig-plot/heatwave12.png" align="bottom" width=400></p>
</center>

<p>
<a name="sec:plot:scaling"></a>

<h3 id="___sec70">Scaling <a name="___sec70"></a></h3>

In this example, as in many other scientific problems, it was easier
to write the code than to assign proper physical values to the input
parameters in the program. To learn about the physical process, here
how heat propagates from the surface and down in the ground, it is
often advantageous to scale the variables in the problem so that we
work with dimensionless variables. Through the scaling procedure we
normally end up with much fewer physical parameters that must be
assigned values. Let us show how we can take advantage of scaling the
present problem.

<p>
Consider a variable \( x \) in a problem with some dimension.  The idea of
scaling is to introduce a new variable \( \bar x = x/x_c \), where \( x_c \)
is a <em>characteristic size</em> of \( x \). Since \( x \) and \( x_c \) have the same
dimension, the dimension cancels in \( \bar x \) such that \( \bar x \) is
dimensionless. Choosing \( x_c \) to be the expected maximum value of \( x \),
ensures that \( \bar x\leq 1 \), which is usually considered a good
idea. That is, we try to have all dimensionless variables varying
between zero and one. For example, we can introduce a dimensionless
\( z \) coordinate: \( \bar z= z/D \), and now \( \bar z \in [0,1] \). Doing a
proper scaling of a problem is challenging so for now it is sufficient
to just follow the steps below - and not worry why we choose a certain
scaling.

<p>
In the present problem we introduce these dimensionless variables:

$$
\begin{align*}
\bar z &= z/D\\ 
\bar T &= {T-T_0\over A}\\ 
\bar t &= {\omega t}
\end{align*}
$$

We now insert \( z=\bar z D \) and \( t=\bar t/\omega \) in the expression
for \( T(z,t) \) and get

$$
\begin{equation*} T = T_0 + Ae^{-b\bar z}\cos(\bar t - b\bar z),\quad b=aD\end{equation*}
$$

or

$$
\begin{equation*} \bar T(\bar z,\bar t)
= {T-T_0\over A} = e^{-b\bar z}\cos(\bar t - b\bar z)\tp\end{equation*}
$$

We see that \( \bar T \) depends on only <em>one</em> dimensionless parameter \( b \)
in addition to the independent dimensionless variables \( \bar z \) and
\( \bar t \). It is common practice at this stage of the scaling to just
drop the bars and write

$$
\begin{equation}
T(z,t) = e^{-bz}\cos(t - bz)\tp
\end{equation}
$$

This function is much simpler to plot than the one with lots of
physical parameters, because now we know that \( T \) varies between \( -1 \)
and 1, \( t \) varies between 0 and \( 2\pi \) for one period, and \( z \) varies
between 0 and 1.  The scaled temperature has only one parameter \( b \) in
addition to the independent variable.  That is, the shape of the graph
is completely determined by \( b \).

<p>
In our previous movie example, we used specific values for \( D \),
\( \omega \), and \( k \), which then implies a certain \( b=D\sqrt{\omega
/(2k)} \) (\( \approx 6.9 \)).  However, we can now run different \( b \) values
and see the effect on the heat propagation.  Different \( b \) values will
in our problems imply different periods of the surface temperature
variation and/or different heat conduction values in the ground's
composition of rocks.  Note that doubling \( \omega \) and \( k \) leaves the
same \( b \) - it is only the fraction \( \omega/k \) that influences the
value of \( b \).

<p>
We can reuse the <code>animate</code> function also in the scaled case, but
we need to make a new \( T(z,t) \) function and, e.g., a main program
where \( b \) can be read from the command line:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">T</span>(z, t):
    <span style="color: #008000; font-weight: bold">return</span> exp(<span style="color: #666666">-</span>b<span style="color: #666666">*</span>z)<span style="color: #666666">*</span>cos(t <span style="color: #666666">-</span> b<span style="color: #666666">*</span>z)  <span style="color: #408080; font-style: italic"># b is global</span>

b <span style="color: #666666">=</span> <span style="color: #008000">float</span>(sys<span style="color: #666666">.</span>argv[<span style="color: #666666">1</span>])
n <span style="color: #666666">=</span> <span style="color: #666666">401</span>
z <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, n)
animate(<span style="color: #666666">3*2*</span>pi, <span style="color: #666666">0.05*2*</span>pi, z, T, <span style="color: #666666">-1.2</span>, <span style="color: #666666">1.2</span>, <span style="color: #666666">0</span>, <span style="color: #BA2121">&#39;z&#39;</span>, <span style="color: #BA2121">&#39;T&#39;</span>)
movie(<span style="color: #BA2121">&#39;tmp_*.png&#39;</span>, encoder<span style="color: #666666">=</span><span style="color: #BA2121">&#39;convert&#39;</span>, fps<span style="color: #666666">=2</span>,
      output_file<span style="color: #666666">=</span><span style="color: #BA2121">&#39;tmp_heatwave.gif&#39;</span>)
os<span style="color: #666666">.</span>system(<span style="color: #BA2121">&#39;convert -delay 50 tmp_*.png movie.gif&#39;</span>)
</pre></div>
<p>
Running the program, found as the file <a href="http://tinyurl.com/pwyasaa/plot/heatwave_scaled.py" target="_self"><tt>heatwave_scaled.py</tt></a>, for different \( b \) values shows
that \( b \) governs how deep the temperature variations on the surface
\( z=0 \) penetrate. A large \( b \) makes the temperature changes confined to
a thin layer close to the surface, while a small \( b \) leads to
temperature variations also deep down in the ground.
You are encouraged to run the program with \( b=2 \) and \( b=20 \)
to experience the major difference, or just view the
<a href="http://hplgit.github.io/scipro-primer/video/heatwave.html" target="_self">ready-made animations</a>.

<p>
We can understand the results from a physical perspective.  Think of
increasing \( \omega \), which means reducing the oscillation period so we
get a more rapid temperature variation. To preserve the value of \( b \)
we must increase \( k \) by the same factor. Since a large \( k \) means that
heat quickly spreads down in the ground, and a small \( k \) implies the
opposite, we see that more rapid variations at the surface requires a
larger \( k \) to more quickly conduct the variations down in the
ground. Similarly, slow temperature variations on the surface can
penetrate deep in the ground even if the ground's ability to conduct
(\( k \)) is low.

<p>
<!-- FIGURE: [fig-plot/heatwave34, width=400 frac=0.9] Plot of the dimensionless temperature \( T(z,t) \)   in the ground for two different \( t \) values and \( b=20 \). <a name="fig:plot:heatwave:fig2"></a> -->

<p>
<!-- FIGURE: [fig-plot/heatwave56, width=400 frac=0.9] Plot of the dimensionless temperature \( T(z,t) \)   in the ground for two different \( t \) values and \( b=2 \). <a name="fig:plot:heatwave:fig3"></a> -->

<h1 id="sec:plot:exer">Exercises<a name="sec:plot:exer"></a></h1>

<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex1">Exercise 1: Fill lists with function values<a name="sec:plot:ex1"></a></h2>

Define

$$
\begin{equation}
h(x) = {1\over\sqrt{2\pi}}e^{-\frac{1}{2}x^2}\tp
\tag{4}
\end{equation}
$$

Fill lists <code>xlist</code> and <code>hlist</code> with \( x \) and \( h(x) \) values
for 41 uniformly spaced \( x \) coordinates in \( [-4,4] \).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
You may adapt the example in the section <a href="#sec:plot:listdata">Using lists for collecting function data</a>.

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>fill_lists.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex2">Exercise 2: Fill arrays; loop version<a name="sec:plot:ex2"></a></h2>

The aim is to fill two arrays <code>x</code> and <code>y</code> with \( x \) and \( h(x) \) values,
respectively, where \( h(x) \) is defined in <a href="#mjx-eqn-4">(4)</a>.  Let
the \( x \) values be as in <a href="#sec:plot:ex1">Exercise 1: Fill lists with function values</a>.  Create empty <code>x</code>
and <code>y</code> arrays and compute each element in <code>x</code> and <code>y</code> with a <code>for</code>
loop.
Filename: <code>fill_arrays_loop.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex2b">Exercise 3: Fill arrays; vectorized version<a name="sec:plot:ex2b"></a></h2>

Vectorize the code in <a href="#sec:plot:ex2">Exercise 2: Fill arrays; loop version</a> by creating the \( x \)
values using the <code>linspace</code> function from the <code>numpy</code> package and by
evaluating \( h(x) \) for an array argument.
Filename: <code>fill_arrays_vectorized.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex2c">Exercise 4: Plot a function<a name="sec:plot:ex2c"></a></h2>

Make a plot of the function in <a href="#sec:plot:ex1">Exercise 1: Fill lists with function values</a>
for \( x\in [-4,4] \).
Filename: <code>plot_Gaussian.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:math:ex1">Exercise 5: Apply a function to a vector<a name="sec:plot:math:ex1"></a></h2>

Given a vector \( v=(2,3,-1) \) and a function \( f(x)=x^3 + xe^x + 1 \),
apply \( f \) to each element in \( v \). Then calculate by hand \( f(v) \) as the
NumPy expression <code>v**3 + v*exp(v) + 1</code> using vector computing rules.
Demonstrate that the two results are equal.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex3">Exercise 6: Simulate by hand a vectorized expression<a name="sec:plot:ex3"></a></h2>

Suppose <code>x</code> and <code>t</code> are two arrays of the same length, entering a
vectorized expression

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">y <span style="color: #666666">=</span> cos(sin(x)) <span style="color: #666666">+</span> exp(<span style="color: #666666">1/</span>t)
</pre></div>
<p>
If <code>x</code> holds two elements, 0 and 2, and <code>t</code> holds the elements 1 and
1.5, calculate by hand (using a calculator) the <code>y</code> array. Thereafter,
write a program that mimics the series of computations you did by hand
(typically a sequence of operations of the kind we listed in the section <a href="#sec:plot:arraycomp">Vector arithmetics and vector functions</a> - use explicit loops, but at the end you can
use Numerical Python functionality to check the results).
Filename: <code>simulate_vector_computing.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex15d">Exercise 7: Demonstrate array slicing<a name="sec:plot:ex15d"></a></h2>

Create an array <code>w</code> with values \( 0,0.1,0.2,\ldots,3 \).  Write out
<code>w[:]</code>, <code>w[:-2]</code>, <code>w[::5]</code>, <code>w[2:-2:6]</code>.  Convince yourself in each
case that you understand which elements of the array that are printed.
Filename: <code>slicing.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex33">Exercise 8: Replace list operations by array computing<a name="sec:plot:ex33"></a></h2>

The data analysis problem in the section ref{sec:looplist:summary:ex}
is solved by list operations. Convert the list to a two-dimensional
array and perform the computations using array operations (i.e., no explicit
loops, but you need a loop to make the printout).
Filename: <code>sun_data_vec.py</code>.

<p>
<!-- plot it! -->
<!-- Bouncing ball: reduce \( v_0 \) by \( p \) every bounce, define the function!!! -->

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex15">Exercise 9: Plot a formula<a name="sec:plot:ex15"></a></h2>

Make a plot of the function \( y(t)=v_0t - \frac{1}{2}gt^2 \) for
\( v_0=10 \), \( g=9.81 \), and \( t\in [0,2v_0/g] \).  Set the axes labels as
<code>time (s)</code> and <code>height (m)</code>.
Filename: <code>plot_ball1.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex15b">Exercise 10: Plot a formula for several parameters<a name="sec:plot:ex15b"></a></h2>

Make a program that reads a set of \( v_0 \) values from the command line
and plots the corresponding curves \( y(t)=v_0t - \frac{1}{2}gt^2 \) in
the same figure, with \( t\in [0,2v_0/g] \) for each curve.  Set \( g=9.81 \).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
You need a different vector of \( t \) coordinates for each curve.

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>plot_ball2.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex15ba">Exercise 11: Specify the extent of the axes in a plot<a name="sec:plot:ex15ba"></a></h2>

Extend the program from <a href="#sec:plot:ex15b">Exercise 10: Plot a formula for several parameters</a> such that the
minimum and maximum \( t \) and \( y \) values are computed, and use the
extreme values to specify the extent of the axes. Add some
space above the highest curve to make the plot look better.
Filename: <code>plot_ball3.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex15c">Exercise 12: Plot exact and inexact Fahrenheit-Celsius conversion formulas<a name="sec:plot:ex15c"></a></h2>

A simple rule to quickly compute the Celsius temperature from the
Fahrenheit degrees is to subtract 30 and then divide by 2: \( C =
(F-30)/2 \).  Compare this curve against the exact curve \( C = (F-32)5/9 \)
in a plot. Let \( F \) vary between \( -20 \) and \( 120 \).
Filename: <code>f2c_shortcut_plot.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex5">Exercise 13: Plot the trajectory of a ball<a name="sec:plot:ex5"></a></h2>

The formula for the trajectory of a ball is given by

$$
\begin{equation}
f(x) = x\tan\theta - {1\over 2v_0^2}{gx^2\over\cos^2\theta} + y_0,
\tag{5}
\end{equation}
$$

where \( x \) is a coordinate along the ground, \( g \) is the acceleration
of gravity, \( v_0 \) is the size of the initial velocity, which makes an
angle \( \theta \) with the \( x \) axis, and \( (0,y_0) \) is the initial position
of the ball.

<p>
In a program, first read the input data \( y_0 \), \( \theta \), and \( v_0 \)
from the command line.  Then plot the trajectory \( y=f(x) \) for \( y\geq
0 \).
Filename: <code>plot_trajectory.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:files:ex12">Exercise 14: Plot data in a two-column file<a name="sec:files:ex12"></a></h2>

The file <a href="http://tinyurl.com/pwyasaa/plot/xy.dat" target="_self"><tt>src/plot/xy.dat</tt></a> contains two
columns of numbers, corresponding to \( x \) and \( y \) coordinates on a
curve. The start of the file looks as this:

<p>

<!-- code=text (!bc dat) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">     -1.0000       -0.0000
     -0.9933       -0.0087
     -0.9867       -0.0179
     -0.9800       -0.0274
     -0.9733       -0.0374
</pre></div>
<p>
Make a program that reads the first column into a list <code>x</code> and
the second column into a list <code>y</code>. Plot
the curve. Print out the mean \( y \) value as well as the
maximum and minimum \( y \) values.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Read the file line by line, split each line
into words, convert to <code>float</code>, and append to <code>x</code> and <code>y</code>.
The computations with <code>y</code> are simpler if the list is converted
to an array.

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>read_2columns.py</code>.

<p>
<!-- Closing remarks for this Exercise -->

<h3 id="___sec86">Remarks <a name="___sec86"></a></h3>

The function <code>loadtxt</code> in <code>numpy</code> can read files with tabular data
(any number of columns) and return the data in a two-dimensional
array:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
data <span style="color: #666666">=</span> np<span style="color: #666666">.</span>loadtxt(<span style="color: #BA2121">&#39;xy.dat&#39;</span>, dtype<span style="color: #666666">=</span>np<span style="color: #666666">.</span>float)  <span style="color: #408080; font-style: italic"># read table of floats</span>
x <span style="color: #666666">=</span> data[:,<span style="color: #666666">0</span>]  <span style="color: #408080; font-style: italic"># column with index 0</span>
y <span style="color: #666666">=</span> data[:,<span style="color: #666666">1</span>]  <span style="color: #408080; font-style: italic"># column with index 1</span>
</pre></div>
<p>
The present exercise asks you to implement a simplified version
of <code>loadtxt</code>, but for later loading of a file with tabular data into
an array you will certainly use <code>loadtxt</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:files:ex12e">Exercise 15: Write function data to file<a name="sec:files:ex12e"></a></h2>

We want to dump \( x \) and \( f(x) \) values to a file, where the \( x \) values
appear in the first column and the \( f(x) \) values appear in the
second. Choose \( n \) equally spaced \( x \) values in the interval \( [a,b] \).
Provide \( f \), \( a \), \( b \), \( n \), and the filename as input data on the
command line.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Use the <code>StringFunction</code> tool (see the sections ref{sec:input:StringFunction} and
<a href="#sec:plot:StringFunction:vectorize">Vectorization of StringFunction objects</a>) to turn the textual expression
for \( f \) into a Python function. (Note that the program from <a href="#sec:files:ex12">Exercise 14: Plot data in a two-column file</a> can be used to read the file generated in the
present exercise into arrays again for visualization of the curve
\( y=f(x) \).)

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>write_cml_function.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:files:ex12c">Exercise 16: Plot data from a file<a name="sec:files:ex12c"></a></h2>

The files <code>density_water.dat</code> and <code>density_air.dat</code> files in the
folder <a href="http://tinyurl.com/pwyasaa/plot" target="_self"><tt>src/plot</tt></a> contain data about the density
of water and air (respectively) for different temperatures. The data
files have some comment lines starting with <code>#</code> and some lines are
blank. The rest of the lines contain density data: the temperature in
the first column and the corresponding density in the second column.
The goal of this exercise is to read the data in such a file and plot
the density versus the temperature as distinct (small) circles for
each data point.  Let the program take the name of the data file as
command-line argument.  Apply the program to both files.
Filename: <code>read_density_data.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:files:ex12c2">Exercise 17: Fit a polynomial to data points<a name="sec:files:ex12c2"></a></h2>

The purpose of this exercise is to find a simple mathematical formula
for how the density of water or air depends on the temperature.
The idea is to load density and temperature data from file as
explained in <a href="#sec:files:ex12c">Exercise 16: Plot data from a file</a> and then apply some NumPy
utilities that can find a polynomial that approximates the density as
a function of the temperature.

<p>
NumPy has a function <code>polyfit(x, y, deg)</code> for finding a &quot;best fit&quot;
of a polynomial of degree <code>deg</code> to a set of data points given by the
array arguments <code>x</code> and <code>y</code>. The <code>polyfit</code> function returns a list of
the coefficients in the fitted polynomial, where the first element is
the coefficient for the term with the highest degree, and the last
element corresponds to the constant term. For example, given points in
<code>x</code> and <code>y</code>, <code>polyfit(x, y, 1)</code> returns the coefficients <code>a, b</code> in a
polynomial <code>a*x + b</code> that fits the data in the best way.  (More
precisely, a line \( y=ax+b \) is a &quot;best fit&quot; to the data points
\( (x_i,y_i) \), \( i=0,\ldots,n-1 \) if \( a \) and \( b \) are chosen to make the
sum of squared errors \( R=\sum_{j=0}^{n-1} (y_j - (ax_j + b))^2 \) as
small as possible.  This approach is known as <em>least squares
approximation</em> to data and proves to be extremely useful throughout
science and technology.)

<p>
NumPy also has a utility <code>poly1d</code>, which can take the tuple or list of
coefficients calculated by, e.g., <code>polyfit</code> and return the polynomial
as a Python function that can be evaluated. The following code snippet
demonstrates the use of <code>polyfit</code> and <code>poly1d</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">coeff <span style="color: #666666">=</span> polyfit(x, y, deg)
p <span style="color: #666666">=</span> poly1d(coeff)
<span style="color: #008000; font-weight: bold">print</span> p             <span style="color: #408080; font-style: italic"># prints the polynomial expression</span>
y_fitted <span style="color: #666666">=</span> p(x)     <span style="color: #408080; font-style: italic"># computes the polynomial at the x points</span>
<span style="color: #408080; font-style: italic"># use red circles for data points and a blue line for the polynomial</span>
plot(x, y, <span style="color: #BA2121">&#39;ro&#39;</span>, x, y_fitted, <span style="color: #BA2121">&#39;b-&#39;</span>,
     legend<span style="color: #666666">=</span>(<span style="color: #BA2121">&#39;data&#39;</span>, <span style="color: #BA2121">&#39;fitted polynomial of degree </span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> deg))
</pre></div>
<p>
<b>a)</b>
Write a function <code>fit(x, y, deg)</code> that creates a plot of data
in <code>x</code> and <code>y</code> arrays along with polynomial approximations of
degrees collected in the list <code>deg</code> as explained above.

<p>
<b>b)</b>
We want to call <code>fit</code> to make a plot of the density of water versus
temperature and another plot of the density of air versus
temperature. In both calls, use <code>deg=[1,2]</code> such that we can compare
linear and quadratic approximations to the data.

<p>
<b>c)</b>
From a visual inspection of the plots, can you suggest simple
mathematical formulas that relate the density of
air to temperature and the density of water to temperature?

<p>
Filename: <code>fit_density_data.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:files:ex19">Exercise 18: Fit a polynomial to experimental data<a name="sec:files:ex19"></a></h2>

Suppose we have measured the oscillation period \( T \) of a simple
pendulum with a mass \( m \) at the end of a massless rod of length
\( L \). We have varied \( L \) and recorded the corresponding \( T \) value. The
measurements are found in a file <a href="http://tinyurl.com/pwyasaa/plot/pendulum.dat" target="_self"><tt>src/plot/pendulum.dat</tt></a>.  The first column in the file
contains \( L \) values and the second column has the corresponding \( T \)
values.

<p>
<b>a)</b>
Plot \( L \) versus \( T \) using circles for the data points.

<p>
<b>b)</b>
We shall assume that \( L \) as a function of \( T \) is a polynomial.
Use the NumPy utilities <code>polyfit</code> and <code>poly1d</code>, as explained in
<a href="#sec:files:ex12c2">Exercise 17: Fit a polynomial to data points</a>, to fit polynomials of degree 1, 2, and
3 to the \( L \) and \( T \) data.  Visualize the polynomial curves together
with the experimental data. Which polynomial fits the measured data
best?

<p>
Filename: <code>fit_pendulum_data.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:files:ex22">Exercise 19: Read acceleration data and find velocities<a name="sec:files:ex22"></a></h2>

A file <a href="http://tinyurl.com/pwyasaa/plot/acc.dat" target="_self"><tt>src/plot/acc.dat</tt></a> contains
measurements \( a_0,a_1,\ldots,a_{n-1} \) of the acceleration of an object
moving along a straight line. The measurement \( a_k \) is taken at time
point \( t_k=k\Delta t \), where \( \Delta t \) is the time spacing between
the measurements.  The purpose of the exercise is to load the
acceleration data into a program and compute the velocity \( v(t) \) of
the object at some time \( t \).

<p>
In general, the acceleration \( a(t) \) is related to the velocity \( v(t) \)
through \( v'(t)=a(t) \). This means that

$$
\begin{equation} v(t) = v(0) + \int_0^t a(\tau) d\tau\tp
\tag{6}
\end{equation}
$$

If \( a(t) \) is only known at some discrete, equally spaced points in time,
\( a_0,\ldots,a_{n-1} \) (which is the case in this exercise), we must
compute the integral in <a href="#mjx-eqn-6">(6)</a> numerically, for example
by the Trapezoidal rule:

$$
\begin{equation}
v(t_k) \approx \Delta t\left( \frac{1}{2}a_0 + \frac{1}{2}a_{k}
+ \sum_{i=1}^{k-1} a_i\right),\quad 1 \leq k \leq n-1\tp
\tag{7}
\end{equation}
$$

We assume \( v(0)=0 \) so that also \( v_0=0 \).

<p>
Read the values \( a_0,\ldots,a_{n-1} \) from file into an array, plot the
acceleration versus time, and use <a href="#mjx-eqn-7">(7)</a> to
compute one \( v(t_k) \) value, where \( \Delta t \) and \( k\geq 1 \) are
specified on the command line.
Filename: <code>acc2vel_v1.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:files:ex23">Exercise 20: Read acceleration data and plot velocities<a name="sec:files:ex23"></a></h2>

The task in this exercise is the same as in <a href="#sec:files:ex22">Exercise 19: Read acceleration data and find velocities</a>, except that we now want to compute \( v(t_k) \) for
all time points \( t_k=k\Delta t \) and plot the velocity versus time.
Now only \( \Delta t \) is given on the command line, and the \( a_0,\ldots,
a_{n-1} \) values must be read from file as in <a href="#sec:files:ex22">Exercise 19: Read acceleration data and find velocities</a>.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Repeated use of <a href="#mjx-eqn-7">(7)</a> for all \( k \) values
is very inefficient. A more efficient formula arises if we add the area of
a new trapezoid to the previous
integral (see also the section ref{sec:diffeq:integral}):

$$
\begin{equation}
v(t_{k}) = v(t_{k-1}) + \int\limits_{t_{k-1}}^{t_k} a(\tau) d\tau
\approx v(t_{k-1}) + \Delta t \frac{1}{2}(a_{k-1} + a_{k}),
\end{equation}
$$

for \( k=1,2,\ldots,n-1 \), while
\( v_0=0 \).
Use this formula to fill an array <code>v</code> with velocity values.

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>acc2vel.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:files:ex24">Exercise 21: Plot a trip's path and velocity from GPS coordinates<a name="sec:files:ex24"></a></h2>

A GPS device measures your position at every \( s \) seconds.  Imagine
that the positions corresponding to a specific trip are stored as
\( (x,y) \) coordinates in a file <a href="http://tinyurl.com/pwyasaa/plot/pos.dat" target="_self"><tt>src/plot/pos.dat</tt></a> with an \( x \) and \( y \) number on each line,
except for the first line, which contains the value of \( s \).

<p>
<b>a)</b>
Plot the two-dimensional curve of
corresponding to the data in the file.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Load \( s \) into a <code>float</code> variable
and then the \( x \) and \( y \) numbers into two arrays. Draw a straight line
between the points, i.e., plot the \( y \) coordinates versus the \( x \)
coordinates.

<p>
<!-- --- end hint in exercise --- -->

<p>
<b>b)</b>
Plot the velocity in \( x \) direction versus time in one plot and the
velocity in \( y \) direction versus time in another plot.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
If \( x(t) \) and \( y(t) \) are the coordinates of the positions as a function
of time, we have that the velocity in \( x \) direction is \( v_x(t)=dx/dt \),
and the velocity in \( y \) direction is \( v_y=dy/dt \).
Since \( x \) and \( y \) are only known for some discrete times,
\( t_k=ks \), \( k=0,\ldots,n-1 \), we must use numerical differentiation. A
simple (forward) formula is

$$
\begin{equation*} v_x(t_k) \approx {x(t_{k+1})-x(t_k)\over s},\quad
v_y(t_k) \approx {y(t_{k+1})-y(t_k)\over s},\quad k=0,\ldots,n-2\tp \end{equation*}
$$

Compute arrays <code>vx</code> and <code>vy</code> with velocities based on the
formulas above for
\( v_x(t_k) \) and \( v_y(t_k) \), \( k=0,\ldots,n-2 \).

<p>
<!-- --- end hint in exercise --- -->

<p>
Filename: <code>position2velocity.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:class:exer:sum">Exercise 22: Vectorize the Midpoint rule for integration<a name="sec:class:exer:sum"></a></h2>

The Midpoint rule for approximating an integral can be expressed as
$$
\begin{equation}
\int_a^b f(x)dx \approx h\sum_{i=1}^n f(a - \frac{1}{2}h + ih),
\end{equation}
$$

where \( h=(b-a)/n \).

<p>
<b>a)</b>
Write a function <code>midpointint(f, a, b, n)</code> to compute
Midpoint rule. Use a plain Python <code>for</code> loop to implement the sum.

<p>
<b>b)</b>
Make a vectorized implementation of the Midpoint rule where you
compute the sum by Python's built-in function <code>sum</code>.

<p>
<b>c)</b>
Make another vectorized implementation of the Midpoint rule where you
compute the sum by the <code>sum</code> function in the <code>numpy</code> package.

<p>
<b>d)</b>
Organize the three implementations above in a module file <code>midpoint_vec.py</code>.

<p>
<b>e)</b>
Start IPython, import the functions from <code>midpoint_vec.py</code>,
define some Python implementation of a mathematical function \( f(x) \)
to integrate, and use the <code>%timeit</code> feature of IPython to measure
the efficiency of the three alternative implementations.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
The <code>%timeit</code> feature is described in
the
document <a href="http://tcse6.on.net/timing" target="_self">Evaluating the efficiency of Python programs</a> <a href="#Langtangen_TCSE6_timing">[4]</a>.

<p>
<!-- --- end hint in exercise --- -->

<p>
Filename: <code>midpoint_vec.py</code>.

<p>
<!-- Closing remarks for this Exercise -->

<h3 id="___sec95">Remarks <a name="___sec95"></a></h3>

The lesson learned from the experiments in e) is that <code>numpy.sum</code> is
much more efficient than Python's built-in function <code>sum</code>. Vectorized
implementations must always make use of <code>numpy.sum</code> to compute sums.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:class:ex27a">Exercise 23: Implement Lagrange's interpolation formula<a name="sec:class:ex27a"></a></h2>

Imagine we have \( n+1 \) measurements of some quantity \( y \) that depends
on \( x \): \( (x_0,y_0), (x_1,y_1),\ldots,(x_{n}, y_n) \). We may think of
\( y \) as a function of \( x \) and ask what \( y \) is at some arbitrary point
\( x \) not coinciding with any of the points \( x_0,\ldots,x_n \).  It is not
clear how \( y \) varies between the measurement points, but we can
make assumptions or models for this behavior. Such a problem
is known as <em>interpolation</em>.

<p>
One way to solve the interpolation problem is to fit a continuous
function that goes through all the \( n+1 \) points and then evaluate this
function for any desired \( x \).  A candidate for such a function is the
polynomial of degree \( n \) that goes through all the points. It turns
out that this polynomial can be written

$$
\begin{equation}
p_L(x) = \sum_{k=0}^n y_kL_k(x),
\tag{8}
\end{equation}
$$

where

$$
\begin{equation} L_k(x) =
\prod_{i=0,i\neq k}^n\frac{x-x_i}{x_k -x_i}
\tag{9} \thinspace .
\end{equation}
$$

The \( \prod \) notation corresponds to \( \sum \), but the terms are multiplied.
For example,

$$
\begin{equation*} \prod_{i=0,i\neq k}^n x_i = x_0x_1\cdots x_{k-1}x_{k+1}\cdots x_n\thinspace .
\end{equation*}
$$

The polynomial \( p_L(x) \) is known as Lagrange's interpolation formula,
and the points \( (x_0,y_0),\ldots,(x_n,y_n) \) are called interpolation points.

<p>
<b>a)</b>
Make functions <code>p_L(x, xp, yp)</code> and <code>L_k(x, k, xp, yp)</code>
that evaluate \( p_L(x) \) and \( L_k(x) \) by <a href="#mjx-eqn-8">(8)</a>
and <a href="#mjx-eqn-9">(9)</a>, respectively,
at the point <code>x</code>. The arrays <code>xp</code> and <code>yp</code>
contain the \( x \) and \( y \) coordinates of the \( n+1 \) interpolation points,
respectively. That is, <code>xp</code> holds \( x_0,\ldots,x_n \), and <code>yp</code>
holds \( y_0,\ldots,y_n \).

<p>
<b>b)</b>
To verify the program, we observe that \( L_k(x_k)=1 \) and that
\( L_k(x_i)=0 \) for \( i\neq k \), implying that \( p_L(x_k)=y_k \).  That is,
the polynomial \( p_L \) goes through all the points
\( (x_0,y_0),\ldots,(x_n,y_n) \).  Write a function <code>test_p_L(xp, yp)</code>
that computes \( |p_L(x_k)-y_k| \) at all the interpolation points
\( (x_k,y_k) \) and checks that the value is approximately zero.  Call
<code>test_p_L</code> with <code>xp</code> and <code>yp</code> corresponding to \( 5 \) equally
spaced points along the curve \( y=\sin(x) \) for \( x\in [0,\pi] \).
Thereafter, evaluate \( p_L(x) \) for an \( x \) in the middle of two
interpolation points and compare the value of \( p_L(x) \) with the exact
one.

<p>
Filename: <code>Lagrange_poly1.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:class:ex27b">Exercise 24: Plot Lagrange's interpolating polynomial<a name="sec:class:ex27b"></a></h2>

<b>a)</b>
Write a function <code>graph(f, n, xmin, xmax, resolution=1001)</code> for
plotting \( p_L(x) \) in <a href="#sec:class:ex27a">Exercise 23: Implement Lagrange's interpolation formula</a>,
based on interpolation points taken from some mathematical function
\( f(x) \) represented by the argument <code>f</code>. The argument <code>n</code>
denotes the number of interpolation points sampled from the \( f(x) \)
function, and <code>resolution</code> is the number of points between
<code>xmin</code> and <code>xmax</code> used to plot \( p_L(x) \).  The \( x \) coordinates
of the <code>n</code> interpolation points can be uniformly distributed
between <code>xmin</code> and <code>xmax</code>. In the graph, the interpolation
points \( (x_0,y_0),\ldots,(x_n,y_n) \) should be marked by small
circles.  Test the <code>graph</code> function by choosing 5
points in \( [0,\pi] \) and <code>f</code> as \( \sin x \).

<p>
<b>b)</b>
Make a module <code>Lagrange_poly2</code> containing the <code>p_L</code>,
<code>L_k</code>, <code>test_p_L</code>, and <code>graph</code> functions. The call to
<code>test_p_L</code> described in <a href="#sec:class:ex27a">Exercise 23: Implement Lagrange's interpolation formula</a> and the
call to <code>graph</code> described above should appear in the module's test block.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
the section ref{sec:input:modules} describes how to make a module.
In particular, a test block is explained in the section ref{sec:input:module:testblock}, test functions like <code>test_p_L</code>
are demonstrated in the section ref{sec:input:modules:testfunc}
and also in the section ref{sec:funcif:summary:ex},
and how to combine <code>test_p_L</code> and <code>graph</code> calls in the
test block is exemplified in the section ref{sec:input:modules:inputdata}.

<p>
<!-- --- end hint in exercise --- -->

<p>
Filename: <code>Lagrange_poly2.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:class:ex27c">Exercise 25: Investigate the behavior of Lagrange's interpolating polynomials<a name="sec:class:ex27c"></a></h2>

Unfortunately, the polynomial \( p_L(x) \) defined and implemented in
<a href="#sec:class:ex27a">Exercise 23: Implement Lagrange's interpolation formula</a> can exhibit some undesired oscillatory
behavior that we shall explore graphically in this exercise.  Call
the <code>graph</code> function from <a href="#sec:class:ex27b">Exercise 24: Plot Lagrange's interpolating polynomial</a> with
\( f(x)=|x| \), \( x\in [-2,2] \), for \( n=2,4,6,10 \). All the graphs of
\( p_L(x) \) should appear in the same plot for comparison. In addition,
make a new figure with calls to <code>graph</code> for \( n=13 \) and \( n=20 \). All the
code necessary for solving this exercise should appear in some
separate program file, which imports the <code>Lagrange_poly2</code> module made
in <a href="#sec:class:ex27b">Exercise 24: Plot Lagrange's interpolating polynomial</a>.
Filename: <code>Lagrange_poly2b.py</code>.

<p>
<!-- Closing remarks for this Exercise -->

<h3 id="___sec99">Remarks <a name="___sec99"></a></h3>

The purpose of the \( p_L(x) \) function is to compute \( (x,y) \) between
some given (often measured) data points \( (x_0,y_0),\ldots,(x_n,y_n) \).
We see from the graphs that for a small number of interpolation
points, \( p_L(x) \) is
quite close to the curve \( y=|x| \) we used to generate the data points,
but as \( n \) increases, \( p_L(x) \) starts to oscillate, especially toward
the end points \( (x_0,y_0) \) and \( (x_n,y_n) \). Much research has
historically been focused on methods that do not result in such
strange oscillations when fitting a polynomial to a set of points.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex5d">Exercise 26: Plot a wave packet<a name="sec:plot:ex5d"></a></h2>

The function

$$
\begin{equation}
f(x, t) = e^{-(x-3t)^2}\sin\left( 3\pi (x-t)\right)
\end{equation}
$$

describes for a fixed value of \( t \) a wave localized in space.  Make a
program that visualizes this function as a function of \( x \) on the
interval \( [-4,4] \) when \( t=0 \).
Filename: <code>plot_wavepacket.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex7">Exercise 27: Judge a plot<a name="sec:plot:ex7"></a></h2>

Assume you have the following program for plotting a parabola:

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, <span style="color: #666666">2</span>, <span style="color: #666666">20</span>)
y <span style="color: #666666">=</span> x<span style="color: #666666">*</span>(<span style="color: #666666">2</span> <span style="color: #666666">-</span> x)
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
plt<span style="color: #666666">.</span>plot(x, y)
plt<span style="color: #666666">.</span>show()
</pre></div>
<p>
Then you switch to the function \( \cos (18\pi x) \) by altering the
computation of <code>y</code> to <code>y = cos(18*pi*x)</code>.  Judge the resulting
plot. Is it correct?  Display the \( \cos (18\pi x) \) function with 1000
points in the same plot.
Filename: <code>judge_plot.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex13c">Exercise 28: Plot the viscosity of water<a name="sec:plot:ex13c"></a></h2>

The viscosity of water, \( \mu \), varies with the temperature \( T \) (in
Kelvin) according to

$$
\begin{equation}
\mu (T) = A\cdot 10^{B/(T-C)},
\end{equation}
$$

where \( A=2.414\cdot 10^{-5}\hbox{ Pa s} \), \( B=247.8 \) K, and \( C=140 \)
K. Plot \( \mu (T) \) for \( T \) between 0 and 100 degrees Celsius. Label the
\( x \) axis with 'temperature (C)' and the \( y \) axis with 'viscosity (Pa
s)'. Note that \( T \) in the formula for \( \mu \) must be in Kelvin.
Filename: <code>water_viscosity.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex16">Exercise 29: Explore a complicated function graphically<a name="sec:plot:ex16"></a></h2>

The wave speed \( c \) of water surface waves depends on the length
\( \lambda \) of the waves.  The following formula relates \( c \) to
\( \lambda \):

$$
\begin{equation}
c(\lambda) =
\sqrt{{g\lambda\over 2\pi}\left( 1 + s{4\pi^2\over\rho g \lambda^2}\right)
\tanh\left( {2\pi h\over\lambda}\right)}\tp
\end{equation}
$$

Here, \( g \) is the acceleration of gravity (\( 9.81\hbox{ m/s}^2 \)), \( s \) is
the air-water surface tension (\( 7.9\cdot 10^{-2} \hbox{ N/m} \)) ,
\( \rho \) is the density of water (can be taken as \( 1000 \hbox{
kg/m}^3 \)), and \( h \) is the water depth.  Let us fix \( h \) at 50 m.  First
make a plot of \( c(\lambda) \) (in m/s) for small \( \lambda \) (0.001 m to
0.1 m).  Then make a plot \( c(\lambda) \) for larger \( \lambda \) (1 m to 2
km.
Filename: <code>water_wave_velocity.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex5b">Exercise 30: Plot Taylor polynomial approximations to \( \sin x \)<a name="sec:plot:ex5b"></a></h2>

The sine function can be approximated by a polynomial according to the
following formula:

$$
\begin{equation}
\sin x \approx S(x;n) = \sum_{j=0}^{n} (-1)^j {x^{2j+1}\over (2j+1)!}\tp
\tag{10}
\end{equation}
$$

The expression \( (2j+1)! \) is the factorial (<code>math.factorial</code> can
compute this quantity).
The error in the approximation \( S(x;n) \) decreases as \( n \) increases and
in the limit we have that \( \lim_{n\rightarrow\infty} S(x;n) = \sin x \).
The purpose of this exercise is to visualize the quality of various
approximations \( S(x;n) \) as \( n \) increases.

<p>
<b>a)</b>
Write a Python function <code>S(x, n)</code> that computes \( S(x;n) \).
Use a straightforward approach where you compute each
term as it stands in the formula, i.e., \( (-1)^j x^{2j+1} \) divided
by the factorial \( (2j+1)! \).
(We remark that ref{sec:diffeq:ex11b}
outlines a much more efficient computation of the terms in the series.)

<p>
<b>b)</b>
Plot \( \sin x \) on \( [0,4\pi] \) together
with the approximations \( S(x;1) \), \( S(x;2) \), \( S(x;3) \), \( S(x;6) \), and \( S(x;12) \).

<p>
Filename: <code>plot_Taylor_sin.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex5e">Exercise 31: Animate a wave packet<a name="sec:plot:ex5e"></a></h2>

Display an animation of the function \( f(x,t) \) in <a href="#sec:plot:ex5d">Exercise 26: Plot a wave packet</a> by plotting \( f \) as a function of \( x \) on \( [-6,6] \)
for a set of \( t \) values in \( [-1,1] \). Also make an animated GIF file.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
A suitable resolution can be 1000 intervals (1001 points)
along the \( x \) axis, 60 intervals (61 points) in
time, and 6 frames per second in the animated GIF file.
Use the recipe in the section <a href="#easyviz:movie">Making animations</a> and remember to remove
the family of old plot files in the beginning of the program.

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>plot_wavepacket_movie.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex32">Exercise 32: Animate a smoothed Heaviside function<a name="sec:plot:ex32"></a></h2>

Visualize the smoothed Heaviside function \( H_{\epsilon}(x) \),
defined in the exercise &quot;Implement a
smoothed Heaviside function&quot; in the document <a href="http://tcse6.on.net/funcif" target="_self">Functions and
branching</a>, as an animation where
\( \epsilon \) starts at 2 and then goes to zero.
Filename: <code>smoothed_Heaviside_movie.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex18">Exercise 33: Animate two-scale temperature variations<a name="sec:plot:ex18"></a></h2>

We consider temperature oscillations in the ground as addressed in
the section <a href="#sec:plot:summarizing">Example: Animating a function</a>. Now we want to visualize daily and
annual variations. Let \( A_1 \) be the amplitude of annual variations and
\( A_2 \) the amplitude of the day/night variations.  Let also \( P_1 = 365 \)
days and \( P_2=24 \) h be the periods of the annual and the daily
oscillations.  The temperature at time \( t \) and depth \( z \) is then given
by

$$
\begin{equation}
T(z,t) = T_0 + A_1e^{-a_1z}\sin (\omega_1 t - a_1z) +
A_2e^{-a_2z}\sin (\omega_2 t - a_2z),
\end{equation}
$$

where

$$
\begin{align*}
 \omega_1 &= {2\pi P_1},\\ 
 \omega_2 &= {2\pi P_2},\\ 
 a_1 &=\sqrt{\omega_1\over 2k},\\ 
 a_2 &=\sqrt{\omega_2\over 2k}\tp\\ 
\end{align*}
$$

Choose \( k = 10^{-6} \hbox{ m}^2/\hbox{s} \), \( A_1=15 \) C,
\( A_2=7 \) C, and the resolution \( \Delta t \) as \( P_2/10 \).
Modify the <code>heatwave.py</code> program in order to
animate this new temperature function.
Filename: <code>heatwave2.py</code>.

<p>
<!-- Closing remarks for this Exercise -->

<h3 id="___sec108">Remarks <a name="___sec108"></a></h3>

We assume in this problem that the temperature
\( T \) equals the reference temperature \( T_0 \) at \( t=0 \), resulting in
a sine variation rather than the cosine variation in
<a href="#mjx-eqn-3">(3)</a>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex19">Exercise 34: Use non-uniformly distributed coordinates for visualization<a name="sec:plot:ex19"></a></h2>

Watching the animation in <a href="#sec:plot:ex18">Exercise 33: Animate two-scale temperature variations</a> reveals that
there are rapid oscillations in a small layer close to \( z=0 \).  The
variations away from \( z=0 \) are much smaller in time and space.  It
would therefore be wise to use more \( z \) coordinates close to \( z=0 \)
than for larger \( z \) values. Given a set \( x_0 < x_1 < \cdots < x_n \) of
uniformly spaced coordinates in \( [a, b] \), we can compute new
coordinates \( \bar x_i \), stretched toward \( x=a \), by the formula

$$
\begin{equation*} \bar x_i = a + (b-a)\left({x_i-a\over b-a}\right)^s,\end{equation*}
$$

for some \( s>1 \). In the present example, we can use this formula to stretch
the \( z \) coordinates to the left.

<p>
<b>a)</b>
Experiment with \( s\in [1.2,3] \) and few points
(say 15) and visualize the curve as a line with circles at the
points so that you can easily see the distribution of points toward
the left end. Identify a suitable value of \( s \).

<p>
<b>b)</b>
Run the animation with no circles and (say) 501 points
with the found \( s \) value.

<p>
Filename: <code>heatwave2a.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex31">Exercise 35: Animate a sequence of approximations to \( \pi \)<a name="sec:plot:ex31"></a></h2>

ref{sec:basic:ex25c} outlines an idea for approximating \( \pi \)
as the length of a polygon inside the circle. Wrap the code from
ref{sec:basic:ex25c} in a function <code>pi_approx(N)</code>, which
returns the approximation to \( \pi \) using a polygon with \( N+1 \) equally
distributed points. The task of the present exercise is to visually
display the polygons as a movie, where each frame shows the polygon
with \( N+1 \) points together with the circle and a title reflecting the
corresponding error in the approximate value of \( \pi \).  The whole
movie arises from letting \( N \) run through \( 4,5,6,\ldots,K \), where \( K \)
is some (large) prescribed value. Let there be a pause of 0.3 s
between each frame in the movie. By playing the movie you will see how
the polygons move closer and closer to the circle and how the
approximation to \( \pi \) improves.
Filename: <code>pi_polygon_movie.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex5g">Exercise 36: Animate a planet's orbit<a name="sec:plot:ex5g"></a></h2>

A planet's orbit around a star has the shape of an ellipse. The
purpose of this exercise is to make an animation of the movement along
the orbit.  One should see a small disk, representing the planet,
moving along an elliptic curve.  An evolving solid line shows the
development of the planet's orbit as the planet moves and the title
displays the planet's instantaneous velocity magnitude.  As a test,
run the special case of a circle and verify that the magnitude of the
velocity remains constant as the planet moves.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint 1.</b>
The points \( (x,y) \) along the ellipse are given
by the expressions

$$
\begin{equation*} x=a\cos (\omega t),\quad y = b\sin (\omega t),\end{equation*}
$$

where \( a \) is the semi-major axis of the ellipse, \( b \) is the semi-minor
axis, \( \omega \) is an angular velocity of the planet around the star,
and \( t \) denotes time. One complete orbit corresponds
to \( t\in [0, 2\pi/\omega] \). Let us discretize time into time points
\( t_k = k\Delta t \), where
\( \Delta t = 2\pi/(\omega n) \). Each frame in the movie corresponds to
\( (x,y) \) points along the curve with
\( t \) values \( t_0,t_1,\ldots,t_i \), \( i \) representing the frame number
(\( i=1,\ldots,n \)).

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint 2.</b>
The velocity vector is

$$
\begin{equation*} (\frac{dx}{dt}, \frac{dy}{dt}) = (-\omega a\sin(\omega t), \omega b\cos(\omega t)),\end{equation*}
$$

and the magnitude of this vector becomes
\( \omega\sqrt{a^2\sin^2(\omega t) + b^2\cos^2(\omega t)} \).

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>planet_orbit.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex17">Exercise 37: Animate the evolution of Taylor polynomials<a name="sec:plot:ex17"></a></h2>

A general series approximation (to a function) can be written as

$$
\begin{equation*}
S(x; M, N)=\sum_{k=M}^{N} f_k(x)\tp
\end{equation*}
$$

For example, the Taylor polynomial of degree \( N \) for \( e^x \) equals
\( S(x; 0, N) \) with \( f_k(x)=x^k/k! \).  The purpose of the exercise is to
make a movie of how \( S(x;M,N) \) develops and improves as an
approximation as we add terms in the sum. That is, the frames in the
movie correspond to plots of \( S(x; M, M) \), \( S(x; M, M+1) \), \( S(x;
M,M+2) \), \( \ldots \), \( S(x; M, N) \).

<p>
<b>a)</b>
Make a function

<p>

<!-- code=text (!bc ccq) typeset with pygments style "default" -->
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">animate_series(fk, M, N, xmin, xmax, ymin, ymax, n, exact)
</pre></div>
</blockquote><p>
for creating such animations. The argument <code>fk</code> holds a Python
function implementing the term \( f_k(x) \) in the sum, <code>M</code> and <code>N</code> are
the summation limits, the next arguments are the minimum and maximum
\( x \) and \( y \) values in the plot, <code>n</code> is the number of \( x \) points in the
curves to be plotted, and <code>exact</code> holds the function that \( S(x) \) aims
at approximating.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Here is some more information on how to write the <code>animate_series</code>
function. The function must accumulate the \( f_k(x) \) terms in a
variable \( s \), and for each \( k \) value, \( s \) is plotted against \( x \)
together with a curve reflecting the exact function.  Each plot must
be saved in a file, say with names <code>tmp_0000.png</code>, <code>tmp_0001.png</code>, and
so on (these filenames can be generated by <code>tmp_%04d.png</code>, using an
appropriate counter). Use the <code>movie</code> function to combine all the plot
files into a movie in a desired movie format.

<p>
In the beginning of the <code>animate_series</code> function, it is necessary to
remove all old plot files of the form <code>tmp_*.png</code>. This can be done by
the <code>glob</code> module and the <code>os.remove</code> function as exemplified in
the section <a href="#easyviz:movie">Making animations</a>.

<p>
<!-- --- end hint in exercise --- -->

<p>
<b>b)</b>
Call the <code>animate_series</code> function for the Taylor series for \( \sin x \),
where \( f_k(x) = (-1)^k {x^{2k+1}/(2k+1)!} \), and \( x\in [0,13\pi] \),
\( M=0 \), \( N=40 \), \( y\in [-2,2] \).

<p>
<b>c)</b>
Call the <code>animate_series</code> function for
the Taylor series for \( e^{-x} \), where \( f_k(x)=(-x)^k/k! \),
and \( x\in [0, 15] \), \( M=0 \), \( N=30 \), \( y\in [-0.5,1.4] \).

<p>
Filename: <code>animate_Taylor_series.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex4">Exercise 38: Plot the velocity profile for pipeflow<a name="sec:plot:ex4"></a></h2>

A fluid that flows through a (very long) pipe has zero velocity on the
pipe wall and a maximum velocity along the centerline of the pipe. The
velocity \( v \) varies through the pipe cross section according to the
following formula:

$$
\begin{equation}
v(r) = \left({\beta\over 2\mu_0}\right)^{{1/ n}}
{n \over n+1}\left( R^{1 + 1/n} - r^{1 + 1/n}\right),
\tag{11}
\end{equation}
$$

where \( R \) is the radius of the pipe, \( \beta \) is the pressure gradient
(the force that drives the flow through the pipe), \( \mu_0 \) is a
viscosity coefficient (small for air, larger for water and even larger
for toothpaste), \( n \) is a real number reflecting the viscous
properties of the fluid (\( n=1 \) for water and air, \( n < 1 \) for many modern
plastic materials), and \( r \) is a radial coordinate that measures the
distance from the centerline (\( r=0 \) is the centerline, \( r=R \) is the
pipe wall).

<p>
<b>a)</b>
Make a Python function that evaluates \( v(r) \).

<p>
<b>b)</b>
Plot \( v(r) \) as a function of
\( r\in [0,R] \), with \( R=1 \), \( \beta =0.02 \), \( \mu_0 =0.02 \), and \( n=0.1 \).

<p>
<b>c)</b>
Make an animation of how the \( v(r) \) curves
varies as \( n \) goes from 1 and down to 0.01. Because the maximum value of
\( v(r) \) decreases rapidly as \( n \) decreases, each curve can be normalized
by its \( v(0) \) value such that the maximum value is always unity.

<p>
Filename: <code>plot_velocity_pipeflow.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex8">Exercise 39: Plot sum-of-sines approximations to a function<a name="sec:plot:ex8"></a></h2>

ref{sec:formula:ex10} defines the approximation \( S(t;n) \) to a
function \( f(t) \).  Plot \( S(t;1) \), \( S(t;3) \), \( S(t;20) \), \( S(t;200) \), and
the exact \( f(t) \) function in the same plot. Use \( T=2\pi \).
Filename: <code>sinesum1_plot.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex8m">Exercise 40: Animate the evolution of a sum-of-sine approximation to a function<a name="sec:plot:ex8m"></a></h2>

First perform <a href="#sec:plot:ex8">Exercise 39: Plot sum-of-sines approximations to a function</a>.  A natural next step is to
animate the evolution of \( S(t;n) \) as \( n \) increases.  Create such an
animation and observe how the discontinuity in \( f(t) \) is poorly
approximated by \( S(t;n) \), even when \( n \) grows large (plot \( f(t) \) in
each frame).  This is a well-known deficiency, called Gibb's
phenomenon, when approximating discontinuous functions by sine or
cosine (Fourier) series.
Filename: <code>sinesum1_movie.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex14">Exercise 41: Plot functions from the command line<a name="sec:plot:ex14"></a></h2>

For quickly getting a plot a function \( f(x) \) for \( x\in [x_{\rm
min},x_{\rm max}] \) it could be nice to a have a program that takes the
minimum amount of information from the command line and produces a
plot on the screen and saves the plot to a file <code>tmp.png</code>.  The usage
of the program goes as follows:

<p>

<!-- code=text (!bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">plotf.py &quot;f(x)&quot; xmin xmax
</pre></div>
<p>
A specific example is

<p>

<!-- code=text (!bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">plotf.py &quot;exp(-0.2*x)*sin(2*pi*x)&quot; 0 4*pi
</pre></div>
<p>
Write the <code>plotf.py</code> program with as short code as possible (we leave
it to <a href="#sec:plot:ex14b">Exercise 42: Improve command-line input</a> to test for valid input).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Make \( x \) coordinates from the second and third command-line arguments and
then use <code>eval</code>
(or <code>StringFunction</code> from <code>scitools.std</code>,
see the sections ref{sec:input:StringFunction} and
<a href="#sec:plot:StringFunction:vectorize">Vectorization of StringFunction objects</a>)
on the first argument.

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>plotf.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex14b">Exercise 42: Improve command-line input<a name="sec:plot:ex14b"></a></h2>

Equip the program from <a href="#sec:plot:ex14">Exercise 41: Plot functions from the command line</a> with tests on valid
input on the command line. Also allow an optional fourth command-line
argument for the number of points along the function curve.  Set this
number to 501 if it is not given.
Filename: <code>plotf2.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex20">Exercise 43: Demonstrate energy concepts from physics<a name="sec:plot:ex20"></a></h2>

The vertical position \( y(t) \) of a ball thrown upward is given by \( y(t)
= v_0t - \frac{1}{2}gt^2 \), where \( g \) is the acceleration of gravity
and \( v_0 \) is the velocity at \( t=0 \).  Two important physical quantities
in this context are the potential energy, obtained by doing work
against gravity, and the kinetic energy, arising from motion.  The
potential energy is defined as \( P=mgy \), where \( m \) is the mass of the
ball. The kinetic energy is defined as \( K=\frac{1}{2}mv^2 \), where \( v \)
is the velocity of the ball, related to \( y \) by \( v(t)=y'(t) \).

<p>
Make a program that can plot \( P(t) \) and \( K(t) \) in the same plot, along
with their sum \( P+K \). Let \( t\in [0,2v_0/g] \). Read \( m \) and \( v_0 \) from
the command line. Run the program with various choices of \( m \) and
\( v_0 \) and observe that \( P+K \) is always constant in this motion. (In
fact, it turns out that \( P+K \) is constant for a large class of
motions, and this is a very important result in physics.)
Filename: <code>energy_physics.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:math:ex9">Exercise 44: Plot a w-like function<a name="sec:plot:math:ex9"></a></h2>

Define mathematically a function that looks like the &quot;w&quot; character.
Plot this function.
Filename: <code>plot_w.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:basic:exH4plot">Exercise 45: Plot a piecewise constant function<a name="sec:basic:exH4plot"></a></h2>

Consider the piecewise constant function defined in ref{sec:basic:exH4}. Make a Python function <code>plot_piecewise(data,
xmax)</code> that draws a graph of the function, where <code>data</code> is the nested
list explained in ref{sec:basic:exH4} and <code>xmax</code> is the
maximum \( x \) coordinate. Use ideas from the section <a href="#sec:plot:pwisefunc">Piecewisely defined functions</a>.
Filename: <code>plot_piecewise_constant.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:basic:exH4vecz1">Exercise 46: Vectorize a piecewise constant function<a name="sec:basic:exH4vecz1"></a></h2>

Consider the piecewise constant function defined in
ref{sec:basic:exH4}. Make a vectorized implementation
<code>piecewise_constant_vec(x, data, xmax)</code> of such a function, where
<code>x</code> is an array.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
You can use ideas from the <code>Nv1</code> function in the section <a href="#sec:vec:hatfunc">Vectorization of a hat function</a>.
However, since the number of intervals is not known, it is necessary to
store the various intervals and conditions in lists.

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>piecewise_constant_vec.py</code>.

<p>
<!-- Closing remarks for this Exercise -->

<h3 id="___sec122">Remarks <a name="___sec122"></a></h3>

Plotting the array returned from <code>piecewise_constant_vec</code> faces
the same problems as encountered in the section <a href="#sec:plot:pwisefunc">Piecewisely defined functions</a>.
It is better to make a custom plotting function that simply draws
straight horizontal lines in each interval (<a href="#sec:basic:exH4plot">Exercise 45: Plot a piecewise constant function</a>).

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex:vizmidpoint">Exercise 47: Visualize approximations in the Midpoint integration rule<a name="sec:plot:ex:vizmidpoint"></a></h2>

Consider the midpoint rule for
integration from ref{sec:basic:ex39c}.
Use Matplotlib to make an illustration of the midpoint rule
as shown to the left in Figure <a href="#sec:plot:ex:int:fig">12</a>.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 12:  Visualization of numerical integration rules, with the Midpoint rule to   the left and the Trapezoidal rule to the right.   The filled areas illustrate the deviations  in the approximation of the area under the curve. <a name="sec:plot:ex:int:fig"></a> </p></center>
<p><img src="fig-plot/viz_midpoint_trapez.png" align="bottom" width=400></p>
</center>

<p>
The \( f(x) \) function used
in Figure <a href="#sec:plot:ex:int:fig">12</a> is

$$
\begin{equation*} f(x) = x(12-x) + \sin(\pi x),\quad x\in[0,10]\tp\end{equation*}
$$


<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Look up the documentation of the Matplotlib function <code>fill_between</code>
and use this function to create the filled areas between \( f(x) \)
and the approximating rectangles.

<p>
Note that the <code>fill_between</code> requires the two curves to have the same
number of points.  For accurate visualization of \( f(x) \) you need quite
many \( x \) coordinates, and the rectangular approximation to \( f(x) \) must
be drawn using the same set of \( x \) coordinates.

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>viz_midpoint.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex:viztrapezoidal">Exercise 48: Visualize approximations in the Trapezoidal integration rule<a name="sec:plot:ex:viztrapezoidal"></a></h2>

Redo <a href="#sec:plot:ex:vizmidpoint">Exercise 47: Visualize approximations in the Midpoint integration rule</a> for the Trapezoidal rule
from ref{sec:basic:ex38}
to produce the graph shown to the right in Figure <a href="#sec:plot:ex:int:fig">12</a>.
Filename: <code>viz_trapezoidal.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex13">Exercise 49: Experience overflow in a function<a name="sec:plot:ex13"></a></h2>

We are give the mathematical function

$$
\begin{equation*} v(x)={1-e^{x/\mu}\over 1-e^{1/\mu}},\end{equation*}
$$

where \( \mu \) is a parameter.

<p>
<b>a)</b>
Make a Python function <code>v(x, mu=1E-6, exp=math.exp)</code> for calculating the
formula for \( v(x) \) using <code>exp</code> as a possibly user-given exponential
function.  Let the <code>v</code> function return the nominator and denominator
in the formula as well as the fraction.

<p>
<b>b)</b>
Call the <code>v</code> function for various <code>x</code> values between 0 and 1 in a
<code>for</code> loop, let <code>mu</code> be <code>1E-3</code>, and have an inner <code>for</code> loop over two
different <code>exp</code> functions: <code>math.exp</code> and <code>numpy.exp</code>.  The output
will demonstrate how the denominator is subject to overflow and how
difficult it is to calculate this function on a computer.

<p>
<b>c)</b>
Plot \( v(x) \) for \( \mu =1,0.01, 0.001 \) on \( [0,1] \) using 10,000 points
to see what the function looks like.

<p>
<b>d)</b>
Convert <code>x</code> and <code>eps</code> to a higher precision representation of
real numbers, with the aid of the NumPy type <code>float96</code>, before
calling <code>v</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span>
x <span style="color: #666666">=</span> numpy<span style="color: #666666">.</span>float96(x); mu <span style="color: #666666">=</span> numpy<span style="color: #666666">.</span>float96(e)
</pre></div>
<p>
Repeat point b) with these type of variables and observe how much better
results we get with <code>float96</code> compared with the standard <code>float</code> value,
which is <code>float64</code> (the number reflects the number of bits in the
machine's representation of a real number).

<p>
<b>e)</b>
Call the <code>v</code> function with <code>x</code> and <code>mu</code> as
<code>float32</code> variables and report how the function now behaves.

<p>
Filename: <code>boundary_layer_func1.py</code>.

<p>
<!-- Closing remarks for this Exercise -->

<h3 id="___sec126">Remarks <a name="___sec126"></a></h3>

When an object (ball, car, airplane) moves through the air, there is a
very, very thin layer of air close to the object's surface where the
air velocity varies dramatically, from the same value as the velocity
of the object at the object's surface to zero a few centimeters away.
This layer is called a <em>boundary layer</em>. The physics in the boundary
layer is important for air resistance and cooling/heating of objects.
The change in velocity in the boundary layer is quite abrupt and can
be modeled by the functiion \( v(x) \), where \( x=1 \) is the object's
surface, and \( x=0 \) is some distance away where one cannot notice any
wind velocity \( v \) because of the passing object (\( v= 0 \)).  The wind
velocity coincides with the velocity of the object at \( x=1 \), here set
to \( v=1 \).  The parameter \( \mu \) is very small and related to the
viscosity of air.  With a small value of \( \mu  \), it becomes difficult
to calculate \( v(x) \) on a computer. The exercise demonstrates the
difficulties and provides a remedy.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:math:ex2">Exercise 50: Apply a function to a rank 2 array<a name="sec:plot:math:ex2"></a></h2>

Let \( A \) be the two-dimensional array

$$
\begin{equation*}
\left\lbrack\begin{array}{ccc}
0 & 2 & -1  \\ 
-1 & -1 & 0 \\ 
0 & 5 & 0
\end{array}\right\rbrack
\end{equation*}
$$

Apply the function \( f \) from <a href="#sec:plot:math:ex1">Exercise 5: Apply a function to a vector</a>
to each element in \( A \). Then
calculate the result of the array expression <code>A**3 + A*exp(A) + 1</code>,
and demonstrate that the end result of the two methods are the same.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex11">Exercise 51: Explain why array computations fail<a name="sec:plot:ex11"></a></h2>

The following loop computes the array <code>y</code> from <code>x</code>:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #666666">&gt;&gt;&gt;</span> x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, <span style="color: #666666">3</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> y <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(<span style="color: #008000">len</span>(x))
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(x)):
<span style="color: #666666">...</span>     y[i] <span style="color: #666666">=</span> x[i] <span style="color: #666666">+</span> <span style="color: #666666">4</span>
</pre></div>
<p>
However, the alternative loop

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">for</span> xi, yi <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">zip</span>(x, y):
<span style="color: #666666">...</span>     yi <span style="color: #666666">=</span> xi <span style="color: #666666">+</span> <span style="color: #666666">5</span>
</pre></div>
<p>
leaves <code>y</code> unchanged. Why? Explain in detail what happens in each
pass of this loop and write down the contents of <code>xi</code>, <code>yi</code>,
<code>x</code>, and <code>y</code> as the loop progresses.

<p>
<!-- --- end exercise --- -->

<h1 id="___sec129">References <a name="___sec129"></a></h1>

<!-- begin bibliography -->

<ol>
 <li> <a name="Langtangen_TCSE6_random"></a> <b>H. P. Langtangen</b>. 
    Random numbers and simple games,
    <a href="http://tcse6.on.net/random" target="_self"><tt>http://tcse6.on.net/random</tt></a>.</li>
 <li> <a name="TCSE3"></a> <b>H. P. Langtangen</b>. 
    <em>Python Scripting for Computational Science</em>,
    Springer,
    2009.</li>
 <li> <a name="Langtangen_TCSE6_input"></a> <b>H. P. Langtangen</b>. 
    User input and error handling,
    <a href="http://tcse6.on.net/input" target="_self"><tt>http://tcse6.on.net/input</tt></a>.</li>
 <li> <a name="Langtangen_TCSE6_timing"></a> <b>H. P. Langtangen</b>. 
    Evaluating the efficiency of Python programs,
    <a href="http://tcse6.on.net/timing" target="_self"><tt>http://tcse6.on.net/timing</tt></a>.</li>
</ol>

<!-- end bibliography -->

<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pager">
</ul>
<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


</body>
</html>
    

