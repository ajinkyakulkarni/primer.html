<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Array computing and curve plotting">
<meta name="keywords" content="vectors,vector computing,scalar (math quantity),heterogeneous lists,Numerical Python,NumPy,array (datatype),array computing,vectorization,array slicing,subarrays,allocate,vectorization,scalar code,curve plotting,plotting,making graphs,backend (Easyviz),backend (Easyviz),remove files (in Python),delete files (in Python),boolean indexing,boolean indexing,in-place array arithmetics,check an object's type,shape (of an array),array shape,matrix,shape (of an array),array shape,eigenvalues,eigenvectors,inverse,determinant,rank of a matrix,least squares approximation,Trapezoidal rule for integration,Lagrange's interpolation formula,interpolation,Midpoint rule for integration,Trapezoidal rule for integration">

<title>Array computing and curve plotting</title>


<link href="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
code { padding: 0px; background-color: inherit; }
pre {
  border: 0pt solid #93a1a1;
  box-shadow: none;
}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [('Table of contents',
               1,
               'table_of_contents',
               'table_of_contents'),
              ('Vectors', 1, None, '___sec0'),
              ('The vector concept', 2, None, '___sec1'),
              ('Mathematical operations on vectors',
               2,
               'sec:plot:vectors',
               'sec:plot:vectors'),
              ('Vector arithmetics and vector functions',
               2,
               'sec:plot:arraycomp',
               'sec:plot:arraycomp'),
              ('Arrays in Python programs', 1, None, '___sec4'),
              ('Using lists for collecting function data',
               2,
               'sec:plot:listdata',
               'sec:plot:listdata'),
              ('Basics of numerical Python arrays',
               2,
               'sec:plot:array:basics',
               'sec:plot:array:basics'),
              ('Computing coordinates and function values',
               2,
               None,
               '___sec7'),
              ('Vectorization',
               2,
               'sec:plot:vectorization',
               'sec:plot:vectorization'),
              ('Curve plotting',
               1,
               'sec:plot:curveplots',
               'sec:plot:curveplots'),
              ('MATLAB-style plotting with Matplotlib',
               2,
               'sec:plot:pylab',
               'sec:plot:pylab'),
              ('A basic plot', 3, None, '___sec11'),
              ('Decorating the plot', 3, None, '___sec12'),
              ('Plotting multiple curves', 3, None, '___sec13'),
              ('Placing several plots in one figure', 3, None, '___sec14'),
              ('Matplotlib; pyplot prefix',
               2,
               'sec:plot:pyplot',
               'sec:plot:pyplot'),
              ('SciTools and Easyviz',
               2,
               'sec:plot:SciTools',
               'sec:plot:SciTools'),
              ('Importing SciTools and Easyviz', 3, None, '___sec17'),
              ('A basic plot', 3, None, '___sec18'),
              ('Decorating the plot', 3, None, '___sec19'),
              ('Plotting multiple curves', 3, None, '___sec20'),
              ('Changing backend', 3, None, '___sec21'),
              ('Placing several plots in one figure', 3, None, '___sec22'),
              ('Other plotting alternatives', 3, None, '___sec23'),
              ('Making animations', 2, 'easyviz:movie', 'easyviz:movie'),
              ('Example', 3, None, '___sec25'),
              ('Animation in Easyviz', 3, None, '___sec26'),
              ('Basic animation in Matplotlib', 3, None, '___sec27'),
              ('Using FuncAnimation in Matplotlib', 3, None, '___sec28'),
              ('Making videos', 2, 'sec:plot:video', 'sec:plot:video'),
              ('Animated GIF file', 3, None, '___sec30'),
              ('MP4, Ogg, WebM, and Flash videos', 3, None, '___sec31'),
              ('Curve plots in pure text', 2, None, '___sec32'),
              ('Plotting difficulties',
               1,
               'sec:plot:difficulties',
               'sec:plot:difficulties'),
              ('Piecewisely defined functions',
               2,
               'sec:plot:pwisefunc',
               'sec:plot:pwisefunc'),
              ('Example: The Heaviside function', 3, None, '___sec35'),
              ('Example: A hat function', 3, None, '___sec36'),
              ('Rapidly varying functions',
               2,
               'sec:plot:sin1x',
               'sec:plot:sin1x'),
              ('More advanced vectorization of functions',
               1,
               'sec:plot:if:vectorize',
               'sec:plot:if:vectorize'),
              ('Vectorization of StringFunction objects',
               2,
               'sec:plot:StringFunction:vectorize',
               'sec:plot:StringFunction:vectorize'),
              ('Vectorization of the Heaviside function',
               2,
               'sec:vec:Heaviside',
               'sec:vec:Heaviside'),
              ('Loop', 3, None, '___sec41'),
              ('Automatic vectorization', 3, None, '___sec42'),
              ('Mixing boolean and floating-point calculations',
               3,
               None,
               '___sec43'),
              ('Manual vectorization', 3, None, '___sec44'),
              ('Vectorization of a hat function',
               2,
               'sec:vec:hatfunc',
               'sec:vec:hatfunc'),
              ('More on numerical Python arrays',
               1,
               'sec:plot:numpy:more',
               'sec:plot:numpy:more'),
              ('Copying arrays', 2, None, '___sec47'),
              ('In-place arithmetics',
               2,
               'sec:plot:numpy:inplace',
               'sec:plot:numpy:inplace'),
              ('Allocating arrays', 2, None, '___sec49'),
              ('Generalized indexing',
               2,
               'sec:plot:generalized:index',
               'sec:plot:generalized:index'),
              ('Testing for the array type', 2, None, '___sec51'),
              ('Example: Vectorizing a constant function',
               3,
               None,
               '___sec52'),
              ('Compact syntax for array generation', 2, None, '___sec53'),
              ('Shape manipulation', 2, None, '___sec54'),
              ('High-performance computing with arrays',
               1,
               'sec:hpc',
               'sec:hpc'),
              ('Example: `axpy`', 3, None, '___sec56'),
              ('Scalar implementation',
               2,
               'sec:hpc:scalar',
               'sec:hpc:scalar'),
              ('Vectorized implementation', 2, 'sec:hpc:vec', 'sec:hpc:vec'),
              ('Memory-saving implementation',
               2,
               'sec:hpc:vec:inplace',
               'sec:hpc:vec:inplace'),
              ('Analysis of memory usage',
               2,
               'sec:hpc:vec:memory_profiler',
               'sec:hpc:vec:memory_profiler'),
              ('Analysis of the CPU time',
               2,
               'sec:hpc:vec:line_profiler',
               'sec:hpc:vec:line_profiler'),
              ('Higher-dimensional arrays',
               1,
               'sec:plot:2Darrays',
               'sec:plot:2Darrays'),
              ('Matrices and arrays', 2, None, '___sec63'),
              ('Two-dimensional numerical Python arrays',
               2,
               'sec:plot:2D:arrays',
               'sec:plot:2D:arrays'),
              ('Array computing',
               2,
               'sec:plot:array2comp',
               'sec:plot:array2comp'),
              ('Remark', 3, None, '___sec66'),
              ('Matrix objects',
               2,
               'sec:plot:numpy:matrix',
               'sec:plot:numpy:matrix'),
              ('Some common linear algebra operations', 1, None, '___sec68'),
              ('Inverse, determinant, and eigenvalues', 2, None, '___sec69'),
              ('Products', 2, None, '___sec70'),
              ('Norms', 2, None, '___sec71'),
              ('Sum and extreme values', 2, None, '___sec72'),
              ('Indexing', 2, None, '___sec73'),
              ('Transpose and upper/lower triangular parts',
               2,
               None,
               '___sec74'),
              ('Solving linear systems', 2, None, '___sec75'),
              ('Matrix row and column operations', 2, None, '___sec76'),
              ('Computing the rank of a matrix', 2, None, '___sec77'),
              ('Symbolic linear algebra', 2, None, '___sec78'),
              ('Plotting of scalar and vector fields',
               1,
               'plot:surf',
               'plot:surf'),
              ('Installation', 2, 'plot:surf:install', 'plot:surf:install'),
              ('Surface plots',
               2,
               'plot:surf:mesh_surf',
               'plot:surf:mesh_surf'),
              ('Grid for 2D scalar fields', 3, None, '___sec82'),
              ('Parameterized curve',
               2,
               'plot:surf:3Dcurve',
               'plot:surf:3Dcurve'),
              ('Contour lines',
               2,
               'plot:surf:contours',
               'plot:surf:contours'),
              ('The gradient vector field',
               2,
               'plot:surf:gradient',
               'plot:surf:gradient'),
              ('Matplotlib', 1, None, '___sec86'),
              ('Surface plots',
               2,
               'matplotlibsurfaceplots',
               'matplotlibsurfaceplots'),
              ('Contour plots',
               2,
               'matplotlibcontourplots',
               'matplotlibcontourplots'),
              ('Vector field plots',
               2,
               'plot:surf:mpl:quiver',
               'plot:surf:mpl:quiver'),
              ('Mayavi', 1, None, '___sec90'),
              ('Surface plots', 2, None, '___sec91'),
              ('Subplots', 3, None, '___sec92'),
              ('Contour plots', 2, None, '___sec93'),
              ('Vector field plots',
               2,
               'plot:surf:mayavi:quiver',
               'plot:surf:mayavi:quiver'),
              ('A 3D scalar field and its gradient field',
               2,
               None,
               '___sec95'),
              ('Animations', 2, None, '___sec96'),
              ('Summary', 1, None, '___sec97'),
              ('Chapter topics', 2, None, '___sec98'),
              ('Array computing', 3, None, '___sec99'),
              ('Plotting curves', 3, None, '___sec100'),
              ('Making movies', 3, None, '___sec101'),
              ('Terminology', 3, None, '___sec102'),
              ('Example: Animating a function',
               2,
               'sec:plot:summarizing',
               'sec:plot:summarizing'),
              ('Problem', 3, None, '___sec104'),
              ('Solution', 3, None, '___sec105'),
              ('Scaling', 3, None, '___sec106'),
              ('Exercises', 1, 'sec:plot:exer', 'sec:plot:exer'),
              ('Exercise 1: Fill lists with function values',
               2,
               'sec:plot:ex1',
               'sec:plot:ex1'),
              ('Exercise 2: Fill arrays; loop version',
               2,
               'sec:plot:ex2',
               'sec:plot:ex2'),
              ('Exercise 3: Fill arrays; vectorized version',
               2,
               'sec:plot:ex2b',
               'sec:plot:ex2b'),
              ('Exercise 4: Plot a function',
               2,
               'sec:plot:ex2c',
               'sec:plot:ex2c'),
              ('Exercise 5: Apply a function to a vector',
               2,
               'sec:plot:math:ex1',
               'sec:plot:math:ex1'),
              ('Exercise 6: Simulate by hand a vectorized expression',
               2,
               'sec:plot:ex3',
               'sec:plot:ex3'),
              ('Exercise 7: Demonstrate array slicing',
               2,
               'sec:plot:ex15d',
               'sec:plot:ex15d'),
              ('Exercise 8: Replace list operations by array computing',
               2,
               'sec:plot:ex33',
               'sec:plot:ex33'),
              ('Exercise 9: Plot a formula',
               2,
               'sec:plot:ex15',
               'sec:plot:ex15'),
              ('Exercise 10: Plot a formula for several parameters',
               2,
               'sec:plot:ex15b',
               'sec:plot:ex15b'),
              ('Exercise 11: Specify the extent of the axes in a plot',
               2,
               'sec:plot:ex15ba',
               'sec:plot:ex15ba'),
              ('Exercise 12: Plot exact and inexact Fahrenheit-Celsius conversion formulas',
               2,
               'sec:plot:ex15c',
               'sec:plot:ex15c'),
              ('Exercise 13: Plot the trajectory of a ball',
               2,
               'sec:plot:ex5',
               'sec:plot:ex5'),
              ('Exercise 14: Plot data in a two-column file',
               2,
               'sec:files:ex12',
               'sec:files:ex12'),
              ('Remarks', 3, None, '___sec122'),
              ('Exercise 15: Write function data to file',
               2,
               'sec:files:ex12e',
               'sec:files:ex12e'),
              ('Exercise 16: Plot data from a file',
               2,
               'sec:files:ex12c',
               'sec:files:ex12c'),
              ('Exercise 17: Write table to file',
               2,
               'sec:files:exer:write_table',
               'sec:files:exer:write_table'),
              ('Exercise 18: Fit a polynomial to data points',
               2,
               'sec:files:ex12c2',
               'sec:files:ex12c2'),
              ('Exercise 19: Fit a polynomial to experimental data',
               2,
               'sec:files:ex19',
               'sec:files:ex19'),
              ('Exercise 20: Read acceleration data and find velocities',
               2,
               'sec:files:ex22',
               'sec:files:ex22'),
              ('Exercise 21: Read acceleration data and plot velocities',
               2,
               'sec:files:ex23',
               'sec:files:ex23'),
              ("Exercise 22: Plot a trip's path and velocity from GPS coordinates",
               2,
               'sec:files:ex24',
               'sec:files:ex24'),
              ('Exercise 23: Vectorize the Midpoint rule for integration',
               2,
               'sec:class:exer:sum',
               'sec:class:exer:sum'),
              ('Remarks', 3, None, '___sec132'),
              ('Exercise 24: Vectorize a function for computing the area of a polygon',
               2,
               'sec:plot:exer:area:polygon:vec',
               'sec:plot:exer:area:polygon:vec'),
              ("Exercise 25: Implement Lagrange's interpolation formula",
               2,
               'sec:class:ex27a',
               'sec:class:ex27a'),
              ("Exercise 26: Plot Lagrange's interpolating polynomial",
               2,
               'sec:class:ex27b',
               'sec:class:ex27b'),
              ("Exercise 27: Investigate the behavior of Lagrange's interpolating polynomials",
               2,
               'sec:class:ex27c',
               'sec:class:ex27c'),
              ('Remarks', 3, None, '___sec137'),
              ('Exercise 28: Plot a wave packet',
               2,
               'sec:plot:ex5d',
               'sec:plot:ex5d'),
              ('Exercise 29: Judge a plot',
               2,
               'sec:plot:ex7',
               'sec:plot:ex7'),
              ('Exercise 30: Plot the viscosity of water',
               2,
               'sec:plot:ex13c',
               'sec:plot:ex13c'),
              ('Exercise 31: Explore a complicated function graphically',
               2,
               'sec:plot:ex16',
               'sec:plot:ex16'),
              ('Exercise 32: Plot Taylor polynomial approximations to $\\sin x$',
               2,
               'sec:plot:ex5b',
               'sec:plot:ex5b'),
              ('Exercise 33: Animate a wave packet',
               2,
               'sec:plot:ex5e',
               'sec:plot:ex5e'),
              ('Exercise 34: Animate a smoothed Heaviside function',
               2,
               'sec:plot:ex32',
               'sec:plot:ex32'),
              ('Exercise 35: Animate two-scale temperature variations',
               2,
               'sec:plot:ex18',
               'sec:plot:ex18'),
              ('Remarks', 3, None, '___sec146'),
              ('Exercise 36: Use non-uniformly distributed coordinates for visualization',
               2,
               'sec:plot:ex19',
               'sec:plot:ex19'),
              ('Exercise 37: Animate a sequence of approximations to $\\pi$',
               2,
               'sec:plot:ex31',
               'sec:plot:ex31'),
              ("Exercise 38: Animate a planet's orbit",
               2,
               'sec:plot:ex5g',
               'sec:plot:ex5g'),
              ('Exercise 39: Animate the evolution of Taylor polynomials',
               2,
               'sec:plot:ex17',
               'sec:plot:ex17'),
              ('Exercise 40: Plot the velocity profile for pipeflow',
               2,
               'sec:plot:ex4',
               'sec:plot:ex4'),
              ('Exercise 41: Plot sum-of-sines approximations to a function',
               2,
               'sec:plot:ex8',
               'sec:plot:ex8'),
              ('Exercise 42: Animate the evolution of a sum-of-sine approximation to a function',
               2,
               'sec:plot:ex8m',
               'sec:plot:ex8m'),
              ('Exercise 43: Plot functions from the command line',
               2,
               'sec:plot:ex14',
               'sec:plot:ex14'),
              ('Exercise 44: Improve command-line input',
               2,
               'sec:plot:ex14b',
               'sec:plot:ex14b'),
              ('Exercise 45: Demonstrate energy concepts from physics',
               2,
               'sec:plot:ex20',
               'sec:plot:ex20'),
              ('Exercise 46: Plot a w-like function',
               2,
               'sec:plot:math:ex9',
               'sec:plot:math:ex9'),
              ('Exercise 47: Plot a piecewise constant function',
               2,
               'sec:basic:exH4plot',
               'sec:basic:exH4plot'),
              ('Exercise 48: Vectorize a piecewise constant function',
               2,
               'sec:basic:exH4vecz1',
               'sec:basic:exH4vecz1'),
              ('Remarks', 3, None, '___sec160'),
              ('Exercise 49: Visualize approximations in the Midpoint integration rule',
               2,
               'sec:plot:ex:vizmidpoint',
               'sec:plot:ex:vizmidpoint'),
              ('Exercise 50: Visualize approximations in the Trapezoidal integration rule',
               2,
               'sec:plot:ex:viztrapezoidal',
               'sec:plot:ex:viztrapezoidal'),
              ('Exercise 51: Experience overflow in a function',
               2,
               'sec:plot:ex13',
               'sec:plot:ex13'),
              ('Remarks', 3, None, '___sec164'),
              ('Exercise 52: Apply a function to a rank 2 array',
               2,
               'sec:plot:math:ex2',
               'sec:plot:math:ex2'),
              ('Exercise 53: Explain why array computations fail',
               2,
               'sec:plot:ex11',
               'sec:plot:ex11'),
              ('Exercise 54: Verify linear algebra results',
               2,
               'plot:linalg:exer:verify',
               'plot:linalg:exer:verify'),
              ('References', 1, None, '___sec168')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\tp}{\thinspace .}
$$




    
<a name="part0009"></a>
<p>
<!-- begin top navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._plot-solarized008.html">&laquo; Previous</a></div>
</td><td>
</td></tr></table>
<!-- end top navigation -->
</p>

<p>
<!-- !split -->
<p style="font-size:80%">This chapter is taken from the book <a href="http://www.springer.com/gp/book/9783662498866">A Primer on Scientific Programming with Python</a> by H. P. Langtangen, 5th edition, Springer, 2016.</p>

<h1 id="sec:plot:exer">Exercises</h1>

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex1">Exercise 1: Fill lists with function values</h2>

<p>
Define

$$
\begin{equation}
h(x) = {1\over\sqrt{2\pi}}e^{-\frac{1}{2}x^2}\tp
\tag{20}
\end{equation}
$$

Fill lists <code>xlist</code> and <code>hlist</code> with \( x \) and \( h(x) \) values
for 41 uniformly spaced \( x \) coordinates in \( [-4,4] \).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
You may adapt the example in the section <a href="._plot-solarized002.html#sec:plot:listdata">Using lists for collecting function data</a>.

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>fill_lists</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex2">Exercise 2: Fill arrays; loop version</h2>

<p>
The aim is to fill two arrays <code>x</code> and <code>y</code> with \( x \) and \( h(x) \) values,
respectively, where \( h(x) \) is defined in <a href="#mjx-eqn-20">(20)</a>.  Let
the \( x \) values be as in <a href="#sec:plot:ex1">Exercise 1: Fill lists with function values</a>.  Create empty <code>x</code>
and <code>y</code> arrays and compute each element in <code>x</code> and <code>y</code> with a <code>for</code>
loop.
Filename: <code>fill_arrays_loop</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex2b">Exercise 3: Fill arrays; vectorized version</h2>

<p>
Vectorize the code in <a href="#sec:plot:ex2">Exercise 2: Fill arrays; loop version</a> by creating the \( x \)
values using the <code>linspace</code> function from the <code>numpy</code> package and by
evaluating \( h(x) \) for an array argument.
Filename: <code>fill_arrays_vectorized</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex2c">Exercise 4: Plot a function</h2>

<p>
Make a plot of the function in <a href="#sec:plot:ex1">Exercise 1: Fill lists with function values</a>
for \( x\in [-4,4] \).
Filename: <code>plot_Gaussian</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:math:ex1">Exercise 5: Apply a function to a vector</h2>

<p>
Given a vector \( v=(2,3,-1) \) and a function \( f(x)=x^3 + xe^x + 1 \),
apply \( f \) to each element in \( v \). Then calculate by hand \( f(v) \) as the
NumPy expression <code>v**3 + v*exp(v) + 1</code> using vector computing rules.
Demonstrate that the two results are equal.
Filename: <code>apply_vecfunc</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex3">Exercise 6: Simulate by hand a vectorized expression</h2>

<p>
Suppose <code>x</code> and <code>t</code> are two arrays of the same length, entering a
vectorized expression

<p>
<!-- begin verbatim block  pycod-->
<pre><code>y = cos(sin(x)) + exp(1/t)
</code></pre>
<!-- end verbatim block -->
If <code>x</code> holds two elements, 0 and 2, and <code>t</code> holds the elements 1 and
1.5, calculate by hand (using a calculator) the <code>y</code> array. Thereafter,
write a program that mimics the series of computations you did by hand
(typically a sequence of operations of the kind we listed in the section <a href="._plot-solarized001.html#sec:plot:arraycomp">Vector arithmetics and vector functions</a> - use explicit loops, but at the end you can
use Numerical Python functionality to check the results).
Filename: <code>simulate_vector_computing</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex15d">Exercise 7: Demonstrate array slicing</h2>

<p>
Create an array <code>w</code> with values \( 0,0.1,0.2,\ldots,3 \).  Write out
<code>w[:]</code>, <code>w[:-2]</code>, <code>w[::5]</code>, <code>w[2:-2:6]</code>.  Convince yourself in each
case that you understand which elements of the array that are printed.
Filename: <code>slicing</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex33">Exercise 8: Replace list operations by array computing</h2>

<p>
The data analysis problem in

<p>
the document <a href="http://hplgit.github.io/primer.html/doc/pub/looplist" target="_self">Loops and lists</a>
<a href="#Langtangen_TCSE6_funcif">[4]</a>
is solved by list operations. Convert the list to a two-dimensional
array and perform the computations using array operations (i.e., no explicit
loops, but you need a loop to make the printout).
Filename: <code>sun_data_vec</code>.

<p>
<!-- Bouncing ball: reduce \( v_0 \) by \( p \) every bounce, define the function!!! -->
<!-- plot it! -->
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex15">Exercise 9: Plot a formula</h2>

<p>
Make a plot of the function \( y(t)=v_0t - \frac{1}{2}gt^2 \) for
\( v_0=10 \), \( g=9.81 \), and \( t\in [0,2v_0/g] \).  Set the axes labels as
<code>time (s)</code> and <code>height (m)</code>.
Filename: <code>plot_ball1</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex15b">Exercise 10: Plot a formula for several parameters</h2>

<p>
Make a program that reads a set of \( v_0 \) values from the command line
and plots the corresponding curves \( y(t)=v_0t - \frac{1}{2}gt^2 \) in
the same figure, with \( t\in [0,2v_0/g] \) for each curve.  Set \( g=9.81 \).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
You need a different vector of \( t \) coordinates for each curve.

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>plot_ball2</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex15ba">Exercise 11: Specify the extent of the axes in a plot</h2>

<p>
Extend the program from <a href="#sec:plot:ex15b">Exercise 10: Plot a formula for several parameters</a> such that the
minimum and maximum \( t \) and \( y \) values are computed, and use the
extreme values to specify the extent of the axes. Add some
space above the highest curve to make the plot look better.
Filename: <code>plot_ball3</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex15c">Exercise 12: Plot exact and inexact Fahrenheit-Celsius conversion formulas</h2>

<p>
A simple rule to quickly compute the Celsius temperature from the
Fahrenheit degrees is to subtract 30 and then divide by 2: \( C =
(F-30)/2 \).  Compare this curve against the exact curve \( C = (F-32)5/9 \)
in a plot. Let \( F \) vary between \( -20 \) and \( 120 \).
Filename: <code>f2c_shortcut_plot</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex5">Exercise 13: Plot the trajectory of a ball</h2>

<p>
The formula for the trajectory of a ball is given by

$$
\begin{equation}
f(x) = x\tan\theta - {1\over 2v_0^2}{gx^2\over\cos^2\theta} + y_0,
\tag{21}
\end{equation}
$$

where \( x \) is a coordinate along the ground, \( g \) is the acceleration
of gravity, \( v_0 \) is the size of the initial velocity, which makes an
angle \( \theta \) with the \( x \) axis, and \( (0,y_0) \) is the initial position
of the ball.

<p>
In a program, first read the input data \( y_0 \), \( \theta \), and \( v_0 \)
from the command line.  Then plot the trajectory \( y=f(x) \) for \( y\geq
0 \).
Filename: <code>plot_trajectory</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:files:ex12">Exercise 14: Plot data in a two-column file</h2>

<p>
The file <a href="http://tinyurl.com/pwyasaa/plot/xy.dat" target="_self"><tt>src/plot/xy.dat</tt></a> contains two
columns of numbers, corresponding to \( x \) and \( y \) coordinates on a
curve. The start of the file looks as this:

<p>
<!-- begin verbatim block  dat-->
<pre><code>     -1.0000       -0.0000
     -0.9933       -0.0087
     -0.9867       -0.0179
     -0.9800       -0.0274
     -0.9733       -0.0374
</code></pre>
<!-- end verbatim block -->
Make a program that reads the first column into a list <code>x</code> and
the second column into a list <code>y</code>. Plot
the curve. Print out the mean \( y \) value as well as the
maximum and minimum \( y \) values.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Read the file line by line, split each line
into words, convert to <code>float</code>, and append to <code>x</code> and <code>y</code>.
The computations with <code>y</code> are simpler if the list is converted
to an array.

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>read_2columns</code>.

<p>
<!-- Closing remarks for this Exercise -->

<h3 id="___sec122">Remarks </h3>

<p>
The function <code>loadtxt</code> in <code>numpy</code> can read files with tabular data
(any number of columns) and return the data in a two-dimensional
array:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import numpy as np
# Read table of floats
data = np.loadtxt('xy.dat', dtype=np.float)
# Extract one-dim arrays from two-dim data
x = data[:,0]  # column with index 0
y = data[:,1]  # column with index 1
</code></pre>
<!-- end verbatim block -->
The present exercise asks you to implement a simplified version
of <code>loadtxt</code>, but for later loading of a file with tabular data into
an array you will certainly use <code>loadtxt</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:files:ex12e">Exercise 15: Write function data to file</h2>

<p>
We want to dump \( x \) and \( f(x) \) values to a file, where the \( x \) values
appear in the first column and the \( f(x) \) values appear in the
second. Choose \( n \) equally spaced \( x \) values in the interval \( [a,b] \).
Provide \( f \), \( a \), \( b \), \( n \), and the filename as input data on the
command line.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
You may use the <code>StringFunction</code> tool (see the sections ref{sec:input:StringFunction} and
<a href="._plot-solarized005.html#sec:plot:StringFunction:vectorize">Vectorization of StringFunction objects</a>) to turn the textual expression
for \( f \) into a Python function.

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>write_cml_function</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:files:ex12c">Exercise 16: Plot data from a file</h2>

<p>
The files <code>density_water.dat</code> and <code>density_air.dat</code> files in the
folder <a href="http://tinyurl.com/pwyasaa/plot" target="_self"><tt>src/plot</tt></a> contain data about the density
of water and air (respectively) for different temperatures. The data
files have some comment lines starting with <code>#</code> and some lines are
blank. The rest of the lines contain density data: the temperature in
the first column and the corresponding density in the second column.
The goal of this exercise is to read the data in such a file and plot
the density versus the temperature as distinct (small) circles for
each data point.  Let the program take the name of the data file as
command-line argument.  Apply the program to both files.
Filename: <code>read_density_data</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:files:exer:write_table">Exercise 17: Write table to file</h2>

<p>
Given a function of two parameters \( x \) and \( y \), we want to create
a file with a table of function values. The left column of the
table contains \( y \) values in decreasing order as we go down
the rows, and the last
row contains the \( x \) values in increasing order. That is, the first
column and the last row act like numbers
on an \( x \) and \( y \) axis in a coordinate system. The rest of the
table cells contains function values corresponding to the \( x \) and
\( y \) values for the respective rows and columns. For example, if
the function formula is \( x+2y \), \( x \) runs from 0 to 2 in steps
of 0.5, and \( y \) run from -1 to 2 in steps of 1, the table looks
as follows:

<p>
<!-- begin verbatim block  dat-->
<pre><code>    2    4  4.5    5  5.5    6
    1    2  2.5    3  3.5    4
    0    0  0.5    1  1.5    2
   -1   -2 -1.5   -1 -0.5    0

         0  0.5    1  1.5    2
</code></pre>
<!-- end verbatim block -->

<p>
The task is to write a function

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def write_table_to_file(f, xmin, xmax, nx, ymin, ymax, ny,
                        width=10, decimals=None,
                        filename='table.dat'):

</code></pre>
<!-- end verbatim block -->
where <code>f</code> is the formula, given as a Python function;
<code>xmin</code>, <code>xmax</code>, <code>ymin</code>, and <code>ymax</code> are the
minimum and maximum \( x \) and \( y \) values; <code>nx</code> is the number of intervals
in the \( x \) coordinates (the number of steps in \( x \) direction is then
<code>(xmax-xmin)/nx</code>); <code>ny</code> is the number of intervals in the
\( y \) coordinates; <code>width</code> is the width of each column in the table
(a positive integer); <code>decimals</code> is the number of decimals used when
writing out the numbers (<code>None</code> means no decimal specification), and <code>filename</code>
is the name of the output file. For example, <code>width=10</code> and <code>decimals=1</code>
gives the output format <code>%10.1g</code>, while <code>width=5</code> and <code>decimals=None</code>
implies <code>%5g</code>.

<p>
Here is a test function which you should use to verify the
implementation:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def test_write_table_to_file():
    filename = 'tmp.dat'
    write_table_to_file(f=lambda x, y: x + 2*y,
                        xmin=0, xmax=2, nx=4,
                        ymin=-1, ymax=2, ny=3,
                        width=5, decimals=None,
                        filename=filename)
    # Load text in file and compare with expected results
    with open(filename, 'r') as infile:
        computed = infile.read()
    expected = &quot;&quot;&quot;\ 
    2    4  4.5    5  5.5    6
    1    2  2.5    3  3.5    4
    0    0  0.5    1  1.5    2
   -1   -2 -1.5   -1 -0.5    0

         0  0.5    1  1.5    2&quot;&quot;&quot;
    assert computed == expected
</code></pre>
<!-- end verbatim block -->
Filename: <code>write_table_to_file</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:files:ex12c2">Exercise 18: Fit a polynomial to data points</h2>

<p>
The purpose of this exercise is to find a simple mathematical formula
for how the density of water or air depends on the temperature.
The idea is to load density and temperature data from file as
explained in <a href="#sec:files:ex12c">Exercise 16: Plot data from a file</a> and then apply some NumPy
utilities that can find a polynomial that approximates the density as
a function of the temperature.

<p>
NumPy has a function <code>polyfit(x, y, deg)</code> for finding a best fit
of a polynomial of degree <code>deg</code> to a set of data points given by the
array arguments <code>x</code> and <code>y</code>. The <code>polyfit</code> function returns a list of
the coefficients in the fitted polynomial, where the first element is
the coefficient for the term with the highest degree, and the last
element corresponds to the constant term. For example, given points in
<code>x</code> and <code>y</code>, <code>polyfit(x, y, 1)</code> returns the coefficients <code>a, b</code> in a
polynomial <code>a*x + b</code> that fits the data in the best way.  (More
precisely, a line \( y=ax+b \) is a best fit to the data points
\( (x_i,y_i) \), \( i=0,\ldots,n-1 \) if \( a \) and \( b \) are chosen to make the
sum of squared errors \( R=\sum_{j=0}^{n-1} (y_j - (ax_j + b))^2 \) as
small as possible.  This approach is known as <em>least squares
approximation</em> to data and proves to be extremely useful throughout
science and technology.)

<p>
NumPy also has a utility <code>poly1d</code>, which can take the tuple or list of
coefficients calculated by, e.g., <code>polyfit</code> and return the polynomial
as a Python function that can be evaluated. The following code snippet
demonstrates the use of <code>polyfit</code> and <code>poly1d</code>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>coeff = polyfit(x, y, deg)
p = poly1d(coeff)
print p             # prints the polynomial expression
y_fitted = p(x)     # computes the polynomial at the x points
# Use red circles for data points and a blue line for the polyn.
plot(x, y, 'ro', x, y_fitted, 'b-',
     legend=('data', 'fitted polynomial of degree %d' % deg))
</code></pre>
<!-- end verbatim block -->

<p>
<b>a)</b>
Write a function <code>fit(x, y, deg)</code> that creates a plot of data
in <code>x</code> and <code>y</code> arrays along with polynomial approximations of
degrees collected in the list <code>deg</code> as explained above.

<p>
<b>b)</b>
We want to call <code>fit</code> to make a plot of the density of water versus
temperature and another plot of the density of air versus
temperature. In both calls, use <code>deg=[1,2]</code> such that we can compare
linear and quadratic approximations to the data.

<p>
<b>c)</b>
From a visual inspection of the plots, can you suggest simple
mathematical formulas that relate the density of
air to temperature and the density of water to temperature?

<p>
Filename: <code>fit_density_data</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:files:ex19">Exercise 19: Fit a polynomial to experimental data</h2>

<p>
Suppose we have measured the oscillation period \( T \) of a simple
pendulum with a mass \( m \) at the end of a massless rod of length
\( L \). We have varied \( L \) and recorded the corresponding \( T \) value. The
measurements are found in a file <a href="http://tinyurl.com/pwyasaa/plot/pendulum.dat" target="_self"><tt>src/plot/pendulum.dat</tt></a>.  The first column in the file
contains \( L \) values and the second column has the corresponding \( T \)
values.

<p>
<b>a)</b>
Plot \( L \) versus \( T \) using circles for the data points.

<p>
<b>b)</b>
We shall assume that \( L \) as a function of \( T \) is a polynomial.
Use the NumPy utilities <code>polyfit</code> and <code>poly1d</code>, as explained in
<a href="#sec:files:ex12c2">Exercise 18: Fit a polynomial to data points</a>, to fit polynomials of degree 1, 2, and
3 to the \( L \) and \( T \) data.  Visualize the polynomial curves together
with the experimental data. Which polynomial fits the measured data
best?

<p>
Filename: <code>fit_pendulum_data</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:files:ex22">Exercise 20: Read acceleration data and find velocities</h2>

<p>
A file <a href="http://tinyurl.com/pwyasaa/plot/acc.dat" target="_self"><tt>src/plot/acc.dat</tt></a> contains
measurements \( a_0,a_1,\ldots,a_{n-1} \) of the acceleration of an object
moving along a straight line. The measurement \( a_k \) is taken at time
point \( t_k=k\Delta t \), where \( \Delta t \) is the time spacing between
the measurements.  The purpose of the exercise is to load the
acceleration data into a program and compute the velocity \( v(t) \) of
the object at some time \( t \).

<p>
In general, the acceleration \( a(t) \) is related to the velocity \( v(t) \)
through \( v'(t)=a(t) \). This means that

$$
\begin{equation} v(t) = v(0) + \int_0^t a(\tau) d\tau\tp
\tag{22}
\end{equation}
$$

If \( a(t) \) is only known at some discrete, equally spaced points in time,
\( a_0,\ldots,a_{n-1} \) (which is the case in this exercise), we must
compute the integral in <a href="#mjx-eqn-22">(22)</a> numerically, for example
by the Trapezoidal rule:

$$
\begin{equation}
v(t_k) \approx \Delta t\left( \frac{1}{2}a_0 + \frac{1}{2}a_{k}
+ \sum_{i=1}^{k-1} a_i\right),\quad 1 \leq k \leq n-1\tp
\tag{23}
\end{equation}
$$

We assume \( v(0)=0 \) so that also \( v_0=0 \).

<p>
Read the values \( a_0,\ldots,a_{n-1} \) from file into an array, plot the
acceleration versus time, and use <a href="#mjx-eqn-23">(23)</a> to
compute one \( v(t_k) \) value, where \( \Delta t \) and \( k\geq 1 \) are
specified on the command line.
Filename: <code>acc2vel_v1</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:files:ex23">Exercise 21: Read acceleration data and plot velocities</h2>

<p>
The task in this exercise is the same as in <a href="#sec:files:ex22">Exercise 20: Read acceleration data and find velocities</a>, except that we now want to compute \( v(t_k) \) for
all time points \( t_k=k\Delta t \) and plot the velocity versus time.
Now only \( \Delta t \) is given on the command line, and the \( a_0,\ldots,
a_{n-1} \) values must be read from file as in <a href="#sec:files:ex22">Exercise 20: Read acceleration data and find velocities</a>.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Repeated use of <a href="#mjx-eqn-23">(23)</a> for all \( k \) values
is very inefficient. A more efficient formula arises if we add the area of
a new trapezoid to the previous

$$
\begin{equation}
v(t_{k}) = v(t_{k-1}) + \int\limits_{t_{k-1}}^{t_k} a(\tau) d\tau
\approx v(t_{k-1}) + \Delta t \frac{1}{2}(a_{k-1} + a_{k}),
\tag{24}
\end{equation}
$$

for \( k=1,2,\ldots,n-1 \), while
\( v_0=0 \).
Use this formula to fill an array <code>v</code> with velocity values.

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>acc2vel</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:files:ex24">Exercise 22: Plot a trip's path and velocity from GPS coordinates</h2>

<p>
A GPS device measures your position at every \( s \) seconds.  Imagine
that the positions corresponding to a specific trip are stored as
\( (x,y) \) coordinates in a file <a href="http://tinyurl.com/pwyasaa/plot/pos.dat" target="_self"><tt>src/plot/pos.dat</tt></a> with an \( x \) and \( y \) number on each line,
except for the first line, which contains the value of \( s \).

<p>
<b>a)</b>
Plot the two-dimensional curve of
corresponding to the data in the file.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Load \( s \) into a <code>float</code> variable
and then the \( x \) and \( y \) numbers into two arrays. Draw a straight line
between the points, i.e., plot the \( y \) coordinates versus the \( x \)
coordinates.

<p>
<!-- --- end hint in exercise --- -->

<p>
<b>b)</b>
Plot the velocity in \( x \) direction versus time in one plot and the
velocity in \( y \) direction versus time in another plot.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
If \( x(t) \) and \( y(t) \) are the coordinates of the positions as a function
of time, we have that the velocity in \( x \) direction is \( v_x(t)=dx/dt \),
and the velocity in \( y \) direction is \( v_y=dy/dt \).
Since \( x \) and \( y \) are only known for some discrete times,
\( t_k=ks \), \( k=0,\ldots,n-1 \), we must use numerical differentiation. A
simple (forward) formula is

$$
\begin{equation*} v_x(t_k) \approx {x(t_{k+1})-x(t_k)\over s},\quad
v_y(t_k) \approx {y(t_{k+1})-y(t_k)\over s},\quad k=0,\ldots,n-2\tp \end{equation*}
$$

Compute arrays <code>vx</code> and <code>vy</code> with velocities based on the
formulas above for
\( v_x(t_k) \) and \( v_y(t_k) \), \( k=0,\ldots,n-2 \).

<p>
<!-- --- end hint in exercise --- -->

<p>
Filename: <code>position2velocity</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:class:exer:sum">Exercise 23: Vectorize the Midpoint rule for integration</h2>

<p>
The Midpoint rule for approximating an integral can be expressed as
$$
\begin{equation}
\int_a^b f(x)dx \approx h\sum_{i=1}^n f(a - \frac{1}{2}h + ih),
\tag{25}
\end{equation}
$$

where \( h=(b-a)/n \).

<p>
<b>a)</b>
Write a function <code>midpointint(f, a, b, n)</code> to compute
Midpoint rule. Use a plain Python <code>for</code> loop to implement the sum.

<p>
<b>b)</b>
Make a vectorized implementation of the Midpoint rule where you
compute the sum by Python's built-in function <code>sum</code>.

<p>
<b>c)</b>
Make another vectorized implementation of the Midpoint rule where you
compute the sum by the <code>sum</code> function in the <code>numpy</code> package.

<p>
<b>d)</b>
Organize the three implementations above in a module file <code>midpoint_vec.py</code>.
Equip the module with one test function for verifying the
three implementations.
Use the integral \( \int_2^4 2xdx = 12 \) as test case since the Midpoint
rule will integrate such a linear integrand exactly.

<p>
<b>e)</b>
Start IPython, import the functions from <code>midpoint_vec.py</code>,
define some Python implementation of a mathematical function \( f(x) \)
to integrate, and use the <code>%timeit</code> feature of IPython to measure
the efficiency of the three alternative implementations.

<p>
Filename: <code>midpoint_vec</code>.

<p>
<!-- Closing remarks for this Exercise -->

<h3 id="___sec132">Remarks </h3>

<p>
The lesson learned from the experiments in e) is that <code>numpy.sum</code> is
much more efficient than Python's built-in function <code>sum</code>. Vectorized
implementations must always make use of <code>numpy.sum</code> to compute sums.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:exer:area:polygon:vec">Exercise 24: Vectorize a function for computing the area of a polygon</h2>

<p>
The area of a polygon is given by
a formula in the exercise &quot;Compute the area of a polygon&quot; in the document <a href="http://hplgit.github.io/primer.html/doc/pub/funcif" target="_self">Functions and
branching</a>.
Vectorize this formula such that there are no Python loops in the
implementation. Make a test function that compares the scalar
implementation in the referred exercise with the new vectorized implementation
for some chosen polygons
(the scalar version must then be available in a module so that the
function can be imported).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Observe that the formula \( x_1y_2+x_2y_3 + \cdots + x_{n-1}y_n =
\sum_{i=0}^{n-1}x_iy_{i+1} \) is the dot product of two vectors,
<code>x[:-1]</code> and <code>y[1:]</code>,
which can be computed as <code>numpy.dot(x[:-1], y[1:])</code>.

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>polygon_area_vec</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:class:ex27a">Exercise 25: Implement Lagrange's interpolation formula</h2>

<p>
Imagine we have \( n+1 \) measurements of some quantity \( y \) that depends
on \( x \): \( (x_0,y_0), (x_1,y_1),\ldots,(x_{n}, y_n) \). We may think of
\( y \) as a function of \( x \) and ask what \( y \) is at some arbitrary point
\( x \) not coinciding with any of the points \( x_0,\ldots,x_n \).  It is not
clear how \( y \) varies between the measurement points, but we can
make assumptions or models for this behavior. Such a problem
is known as <em>interpolation</em>.

<p>
One way to solve the interpolation problem is to fit a continuous
function that goes through all the \( n+1 \) points and then evaluate this
function for any desired \( x \).  A candidate for such a function is the
polynomial of degree \( n \) that goes through all the points. It turns
out that this polynomial can be written

$$
\begin{equation}
p_L(x) = \sum_{k=0}^n y_kL_k(x),
\tag{26}
\end{equation}
$$

where

$$
\begin{equation} L_k(x) =
\prod_{i=0,i\neq k}^n\frac{x-x_i}{x_k -x_i}
\tag{27} \thinspace .
\end{equation}
$$

The \( \prod \) notation corresponds to \( \sum \), but the terms are multiplied.
For example,

$$
\begin{equation*} \prod_{i=0,i\neq k}^n x_i = x_0x_1\cdots x_{k-1}x_{k+1}\cdots x_n\thinspace .
\end{equation*}
$$

The polynomial \( p_L(x) \) is known as Lagrange's interpolation formula,
and the points \( (x_0,y_0),\ldots,(x_n,y_n) \) are called interpolation points.

<p>
<b>a)</b>
Make functions <code>p_L(x, xp, yp)</code> and <code>L_k(x, k, xp, yp)</code>
that evaluate \( p_L(x) \) and \( L_k(x) \) by <a href="#mjx-eqn-26">(26)</a>
and <a href="#mjx-eqn-27">(27)</a>, respectively,
at the point <code>x</code>. The arrays <code>xp</code> and <code>yp</code>
contain the \( x \) and \( y \) coordinates of the \( n+1 \) interpolation points,
respectively. That is, <code>xp</code> holds \( x_0,\ldots,x_n \), and <code>yp</code>
holds \( y_0,\ldots,y_n \).

<p>
<b>b)</b>
To verify the program, we observe that \( L_k(x_k)=1 \) and that
\( L_k(x_i)=0 \) for \( i\neq k \), implying that \( p_L(x_k)=y_k \).  That is,
the polynomial \( p_L \) goes through all the points
\( (x_0,y_0),\ldots,(x_n,y_n) \).  Write a function <code>test_p_L(xp, yp)</code>
that computes \( |p_L(x_k)-y_k| \) at all the interpolation points
\( (x_k,y_k) \) and checks that the value is approximately zero.  Call
<code>test_p_L</code> with <code>xp</code> and <code>yp</code> corresponding to \( 5 \) equally
spaced points along the curve \( y=\sin(x) \) for \( x\in [0,\pi] \).
Thereafter, evaluate \( p_L(x) \) for an \( x \) in the middle of two
interpolation points and compare the value of \( p_L(x) \) with the exact
one.

<p>
Filename: <code>Lagrange_poly1</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:class:ex27b">Exercise 26: Plot Lagrange's interpolating polynomial</h2>

<p>
<b>a)</b>
Write a function

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def graph(f, n, xmin, xmax, resolution=1001):
</code></pre>
<!-- end verbatim block -->
for plotting \( p_L(x) \) in <a href="#sec:class:ex27a">Exercise 25: Implement Lagrange's interpolation formula</a>,
based on interpolation points taken from some mathematical function
\( f(x) \) represented by the argument <code>f</code>. The argument <code>n</code>
denotes the number of interpolation points sampled from the \( f(x) \)
function, and <code>resolution</code> is the number of points between
<code>xmin</code> and <code>xmax</code> used to plot \( p_L(x) \).  The \( x \) coordinates
of the <code>n</code> interpolation points can be uniformly distributed
between <code>xmin</code> and <code>xmax</code>. In the graph, the interpolation
points \( (x_0,y_0),\ldots,(x_n,y_n) \) should be marked by small
circles.  Test the <code>graph</code> function by choosing 5
points in \( [0,\pi] \) and <code>f</code> as \( \sin x \).

<p>
<b>b)</b>
Make a module <code>Lagrange_poly2</code> containing the <code>p_L</code>,
<code>L_k</code>, <code>test_p_L</code>, and <code>graph</code> functions. The call to
<code>test_p_L</code> described in <a href="#sec:class:ex27a">Exercise 25: Implement Lagrange's interpolation formula</a> and the
call to <code>graph</code> described above should appear in the module's test block.

<p>
Filename: <code>Lagrange_poly2</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:class:ex27c">Exercise 27: Investigate the behavior of Lagrange's interpolating polynomials</h2>

<p>
Unfortunately, the polynomial \( p_L(x) \) defined and implemented in
<a href="#sec:class:ex27a">Exercise 25: Implement Lagrange's interpolation formula</a> can exhibit some undesired oscillatory
behavior that we shall explore graphically in this exercise.  Call the
<code>graph</code> function from <a href="#sec:class:ex27b">Exercise 26: Plot Lagrange's interpolating polynomial</a> with \( f(x)=|x| \),
\( x\in [-2,2] \), for \( n=2,4,6,10 \). All the graphs of \( p_L(x) \) should
appear in the same plot for comparison. In addition, make a new figure
with results from calls to <code>graph</code> for \( n=13 \) and \( n=20 \). All the
code necessary for solving this exercise should appear in some
separate program file, which imports the <code>Lagrange_poly2</code> module made
in <a href="#sec:class:ex27b">Exercise 26: Plot Lagrange's interpolating polynomial</a>.
Filename: <code>Lagrange_poly2b</code>.

<p>
<!-- Closing remarks for this Exercise -->

<h3 id="___sec137">Remarks </h3>

<p>
The purpose of the \( p_L(x) \) function is to compute \( (x,y) \) between
some given (often measured) data points \( (x_0,y_0),\ldots,(x_n,y_n) \).
We see from the graphs that for a small number of interpolation
points, \( p_L(x) \) is
quite close to the curve \( y=|x| \) we used to generate the data points,
but as \( n \) increases, \( p_L(x) \) starts to oscillate, especially toward
the end points \( (x_0,y_0) \) and \( (x_n,y_n) \). Much research has
historically been focused on methods that do not result in such
strange oscillations when fitting a polynomial to a set of points.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex5d">Exercise 28: Plot a wave packet</h2>

<p>
The function

$$
\begin{equation}
f(x, t) = e^{-(x-3t)^2}\sin\left( 3\pi (x-t)\right)
\tag{28}
\end{equation}
$$

describes for a fixed value of \( t \) a wave localized in space.  Make a
program that visualizes this function as a function of \( x \) on the
interval \( [-4,4] \) when \( t=0 \).
Filename: <code>plot_wavepacket</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex7">Exercise 29: Judge a plot</h2>

<p>
Assume you have the following program for plotting a parabola:

<p>
<!-- begin verbatim block  pypro-->
<pre><code>import numpy as np
x = np.linspace(0, 2, 20)
y = x*(2 - x)
import matplotlib.pyplot as plt
plt.plot(x, y)
plt.show()
</code></pre>
<!-- end verbatim block -->
Then you switch to the function \( \cos (18\pi x) \) by altering the
computation of <code>y</code> to <code>y = cos(18*pi*x)</code>.  Judge the resulting
plot. Is it correct?  Display the \( \cos (18\pi x) \) function with 1000
points in the same plot.
Filename: <code>judge_plot</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex13c">Exercise 30: Plot the viscosity of water</h2>

<p>
The viscosity of water, \( \mu \), varies with the temperature \( T \) (in
Kelvin) according to

$$
\begin{equation}
\mu (T) = A\cdot 10^{B/(T-C)},
\tag{29}
\end{equation}
$$

where \( A=2.414\cdot 10^{-5}\hbox{ Pa s} \), \( B=247.8 \) K, and \( C=140 \)
K. Plot \( \mu (T) \) for \( T \) between 0 and 100 degrees Celsius. Label the
\( x \) axis with 'temperature (C)' and the \( y \) axis with 'viscosity (Pa
s)'. Note that \( T \) in the formula for \( \mu \) must be in Kelvin.
Filename: <code>water_viscosity</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex16">Exercise 31: Explore a complicated function graphically</h2>

<p>
The wave speed \( c \) of water surface waves depends on the length
\( \lambda \) of the waves.  The following formula relates \( c \) to
\( \lambda \):

$$
\begin{equation}
c(\lambda) =
\sqrt{{g\lambda\over 2\pi}\left( 1 + s{4\pi^2\over\rho g \lambda^2}\right)
\tanh\left( {2\pi h\over\lambda}\right)}\tp
\tag{30}
\end{equation}
$$

Here, \( g \) is the acceleration of gravity (\( 9.81\hbox{ m/s}^2 \)), \( s \) is
the air-water surface tension (\( 7.9\cdot 10^{-2} \hbox{ N/m} \)) ,
\( \rho \) is the density of water (can be taken as \( 1000 \hbox{
kg/m}^3 \)), and \( h \) is the water depth.  Let us fix \( h \) at 50 m.  First
make a plot of \( c(\lambda) \) (in m/s) for small \( \lambda \) (0.001 m to
0.1 m).  Then make a plot \( c(\lambda) \) for larger \( \lambda \) (1 m to 2
km.
Filename: <code>water_wave_velocity</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex5b">Exercise 32: Plot Taylor polynomial approximations to \( \sin x \)</h2>

<p>
The sine function can be approximated by a polynomial according to the
following formula:

$$
\begin{equation}
\sin x \approx S(x;n) = \sum_{j=0}^{n} (-1)^j {x^{2j+1}\over (2j+1)!}\tp
\tag{31}
\end{equation}
$$

The expression \( (2j+1)! \) is the factorial (<code>math.factorial</code> can
compute this quantity).
The error in the approximation \( S(x;n) \) decreases as \( n \) increases and
in the limit we have that \( \lim_{n\rightarrow\infty} S(x;n) = \sin x \).
The purpose of this exercise is to visualize the quality of various
approximations \( S(x;n) \) as \( n \) increases.

<p>
<b>a)</b>
Write a Python function <code>S(x, n)</code> that computes \( S(x;n) \).
Use a straightforward approach where you compute each
term as it stands in the formula, i.e., \( (-1)^j x^{2j+1} \) divided
by the factorial \( (2j+1)! \).

<p>
<b>b)</b>
Plot \( \sin x \) on \( [0,4\pi] \) together
with the approximations \( S(x;1) \), \( S(x;2) \), \( S(x;3) \), \( S(x;6) \), and \( S(x;12) \).

<p>
Filename: <code>plot_Taylor_sin</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex5e">Exercise 33: Animate a wave packet</h2>

<p>
Display an animation of the function \( f(x,t) \) in <a href="#sec:plot:ex5d">Exercise 28: Plot a wave packet</a> by plotting \( f \) as a function of \( x \) on \( [-6,6] \)
for a set of \( t \) values in \( [-1,1] \). Also make an animated GIF file.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
A suitable resolution can be 1000 intervals (1001 points)
along the \( x \) axis, 60 intervals (61 points) in
time, and 6 frames per second in the animated GIF file.
Use the recipe in the section <a href="._plot-solarized003.html#easyviz:movie">Making animations</a> and remember to remove
the family of old plot files in the beginning of the program.

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>plot_wavepacket_movie</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex32">Exercise 34: Animate a smoothed Heaviside function</h2>

<p>
Visualize the smoothed Heaviside function \( H_{\epsilon}(x) \), defined in
the exercise &quot;Implement a
smoothed Heaviside function&quot; in the document <a href="http://hplgit.github.io/primer.html/doc/pub/funcif" target="_self">Functions and
branching</a>,
as an animation where \( \epsilon \) starts at 2 and then goes to zero.
Filename: <code>smoothed_Heaviside_movie</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex18">Exercise 35: Animate two-scale temperature variations</h2>

<p>
We consider temperature oscillations in the ground as addressed in
the section <a href="._plot-solarized008.html#sec:plot:summarizing">Example: Animating a function</a>. Now we want to visualize daily and
annual variations. Let \( A_1 \) be the amplitude of annual variations and
\( A_2 \) the amplitude of the day/night variations.  Let also \( P_1 = 365 \)
days and \( P_2=24 \) h be the periods of the annual and the daily
oscillations.  The temperature at time \( t \) and depth \( z \) is then given
by

$$
\begin{equation}
T(z,t) = T_0 + A_1e^{-a_1z}\sin (\omega_1 t - a_1z) +
A_2e^{-a_2z}\sin (\omega_2 t - a_2z),
\tag{32}
\end{equation}
$$

where

$$
\begin{align*}
 \omega_1 &= {2\pi P_1},\\ 
 \omega_2 &= {2\pi P_2},\\ 
 a_1 &=\sqrt{\omega_1\over 2k},\\ 
 a_2 &=\sqrt{\omega_2\over 2k}\tp\\ 
\end{align*}
$$

Choose \( k = 10^{-6} \hbox{ m}^2/\hbox{s} \), \( A_1=15 \) C,
\( A_2=7 \) C, and the resolution \( \Delta t \) as \( P_2/10 \).
Modify the <code>heatwave.py</code> program in order to
animate this new temperature function.
Filename: <code>heatwave2</code>.

<p>
<!-- Closing remarks for this Exercise -->

<h3 id="___sec146">Remarks </h3>

<p>
We assume in this problem that the temperature
\( T \) equals the reference temperature \( T_0 \) at \( t=0 \), resulting in
a sine variation rather than the cosine variation in
<a href="._plot-solarized008.html#mjx-eqn-18">(18)</a>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex19">Exercise 36: Use non-uniformly distributed coordinates for visualization</h2>

<p>
Watching the animation in <a href="#sec:plot:ex18">Exercise 35: Animate two-scale temperature variations</a> reveals that
there are rapid oscillations in a small layer close to \( z=0 \).  The
variations away from \( z=0 \) are much smaller in time and space.  It
would therefore be wise to use more \( z \) coordinates close to \( z=0 \)
than for larger \( z \) values. Given a set \( x_0 < x_1 < \cdots < x_n \) of
uniformly spaced coordinates in \( [a, b] \), we can compute new
coordinates \( \bar x_i \), stretched toward \( x=a \), by the formula

$$
\begin{equation*} \bar x_i = a + (b-a)\left({x_i-a\over b-a}\right)^s,\end{equation*}
$$

for some \( s>1 \). In the present example, we can use this formula to stretch
the \( z \) coordinates to the left.

<p>
<b>a)</b>
Experiment with \( s\in [1.2,3] \) and few points
(say 15) and visualize the curve as a line with circles at the
points so that you can easily see the distribution of points toward
the left end. Identify a suitable value of \( s \).

<p>
<b>b)</b>
Run the animation with no circles and (say) 501 points
with the found \( s \) value.

<p>
Filename: <code>heatwave2a</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex31">Exercise 37: Animate a sequence of approximations to \( \pi \)</h2>

<p>
The
exercise named &quot;Approximate $\pi$&quot; in the
document <a href="http://hplgit.github.io/primer.html/doc/pub/funcif" target="_self">Functions and branching</a>
<a href="#Langtangen_TCSE6_funcif">[4]</a>
outlines an idea for approximating \( \pi \)
as the length of a polygon inside the circle. Wrap the code from
that exercise in a function <code>pi_approx(N)</code>, which
returns the approximation to \( \pi \) using a polygon with \( N+1 \) equally
distributed points. The task of the present exercise is to visually
display the polygons as a movie, where each frame shows the polygon
with \( N+1 \) points together with the circle and a title reflecting the
corresponding error in the approximate value of \( \pi \).  The whole
movie arises from letting \( N \) run through \( 4,5,6,\ldots,K \), where \( K \)
is some (large) prescribed value. Let there be a pause of 0.3 s
between each frame in the movie. By playing the movie you will see how
the polygons move closer and closer to the circle and how the
approximation to \( \pi \) improves.
Filename: <code>pi_polygon_movie</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex5g">Exercise 38: Animate a planet's orbit</h2>

<p>
A planet's orbit around a star has the shape of an ellipse. The
purpose of this exercise is to make an animation of the movement along
the orbit.  One should see a small disk, representing the planet,
moving along an elliptic curve.  An evolving solid line shows the
development of the planet's orbit as the planet moves and the title
displays the planet's instantaneous velocity magnitude.  As a test,
run the special case of a circle and verify that the magnitude of the
velocity remains constant as the planet moves.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint 1.</b>
The points \( (x,y) \) along the ellipse are given
by the expressions

$$
\begin{equation*} x=a\cos (\omega t),\quad y = b\sin (\omega t),\end{equation*}
$$

where \( a \) is the semi-major axis of the ellipse, \( b \) is the semi-minor
axis, \( \omega \) is an angular velocity of the planet around the star,
and \( t \) denotes time. One complete orbit corresponds
to \( t\in [0, 2\pi/\omega] \). Let us discretize time into time points
\( t_k = k\Delta t \), where
\( \Delta t = 2\pi/(\omega n) \). Each frame in the movie corresponds to
\( (x,y) \) points along the curve with
\( t \) values \( t_0,t_1,\ldots,t_i \), \( i \) representing the frame number
(\( i=1,\ldots,n \)).

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint 2.</b>
The velocity vector is

$$
\begin{equation*} (\frac{dx}{dt}, \frac{dy}{dt}) = (-\omega a\sin(\omega t), \omega b\cos(\omega t)),\end{equation*}
$$

and the magnitude of this vector becomes
\( \omega\sqrt{a^2\sin^2(\omega t) + b^2\cos^2(\omega t)} \).

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>planet_orbit</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex17">Exercise 39: Animate the evolution of Taylor polynomials</h2>

<p>
A general series approximation (to a function) can be written as

$$
\begin{equation*}
S(x; M, N)=\sum_{k=M}^{N} f_k(x)\tp
\end{equation*}
$$

For example, the Taylor polynomial of degree \( N \) for \( e^x \) equals
\( S(x; 0, N) \) with \( f_k(x)=x^k/k! \).  The purpose of the exercise is to
make a movie of how \( S(x;M,N) \) develops and improves as an
approximation as we add terms in the sum. That is, the frames in the
movie correspond to plots of \( S(x; M, M) \), \( S(x; M, M+1) \), \( S(x;
M,M+2) \), \( \ldots \), \( S(x; M, N) \).

<p>
<b>a)</b>
Make a function

<p>
<!-- begin verbatim block  ccq-->
<pre><code>animate_series(fk, M, N, xmin, xmax, ymin, ymax, n, exact)
</code></pre>
<!-- end verbatim block -->
for creating such animations. The argument <code>fk</code> holds a Python
function implementing the term \( f_k(x) \) in the sum, <code>M</code> and <code>N</code> are
the summation limits, the next arguments are the minimum and maximum
\( x \) and \( y \) values in the plot, <code>n</code> is the number of \( x \) points in the
curves to be plotted, and <code>exact</code> holds the function that \( S(x) \) aims
at approximating.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Here is some more information on how to write the <code>animate_series</code>
function. The function must accumulate the \( f_k(x) \) terms in a
variable \( s \), and for each \( k \) value, \( s \) is plotted against \( x \)
together with a curve reflecting the exact function.  Each plot must
be saved in a file, say with names <code>tmp_0000.png</code>, <code>tmp_0001.png</code>, and
so on (these filenames can be generated by <code>tmp_%04d.png</code>, using an
appropriate counter). Use the <code>movie</code> function to combine all the plot
files into a movie in a desired movie format.

<p>
In the beginning of the <code>animate_series</code> function, it is necessary to
remove all old plot files of the form <code>tmp_*.png</code>. This can be done by
the <code>glob</code> module and the <code>os.remove</code> function as exemplified in
the section <a href="._plot-solarized003.html#easyviz:movie">Making animations</a>.

<p>
<!-- --- end hint in exercise --- -->

<p>
<b>b)</b>
Call the <code>animate_series</code> function for the Taylor series for \( \sin x \),
where \( f_k(x) = (-1)^k {x^{2k+1}/(2k+1)!} \), and \( x\in [0,13\pi] \),
\( M=0 \), \( N=40 \), \( y\in [-2,2] \).

<p>
<b>c)</b>
Call the <code>animate_series</code> function for
the Taylor series for \( e^{-x} \), where \( f_k(x)=(-x)^k/k! \),
and \( x\in [0, 15] \), \( M=0 \), \( N=30 \), \( y\in [-0.5,1.4] \).

<p>
Filename: <code>animate_Taylor_series</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex4">Exercise 40: Plot the velocity profile for pipeflow</h2>

<p>
A fluid that flows through a (very long) pipe has zero velocity on the
pipe wall and a maximum velocity along the centerline of the pipe. The
velocity \( v \) varies through the pipe cross section according to the
following formula:

$$
\begin{equation}
v(r) = \left({\beta\over 2\mu_0}\right)^{{1/ n}}
{n \over n+1}\left( R^{1 + 1/n} - r^{1 + 1/n}\right),
\tag{33}
\end{equation}
$$

where \( R \) is the radius of the pipe, \( \beta \) is the pressure gradient
(the force that drives the flow through the pipe), \( \mu_0 \) is a
viscosity coefficient (small for air, larger for water and even larger
for toothpaste), \( n \) is a real number reflecting the viscous
properties of the fluid (\( n=1 \) for water and air, \( n < 1 \) for many modern
plastic materials), and \( r \) is a radial coordinate that measures the
distance from the centerline (\( r=0 \) is the centerline, \( r=R \) is the
pipe wall).

<p>
<b>a)</b>
Make a Python function that evaluates \( v(r) \).

<p>
<b>b)</b>
Plot \( v(r) \) as a function of
\( r\in [0,R] \), with \( R=1 \), \( \beta =0.02 \), \( \mu_0 =0.02 \), and \( n=0.1 \).

<p>
<b>c)</b>
Make an animation of how the \( v(r) \) curves
varies as \( n \) goes from 1 and down to 0.01. Because the maximum value of
\( v(r) \) decreases rapidly as \( n \) decreases, each curve can be normalized
by its \( v(0) \) value such that the maximum value is always unity.

<p>
Filename: <code>plot_velocity_pipeflow</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex8">Exercise 41: Plot sum-of-sines approximations to a function</h2>

<p>
The function
$$
\begin{equation*}
S(t;n) = {4\over\pi}\sum_{i=1}^n {1\over 2i-1}
\sin\left( {2(2i-1)\pi t\over T}\right)\tp
\end{equation*}
$$

is as approximation to

$$
\begin{equation*}
f(t) = \left\lbrace\begin{array}{ll}
1, & 0 < t < T/2,\\ 
0, & t = T/2,\\ 
-1, & T/2 < t < T
\end{array}\right.
\end{equation*}
$$

It can be shown that \( S(t;n)\rightarrow f(t) \) as \( n\rightarrow\infty \).

<p>
Plot \( S(t;1) \), \( S(t;3) \), \( S(t;20) \), \( S(t;200) \), and
the exact \( f(t) \) function in the same plot. Use \( T=2\pi \).
Filename: <code>sinesum1_plot</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex8m">Exercise 42: Animate the evolution of a sum-of-sine approximation to a function</h2>

<p>
First perform <a href="#sec:plot:ex8">Exercise 41: Plot sum-of-sines approximations to a function</a>.  A natural next step is to
animate the evolution of \( S(t;n) \) as \( n \) increases.  Create such an
animation and observe how the discontinuity in \( f(t) \) is poorly
approximated by \( S(t;n) \), even when \( n \) grows large (plot \( f(t) \) in
each frame).  This is a well-known deficiency, called Gibb's
phenomenon, when approximating discontinuous functions by sine or
cosine (Fourier) series.
Filename: <code>sinesum1_movie</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex14">Exercise 43: Plot functions from the command line</h2>

<p>
For quickly getting a plot of a function \( f(x) \) for \( x\in [x_{\rm
min},x_{\rm max}] \) it could be nice to a have a program that takes the
minimum amount of information from the command line and produces a
plot on the screen and saves the plot to a file <code>tmp.png</code>.  The usage
of the program goes as follows:

<p>
<!-- begin verbatim block  sys-->
<pre><code>plotf.py &quot;f(x)&quot; xmin xmax
</code></pre>
<!-- end verbatim block -->
Plotting \( e^{-0.2x}\sin (2\pi x) \) for \( x\in [0,4\pi] \) is then specified as

<p>
<!-- begin verbatim block  sys-->
<pre><code>plotf.py &quot;exp(-0.2*x)*sin(2*pi*x)&quot; 0 4*pi
</code></pre>
<!-- end verbatim block -->

<p>
Write the <code>plotf.py</code> program with as short code as possible (we leave
it to <a href="#sec:plot:ex14b">Exercise 44: Improve command-line input</a> to test for valid input).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Make \( x \) coordinates from the second and third command-line arguments and
then use <code>eval</code>
on the first argument.

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>plotf</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex14b">Exercise 44: Improve command-line input</h2>

<p>
Equip the program from <a href="#sec:plot:ex14">Exercise 43: Plot functions from the command line</a> with tests on valid
input on the command line. Also allow an optional fourth command-line
argument for the number of points along the function curve.  Set this
number to 501 if it is not given.
Filename: <code>plotf2</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex20">Exercise 45: Demonstrate energy concepts from physics</h2>

<p>
The vertical position \( y(t) \) of a ball thrown upward is given by \( y(t)
= v_0t - \frac{1}{2}gt^2 \), where \( g \) is the acceleration of gravity
and \( v_0 \) is the velocity at \( t=0 \).  Two important physical quantities
in this context are the potential energy, obtained by doing work
against gravity, and the kinetic energy, arising from motion.  The
potential energy is defined as \( P=mgy \), where \( m \) is the mass of the
ball. The kinetic energy is defined as \( K=\frac{1}{2}mv^2 \), where \( v \)
is the velocity of the ball, related to \( y \) by \( v(t)=y'(t) \).

<p>
Make a program that can plot \( P(t) \) and \( K(t) \) in the same plot, along
with their sum \( P+K \). Let \( t\in [0,2v_0/g] \). Read \( m \) and \( v_0 \) from
the command line. Run the program with various choices of \( m \) and
\( v_0 \) and observe that \( P+K \) is always constant in this motion. (In
fact, it turns out that \( P+K \) is constant for a large class of
motions, and this is a very important result in physics.)
Filename: <code>energy_physics</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:math:ex9">Exercise 46: Plot a w-like function</h2>

<p>
Define mathematically a function that looks like the &quot;w&quot; character.
Plot the function.
Also write a formal test function that verifies the implementation.
Filename: <code>plot_w</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:basic:exH4plot">Exercise 47: Plot a piecewise constant function</h2>

<p>
Consider the piecewise constant function defined in The exercise
named &quot;Implement a piecewise constant function&quot; in the document
<a href="http://hplgit.github.io/primer.html/doc/pub/funcif" target="_self">Functions and branching</a>
<a href="#Langtangen_TCSE6_funcif">[4]</a>.  Make a Python function
<code>plot_piecewise(data, xmax)</code> that draws a graph of the function, where
<code>data</code> is the nested list explained in mentioned exercise and <code>xmax</code>
is the maximum \( x \) coordinate. Use ideas from the section <a href="._plot-solarized004.html#sec:plot:pwisefunc">Piecewisely defined functions</a>.
Filename: <code>plot_piecewise_constant</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:basic:exH4vecz1">Exercise 48: Vectorize a piecewise constant function</h2>

<p>
Consider the piecewise constant function defined in The exercise
named &quot;Implement a piecewise constant function&quot; in the document
<a href="http://hplgit.github.io/primer.html/doc/pub/funcif" target="_self">Functions and branching</a>
<a href="#Langtangen_TCSE6_funcif">[4]</a>.
Make a vectorized implementation
<code>piecewise_constant_vec(x, data, xmax)</code> of such a function, where
<code>x</code> is an array.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
You can use ideas from the <code>Nv1</code> function in the section <a href="._plot-solarized005.html#sec:vec:hatfunc">Vectorization of a hat function</a>.
However, since the number of intervals is not known, it is necessary to
store the various intervals and conditions in lists.

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>piecewise_constant_vec</code>.

<p>
<!-- Closing remarks for this Exercise -->

<h3 id="___sec160">Remarks </h3>

<p>
Plotting the array returned from <code>piecewise_constant_vec</code> faces
the same problems as encountered in the section <a href="._plot-solarized004.html#sec:plot:pwisefunc">Piecewisely defined functions</a>.
It is better to make a custom plotting function that simply draws
straight horizontal lines in each
interval.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex:vizmidpoint">Exercise 49: Visualize approximations in the Midpoint integration rule</h2>

<p>
Consider the midpoint rule for
numerical integration.
Use Matplotlib to make an illustration of the midpoint rule
as shown to the left in Figure <a href="#sec:plot:ex:int:fig">22</a>.

<p>
<center> <!-- figure label: --> <div id="sec:plot:ex:int:fig"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 22:  Visualization of numerical integration rules, with the Midpoint rule to   the left and the Trapezoidal rule to the right.   The filled areas illustrate the deviations  in the approximation of the area under the curve.  <!-- caption label: sec:plot:ex:int:fig --> </p></center>
<p><img src="fig-plot/viz_midpoint_trapez.png" align="bottom" width=400></p>
</center>

<p>
The \( f(x) \) function used
in Figure <a href="#sec:plot:ex:int:fig">22</a> is

$$
\begin{equation*} f(x) = x(12-x) + \sin(\pi x),\quad x\in[0,10]\tp\end{equation*}
$$

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Look up the documentation of the Matplotlib function <code>fill_between</code>
and use this function to create the filled areas between \( f(x) \)
and the approximating rectangles.

<p>
Note that the <code>fill_between</code> requires the two curves to have the same
number of points.  For accurate visualization of \( f(x) \) you need quite
many \( x \) coordinates, and the rectangular approximation to \( f(x) \) must
be drawn using the same set of \( x \) coordinates.

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>viz_midpoint</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex:viztrapezoidal">Exercise 50: Visualize approximations in the Trapezoidal integration rule</h2>

<p>
Redo <a href="#sec:plot:ex:vizmidpoint">Exercise 49: Visualize approximations in the Midpoint integration rule</a> for the Trapezoidal rule
to produce the graph shown to the right in Figure <a href="#sec:plot:ex:int:fig">22</a>.
Filename: <code>viz_trapezoidal</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex13">Exercise 51: Experience overflow in a function</h2>

<p>
We are give the mathematical function

$$
\begin{equation*} v(x)={1-e^{x/\mu}\over 1-e^{1/\mu}},\end{equation*}
$$

where \( \mu \) is a parameter.

<p>
<b>a)</b>
Make a Python function <code>v(x, mu=1E-6, exp=math.exp)</code> for calculating the
formula for \( v(x) \) using <code>exp</code> as a possibly user-given exponential
function.  Let the <code>v</code> function return the nominator and denominator
in the formula as well as the fraction.

<p>
<b>b)</b>
Call the <code>v</code> function for various <code>x</code> values between 0 and 1 in a
<code>for</code> loop, let <code>mu</code> be <code>1E-3</code>, and have an inner <code>for</code> loop over two
different <code>exp</code> functions: <code>math.exp</code> and <code>numpy.exp</code>.  The output
will demonstrate how the denominator is subject to overflow and how
difficult it is to calculate this function on a computer.

<p>
<b>c)</b>
Plot \( v(x) \) for \( \mu =1,0.01, 0.001 \) on \( [0,1] \) using 10,000 points
to see what the function looks like.

<p>
<b>d)</b>
Convert <code>x</code> and <code>eps</code> to a higher precision representation of
real numbers, with the aid of the NumPy type <code>float96</code>, before
calling <code>v</code>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import numpy
x = numpy.float96(x); mu = numpy.float96(e)
</code></pre>
<!-- end verbatim block -->
Repeat point b) with these type of variables and observe how much better
results we get with <code>float96</code> compared with the standard <code>float</code> value,
which is <code>float64</code> (the number reflects the number of bits in the
machine's representation of a real number).

<p>
<b>e)</b>
Call the <code>v</code> function with <code>x</code> and <code>mu</code> as
<code>float32</code> variables and report how the function now behaves.

<p>
Filename: <code>boundary_layer_func1</code>.

<p>
<!-- Closing remarks for this Exercise -->

<h3 id="___sec164">Remarks </h3>

<p>
When an object (ball, car, airplane) moves through the air, there is a
very, very thin layer of air close to the object's surface where the
air velocity varies dramatically, from the same value as the velocity
of the object at the object's surface to zero a few centimeters away.
This layer is called a <em>boundary layer</em>. The physics in the boundary
layer is important for air resistance and cooling/heating of objects.
The change in velocity in the boundary layer is quite abrupt and can
be modeled by the functiion \( v(x) \), where \( x=1 \) is the object's
surface, and \( x=0 \) is some distance away where one cannot notice any
wind velocity \( v \) because of the passing object (\( v= 0 \)).  The wind
velocity coincides with the velocity of the object at \( x=1 \), here set
to \( v=1 \).  The parameter \( \mu \) is very small and related to the
viscosity of air.  With a small value of \( \mu  \), it becomes difficult
to calculate \( v(x) \) on a computer. The exercise demonstrates the
difficulties and provides a remedy.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:math:ex2">Exercise 52: Apply a function to a rank 2 array</h2>

<p>
Let \( A \) be the two-dimensional array

$$
\begin{equation*}
\left\lbrack\begin{array}{ccc}
0 & 2 & -1  \\ 
-1 & -1 & 0 \\ 
0 & 5 & 0
\end{array}\right\rbrack
\end{equation*}
$$

Apply the function \( f \) from <a href="#sec:plot:math:ex1">Exercise 5: Apply a function to a vector</a>
to each element in \( A \). Then
calculate the result of the array expression <code>A**3 + A*exp(A) + 1</code>,
and demonstrate that the end result of the two methods are the same.
Filename: <code>apply_arrayfunc</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:plot:ex11">Exercise 53: Explain why array computations fail</h2>

<p>
The following loop computes the array <code>y</code> from <code>x</code>:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; x = np.linspace(0, 1, 3)
&gt;&gt;&gt; y = np.zeros(len(x))
&gt;&gt;&gt; for i in range(len(x)):
...     y[i] = x[i] + 4
</code></pre>
<!-- end verbatim block -->
However, the alternative loop

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; for xi, yi in zip(x, y):
...     yi = xi + 5
</code></pre>
<!-- end verbatim block -->
leaves <code>y</code> unchanged. Why? Explain in detail what happens in each
pass of this loop and write down the contents of <code>xi</code>, <code>yi</code>,
<code>x</code>, and <code>y</code> as the loop progresses.
Filename: <code>find_errors_arraycomp</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="plot:linalg:exer:verify">Exercise 54: Verify linear algebra results</h2>

<p>
When we want to verify that a mathematical result is true, we often generate matrices or vectors with random elements and show that the result holds for
these &quot;arbitrary&quot; mathematical objects. As an example,
consider testing that \( A+B=B+A \) for matrices \( A \) and \( B \):

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def test_addition():
    n = 4  # matrix size
    A = matrix(random.rand(n, n))
    B = matrix(random.rand(n, n))

    tol = 1E-14
    result1 = A + B
    result2 = B + A
    assert abs(result1 - result2).max() &lt; tol
</code></pre>
<!-- end verbatim block -->
Use this technique to write test functions for the following mathematical
results:

<ol>
<li> \( (A + B)C = AC + BC \)</li>
<li> \( (AB)C = A(BC) \)</li>
<li> \( \text{rank}A=\text{rank}A^T \)</li>
<li> \( \det(AB) = \det A\det B \)</li>
<li> The eigenvalues if \( A \) equals the eigenvalues of \( A^T \) when \( A \) is square.</li>
</ol>

Filename: <code>verify_linalg</code>.

<p>
<!-- --- end exercise --- -->

<h1 id="___sec168">References </h1>

<p>
<!-- begin bibliography -->

<ol>
 <li> <div id="Langtangen_TCSE6_random"></div> <b>H. P. Langtangen</b>. 
    Random numbers and simple games,
    \emphhttp://hplgit.github.io/primer.html/doc/pub/random,
    <a href="http://hplgit.github.io/primer.html/doc/pub/random" target="_self"><tt>http://hplgit.github.io/primer.html/doc/pub/random</tt></a>.</li>
 <li> <div id="TCSE3"></div> <b>H. P. Langtangen</b>. 
    <em>Python Scripting for Computational Science</em>,
    3rd edition,
    <em>Texts in Computational Science and Engineering</em>,
    Springer,
    2009.</li>
 <li> <div id="Langtangen_TCSE6_input"></div> <b>H. P. Langtangen</b>. 
    User input and error handling,
    \emphhttp://hplgit.github.io/primer.html/doc/pub/input,
    <a href="http://hplgit.github.io/primer.html/doc/pub/input" target="_self"><tt>http://hplgit.github.io/primer.html/doc/pub/input</tt></a>.</li>
 <li> <div id="Langtangen_TCSE6_funcif"></div> <b>H. P. Langtangen</b>. 
    Functions and branching,
    \emphhttp://hplgit.github.io/primer.html/doc/pub/funcif,
    <a href="http://hplgit.github.io/primer.html/doc/pub/funcif" target="_self"><tt>http://hplgit.github.io/primer.html/doc/pub/funcif</tt></a>.</li>
</ol>

<!-- end bibliography -->

<p>
<!-- begin bottom navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._plot-solarized008.html">&laquo; Previous</a></div>
</td><td>
</td></tr></table>
<!-- end bottom navigation -->
</p>

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

