<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Array computing and curve plotting">
<meta name="keywords" content="vectors,vector computing,scalar (math quantity),heterogeneous lists,Numerical Python,NumPy,array (datatype),array computing,vectorization,array slicing,subarrays,allocate,vectorization,scalar code,curve plotting,plotting,making graphs,backend (Easyviz),backend (Easyviz),remove files (in Python),delete files (in Python),boolean indexing,boolean indexing,in-place array arithmetics,check an object's type,shape (of an array),array shape,matrix,shape (of an array),array shape,eigenvalues,eigenvectors,inverse,determinant,rank of a matrix,least squares approximation,Trapezoidal rule for integration,Lagrange's interpolation formula,interpolation,Midpoint rule for integration,Trapezoidal rule for integration">

<title>Array computing and curve plotting</title>


<link href="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
code { padding: 0px; background-color: inherit; }
pre {
  border: 0pt solid #93a1a1;
  box-shadow: none;
}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [('Table of contents',
               1,
               'table_of_contents',
               'table_of_contents'),
              ('Vectors', 1, None, '___sec0'),
              ('The vector concept', 2, None, '___sec1'),
              ('Mathematical operations on vectors',
               2,
               'sec:plot:vectors',
               'sec:plot:vectors'),
              ('Vector arithmetics and vector functions',
               2,
               'sec:plot:arraycomp',
               'sec:plot:arraycomp'),
              ('Arrays in Python programs', 1, None, '___sec4'),
              ('Using lists for collecting function data',
               2,
               'sec:plot:listdata',
               'sec:plot:listdata'),
              ('Basics of numerical Python arrays',
               2,
               'sec:plot:array:basics',
               'sec:plot:array:basics'),
              ('Computing coordinates and function values',
               2,
               None,
               '___sec7'),
              ('Vectorization',
               2,
               'sec:plot:vectorization',
               'sec:plot:vectorization'),
              ('Curve plotting',
               1,
               'sec:plot:curveplots',
               'sec:plot:curveplots'),
              ('MATLAB-style plotting with Matplotlib',
               2,
               'sec:plot:pylab',
               'sec:plot:pylab'),
              ('A basic plot', 3, None, '___sec11'),
              ('Decorating the plot', 3, None, '___sec12'),
              ('Plotting multiple curves', 3, None, '___sec13'),
              ('Placing several plots in one figure', 3, None, '___sec14'),
              ('Matplotlib; pyplot prefix',
               2,
               'sec:plot:pyplot',
               'sec:plot:pyplot'),
              ('SciTools and Easyviz',
               2,
               'sec:plot:SciTools',
               'sec:plot:SciTools'),
              ('Importing SciTools and Easyviz', 3, None, '___sec17'),
              ('A basic plot', 3, None, '___sec18'),
              ('Decorating the plot', 3, None, '___sec19'),
              ('Plotting multiple curves', 3, None, '___sec20'),
              ('Changing backend', 3, None, '___sec21'),
              ('Placing several plots in one figure', 3, None, '___sec22'),
              ('Other plotting alternatives', 3, None, '___sec23'),
              ('Making animations', 2, 'easyviz:movie', 'easyviz:movie'),
              ('Example', 3, None, '___sec25'),
              ('Animation in Easyviz', 3, None, '___sec26'),
              ('Basic animation in Matplotlib', 3, None, '___sec27'),
              ('Using FuncAnimation in Matplotlib', 3, None, '___sec28'),
              ('Making videos', 2, 'sec:plot:video', 'sec:plot:video'),
              ('Animated GIF file', 3, None, '___sec30'),
              ('MP4, Ogg, WebM, and Flash videos', 3, None, '___sec31'),
              ('Curve plots in pure text', 2, None, '___sec32'),
              ('Plotting difficulties',
               1,
               'sec:plot:difficulties',
               'sec:plot:difficulties'),
              ('Piecewisely defined functions',
               2,
               'sec:plot:pwisefunc',
               'sec:plot:pwisefunc'),
              ('Example: The Heaviside function', 3, None, '___sec35'),
              ('Example: A hat function', 3, None, '___sec36'),
              ('Rapidly varying functions',
               2,
               'sec:plot:sin1x',
               'sec:plot:sin1x'),
              ('More advanced vectorization of functions',
               1,
               'sec:plot:if:vectorize',
               'sec:plot:if:vectorize'),
              ('Vectorization of StringFunction objects',
               2,
               'sec:plot:StringFunction:vectorize',
               'sec:plot:StringFunction:vectorize'),
              ('Vectorization of the Heaviside function',
               2,
               'sec:vec:Heaviside',
               'sec:vec:Heaviside'),
              ('Loop', 3, None, '___sec41'),
              ('Automatic vectorization', 3, None, '___sec42'),
              ('Mixing boolean and floating-point calculations',
               3,
               None,
               '___sec43'),
              ('Manual vectorization', 3, None, '___sec44'),
              ('Vectorization of a hat function',
               2,
               'sec:vec:hatfunc',
               'sec:vec:hatfunc'),
              ('More on numerical Python arrays',
               1,
               'sec:plot:numpy:more',
               'sec:plot:numpy:more'),
              ('Copying arrays', 2, None, '___sec47'),
              ('In-place arithmetics',
               2,
               'sec:plot:numpy:inplace',
               'sec:plot:numpy:inplace'),
              ('Allocating arrays', 2, None, '___sec49'),
              ('Generalized indexing',
               2,
               'sec:plot:generalized:index',
               'sec:plot:generalized:index'),
              ('Testing for the array type', 2, None, '___sec51'),
              ('Example: Vectorizing a constant function',
               3,
               None,
               '___sec52'),
              ('Compact syntax for array generation', 2, None, '___sec53'),
              ('Shape manipulation', 2, None, '___sec54'),
              ('High-performance computing with arrays',
               1,
               'sec:hpc',
               'sec:hpc'),
              ('Example: `axpy`', 3, None, '___sec56'),
              ('Scalar implementation',
               2,
               'sec:hpc:scalar',
               'sec:hpc:scalar'),
              ('Vectorized implementation', 2, 'sec:hpc:vec', 'sec:hpc:vec'),
              ('Memory-saving implementation',
               2,
               'sec:hpc:vec:inplace',
               'sec:hpc:vec:inplace'),
              ('Analysis of memory usage',
               2,
               'sec:hpc:vec:memory_profiler',
               'sec:hpc:vec:memory_profiler'),
              ('Analysis of the CPU time',
               2,
               'sec:hpc:vec:line_profiler',
               'sec:hpc:vec:line_profiler'),
              ('Higher-dimensional arrays',
               1,
               'sec:plot:2Darrays',
               'sec:plot:2Darrays'),
              ('Matrices and arrays', 2, None, '___sec63'),
              ('Two-dimensional numerical Python arrays',
               2,
               'sec:plot:2D:arrays',
               'sec:plot:2D:arrays'),
              ('Array computing',
               2,
               'sec:plot:array2comp',
               'sec:plot:array2comp'),
              ('Remark', 3, None, '___sec66'),
              ('Matrix objects',
               2,
               'sec:plot:numpy:matrix',
               'sec:plot:numpy:matrix'),
              ('Some common linear algebra operations', 1, None, '___sec68'),
              ('Inverse, determinant, and eigenvalues', 2, None, '___sec69'),
              ('Products', 2, None, '___sec70'),
              ('Norms', 2, None, '___sec71'),
              ('Sum and extreme values', 2, None, '___sec72'),
              ('Indexing', 2, None, '___sec73'),
              ('Transpose and upper/lower triangular parts',
               2,
               None,
               '___sec74'),
              ('Solving linear systems', 2, None, '___sec75'),
              ('Matrix row and column operations', 2, None, '___sec76'),
              ('Computing the rank of a matrix', 2, None, '___sec77'),
              ('Symbolic linear algebra', 2, None, '___sec78'),
              ('Plotting of scalar and vector fields',
               1,
               'plot:surf',
               'plot:surf'),
              ('Installation', 2, 'plot:surf:install', 'plot:surf:install'),
              ('Surface plots',
               2,
               'plot:surf:mesh_surf',
               'plot:surf:mesh_surf'),
              ('Grid for 2D scalar fields', 3, None, '___sec82'),
              ('Parameterized curve',
               2,
               'plot:surf:3Dcurve',
               'plot:surf:3Dcurve'),
              ('Contour lines',
               2,
               'plot:surf:contours',
               'plot:surf:contours'),
              ('The gradient vector field',
               2,
               'plot:surf:gradient',
               'plot:surf:gradient'),
              ('Matplotlib', 1, None, '___sec86'),
              ('Surface plots',
               2,
               'matplotlibsurfaceplots',
               'matplotlibsurfaceplots'),
              ('Contour plots',
               2,
               'matplotlibcontourplots',
               'matplotlibcontourplots'),
              ('Vector field plots',
               2,
               'plot:surf:mpl:quiver',
               'plot:surf:mpl:quiver'),
              ('Mayavi', 1, None, '___sec90'),
              ('Surface plots', 2, None, '___sec91'),
              ('Subplots', 3, None, '___sec92'),
              ('Contour plots', 2, None, '___sec93'),
              ('Vector field plots',
               2,
               'plot:surf:mayavi:quiver',
               'plot:surf:mayavi:quiver'),
              ('A 3D scalar field and its gradient field',
               2,
               None,
               '___sec95'),
              ('Animations', 2, None, '___sec96'),
              ('Summary', 1, None, '___sec97'),
              ('Chapter topics', 2, None, '___sec98'),
              ('Array computing', 3, None, '___sec99'),
              ('Plotting curves', 3, None, '___sec100'),
              ('Making movies', 3, None, '___sec101'),
              ('Terminology', 3, None, '___sec102'),
              ('Example: Animating a function',
               2,
               'sec:plot:summarizing',
               'sec:plot:summarizing'),
              ('Problem', 3, None, '___sec104'),
              ('Solution', 3, None, '___sec105'),
              ('Scaling', 3, None, '___sec106'),
              ('Exercises', 1, 'sec:plot:exer', 'sec:plot:exer'),
              ('Exercise 1: Fill lists with function values',
               2,
               'sec:plot:ex1',
               'sec:plot:ex1'),
              ('Exercise 2: Fill arrays; loop version',
               2,
               'sec:plot:ex2',
               'sec:plot:ex2'),
              ('Exercise 3: Fill arrays; vectorized version',
               2,
               'sec:plot:ex2b',
               'sec:plot:ex2b'),
              ('Exercise 4: Plot a function',
               2,
               'sec:plot:ex2c',
               'sec:plot:ex2c'),
              ('Exercise 5: Apply a function to a vector',
               2,
               'sec:plot:math:ex1',
               'sec:plot:math:ex1'),
              ('Exercise 6: Simulate by hand a vectorized expression',
               2,
               'sec:plot:ex3',
               'sec:plot:ex3'),
              ('Exercise 7: Demonstrate array slicing',
               2,
               'sec:plot:ex15d',
               'sec:plot:ex15d'),
              ('Exercise 8: Replace list operations by array computing',
               2,
               'sec:plot:ex33',
               'sec:plot:ex33'),
              ('Exercise 9: Plot a formula',
               2,
               'sec:plot:ex15',
               'sec:plot:ex15'),
              ('Exercise 10: Plot a formula for several parameters',
               2,
               'sec:plot:ex15b',
               'sec:plot:ex15b'),
              ('Exercise 11: Specify the extent of the axes in a plot',
               2,
               'sec:plot:ex15ba',
               'sec:plot:ex15ba'),
              ('Exercise 12: Plot exact and inexact Fahrenheit-Celsius conversion formulas',
               2,
               'sec:plot:ex15c',
               'sec:plot:ex15c'),
              ('Exercise 13: Plot the trajectory of a ball',
               2,
               'sec:plot:ex5',
               'sec:plot:ex5'),
              ('Exercise 14: Plot data in a two-column file',
               2,
               'sec:files:ex12',
               'sec:files:ex12'),
              ('Remarks', 3, None, '___sec122'),
              ('Exercise 15: Write function data to file',
               2,
               'sec:files:ex12e',
               'sec:files:ex12e'),
              ('Exercise 16: Plot data from a file',
               2,
               'sec:files:ex12c',
               'sec:files:ex12c'),
              ('Exercise 17: Write table to file',
               2,
               'sec:files:exer:write_table',
               'sec:files:exer:write_table'),
              ('Exercise 18: Fit a polynomial to data points',
               2,
               'sec:files:ex12c2',
               'sec:files:ex12c2'),
              ('Exercise 19: Fit a polynomial to experimental data',
               2,
               'sec:files:ex19',
               'sec:files:ex19'),
              ('Exercise 20: Read acceleration data and find velocities',
               2,
               'sec:files:ex22',
               'sec:files:ex22'),
              ('Exercise 21: Read acceleration data and plot velocities',
               2,
               'sec:files:ex23',
               'sec:files:ex23'),
              ("Exercise 22: Plot a trip's path and velocity from GPS coordinates",
               2,
               'sec:files:ex24',
               'sec:files:ex24'),
              ('Exercise 23: Vectorize the Midpoint rule for integration',
               2,
               'sec:class:exer:sum',
               'sec:class:exer:sum'),
              ('Remarks', 3, None, '___sec132'),
              ('Exercise 24: Vectorize a function for computing the area of a polygon',
               2,
               'sec:plot:exer:area:polygon:vec',
               'sec:plot:exer:area:polygon:vec'),
              ("Exercise 25: Implement Lagrange's interpolation formula",
               2,
               'sec:class:ex27a',
               'sec:class:ex27a'),
              ("Exercise 26: Plot Lagrange's interpolating polynomial",
               2,
               'sec:class:ex27b',
               'sec:class:ex27b'),
              ("Exercise 27: Investigate the behavior of Lagrange's interpolating polynomials",
               2,
               'sec:class:ex27c',
               'sec:class:ex27c'),
              ('Remarks', 3, None, '___sec137'),
              ('Exercise 28: Plot a wave packet',
               2,
               'sec:plot:ex5d',
               'sec:plot:ex5d'),
              ('Exercise 29: Judge a plot',
               2,
               'sec:plot:ex7',
               'sec:plot:ex7'),
              ('Exercise 30: Plot the viscosity of water',
               2,
               'sec:plot:ex13c',
               'sec:plot:ex13c'),
              ('Exercise 31: Explore a complicated function graphically',
               2,
               'sec:plot:ex16',
               'sec:plot:ex16'),
              ('Exercise 32: Plot Taylor polynomial approximations to $\\sin x$',
               2,
               'sec:plot:ex5b',
               'sec:plot:ex5b'),
              ('Exercise 33: Animate a wave packet',
               2,
               'sec:plot:ex5e',
               'sec:plot:ex5e'),
              ('Exercise 34: Animate a smoothed Heaviside function',
               2,
               'sec:plot:ex32',
               'sec:plot:ex32'),
              ('Exercise 35: Animate two-scale temperature variations',
               2,
               'sec:plot:ex18',
               'sec:plot:ex18'),
              ('Remarks', 3, None, '___sec146'),
              ('Exercise 36: Use non-uniformly distributed coordinates for visualization',
               2,
               'sec:plot:ex19',
               'sec:plot:ex19'),
              ('Exercise 37: Animate a sequence of approximations to $\\pi$',
               2,
               'sec:plot:ex31',
               'sec:plot:ex31'),
              ("Exercise 38: Animate a planet's orbit",
               2,
               'sec:plot:ex5g',
               'sec:plot:ex5g'),
              ('Exercise 39: Animate the evolution of Taylor polynomials',
               2,
               'sec:plot:ex17',
               'sec:plot:ex17'),
              ('Exercise 40: Plot the velocity profile for pipeflow',
               2,
               'sec:plot:ex4',
               'sec:plot:ex4'),
              ('Exercise 41: Plot sum-of-sines approximations to a function',
               2,
               'sec:plot:ex8',
               'sec:plot:ex8'),
              ('Exercise 42: Animate the evolution of a sum-of-sine approximation to a function',
               2,
               'sec:plot:ex8m',
               'sec:plot:ex8m'),
              ('Exercise 43: Plot functions from the command line',
               2,
               'sec:plot:ex14',
               'sec:plot:ex14'),
              ('Exercise 44: Improve command-line input',
               2,
               'sec:plot:ex14b',
               'sec:plot:ex14b'),
              ('Exercise 45: Demonstrate energy concepts from physics',
               2,
               'sec:plot:ex20',
               'sec:plot:ex20'),
              ('Exercise 46: Plot a w-like function',
               2,
               'sec:plot:math:ex9',
               'sec:plot:math:ex9'),
              ('Exercise 47: Plot a piecewise constant function',
               2,
               'sec:basic:exH4plot',
               'sec:basic:exH4plot'),
              ('Exercise 48: Vectorize a piecewise constant function',
               2,
               'sec:basic:exH4vecz1',
               'sec:basic:exH4vecz1'),
              ('Remarks', 3, None, '___sec160'),
              ('Exercise 49: Visualize approximations in the Midpoint integration rule',
               2,
               'sec:plot:ex:vizmidpoint',
               'sec:plot:ex:vizmidpoint'),
              ('Exercise 50: Visualize approximations in the Trapezoidal integration rule',
               2,
               'sec:plot:ex:viztrapezoidal',
               'sec:plot:ex:viztrapezoidal'),
              ('Exercise 51: Experience overflow in a function',
               2,
               'sec:plot:ex13',
               'sec:plot:ex13'),
              ('Remarks', 3, None, '___sec164'),
              ('Exercise 52: Apply a function to a rank 2 array',
               2,
               'sec:plot:math:ex2',
               'sec:plot:math:ex2'),
              ('Exercise 53: Explain why array computations fail',
               2,
               'sec:plot:ex11',
               'sec:plot:ex11'),
              ('Exercise 54: Verify linear algebra results',
               2,
               'plot:linalg:exer:verify',
               'plot:linalg:exer:verify'),
              ('References', 1, None, '___sec168')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\tp}{\thinspace .}
$$




    
<a name="part0007"></a>
<p>
<!-- begin top navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._plot-solarized006.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._plot-solarized008.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end top navigation -->
</p>

<p>
<!-- !split -->
<p style="font-size:80%">This chapter is taken from the book <a href="http://www.springer.com/gp/book/9783662498866">A Primer on Scientific Programming with Python</a> by H. P. Langtangen, 5th edition, Springer, 2016.</p>

<h1 id="sec:plot:2Darrays">Higher-dimensional arrays</h1>

<h2 id="___sec63">Matrices and arrays </h2>

<p>
Vectors appeared when mathematicians needed to calculate with a list
of numbers.  When they needed a table (or a list of lists in Python
terminology), they invented the concept of <em>matrix</em> (singular) and
<em>matrices</em> (plural).  A table of numbers has the numbers ordered into
rows and columns. One example is

$$
\begin{equation*}
\left\lbrack\begin{array}{cccc}
0 & 12 & -1 & 5\\ 
-1 & -1 & -1 & 0\\ 
11 & 5 & 5 & -2
\end{array}\right\rbrack
\end{equation*}
$$

This table with three rows and four columns is called a \( 3\times4 \)
matrix (mathematicians may not like this sentence, but it suffices for
our purposes).  If the symbol \( A \) is associated with this matrix,
\( A_{i,j} \) denotes the number in row number \( i \) and column number \( j \).
Counting rows and columns from 0, we have, for instance, \( A_{0,0}=0 \)
and \( A_{2,3}=-2 \). We can write a general \( m\times n \) matrix \( A \) as

$$
\begin{equation*}
\left\lbrack\begin{array}{ccc}
A_{0,0} & \cdots &  A_{0,n-1}\\ 
\vdots & \ddots &  \vdots\\ 
A_{m-1,0} & \cdots & A_{m-1,n-1}
\end{array}\right\rbrack
\end{equation*}
$$

Matrices can be added and subtracted. They can also be multiplied by a
scalar (a number), and there is a concept of length or size.  The
formulas are quite similar to those presented for vectors, but the
exact form is not important here.

<p>
We can generalize the concept of table and matrix to <em>array</em>, which
holds quantities with in general \( d \) indices.  Equivalently we say
that the array has rank \( d \).  For \( d=3 \), an array \( A \) has elements
with three indices: \( A_{p,q,r} \).  If \( p \) goes from 0 to \( n_p-1 \), \( q \)
from 0 to \( n_q-1 \), and \( r \) from 0 to \( n_r-1 \), the \( A \) array has
\( n_p\times n_q\times n_r \) elements in total.  We may speak about the
<em>shape</em> of the array, which is a \( d \)-vector holding the number of
elements in each &quot;array direction&quot;, i.e., the number of elements for
each index. For the mentioned \( A \) array, the shape is \( (n_p,n_q,n_r) \).

<p>
The special case of \( d=1 \) is a vector, and \( d=2 \) corresponds to a
matrix.  When we program we may skip thinking about vectors and
matrices (if you are not so familiar with these concepts from a
mathematical point of view) and instead just work with arrays. The
number of indices corresponds to what is convenient in the programming
problem we try to solve.

<h2 id="sec:plot:2D:arrays">Two-dimensional numerical Python arrays</h2>

<p>
Consider a nested list <code>table</code> of two-pairs <code>[C, F]</code>
constructed by

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; Cdegrees = [-30 + i*10 for i in range(3)]
&gt;&gt;&gt; Fdegrees = [9./5*C + 32 for C in Cdegrees]
&gt;&gt;&gt; table = [[C, F] for C, F in zip(Cdegrees, Fdegrees)]
&gt;&gt;&gt; print table
[[-30, -22.0], [-20, -4.0], [-10, 14.0]]
</code></pre>
<!-- end verbatim block -->
This nested list can be turned into an array,

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; table2 = np.array(table)
&gt;&gt;&gt; print table2
[[-30. -22.]
 [-20.  -4.]
 [-10.  14.]]
&gt;&gt;&gt; type(table2)
&lt;type 'numpy.ndarray'&gt;
</code></pre>
<!-- end verbatim block -->
We say that <code>table2</code> is a <em>two-dimensional</em> array, or an array
of rank 2.

<p>
The <code>table</code> list and the <code>table2</code> array are stored very differently in
memory. The <code>table</code> variable refers to a list object containing three
elements.  Each of these elements is a reference to a separate list
object with two elements, where each element refers to a separate
<code>float</code> object.  The <code>table2</code> variable is a reference to a single
array object that again refers to a consecutive sequence of bytes in
memory where the six floating-point numbers are stored. The data
associated with <code>table2</code> are found in one chunk in the computer's
memory, while the data associated with <code>table</code> are scattered around in
memory. On today's machines, it is much more expensive to find data in
memory than to compute with the data. Arrays make the data fetching
more efficient, and this is major reason for using arrays.  However,
this efficiency gain is only present for very large arrays, not for a
\( 3\times 2 \) array.

<p>
Indexing a nested list is done in two steps, first the outer list is
indexed, giving access to an element that is another list, and then
this latter list is indexed:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; table[1][0]     # table[1] is [-20,4], whose index 0 holds -20
-20
</code></pre>
<!-- end verbatim block -->
This syntax works for two-dimensional arrays too:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; table2[1][0]
-20.0
</code></pre>
<!-- end verbatim block -->
but there is another syntax that is more common for arrays:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; table2[1,0]
-20.0
</code></pre>
<!-- end verbatim block -->

<p>
A two-dimensional array reflects a table and has a certain number of
rows and columns. We refer to rows as the <em>first dimension</em> of the
array and columns as the <em>second dimension</em>. These two dimensions are
available as <code>table2.shape</code>:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; table2.shape
(3, 2)
</code></pre>
<!-- end verbatim block -->
Here, 3 is the number of rows and 2 is the number of columns.

<p>
A loop over all the elements in a two-dimensional array is usually
expressed as two <em>nested</em> <code>for</code> loops, one for each index:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; for i in range(table2.shape[0]):
...     for j in range(table2.shape[1]):
...         print 'table2[%d,%d] = %g' % (i, j, table2[i,j])
...
table2[0,0] = -30
table2[0,1] = -22
table2[1,0] = -20
table2[1,1] = -4
table2[2,0] = -10
table2[2,1] = 14
</code></pre>
<!-- end verbatim block -->
An alternative (but less efficient) way of visiting each element in an
array with any number of dimensions makes use of a single <code>for</code> loop:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; for index_tuple, value in np.ndenumerate(table2):
...     print 'index %s has value %g' % \ 
...           (index_tuple, table2[index_tuple])
...
index (0,0) has value -30
index (0,1) has value -22
index (1,0) has value -20
index (1,1) has value -4
index (2,0) has value -10
index (2,1) has value 14
</code></pre>
<!-- end verbatim block -->

<p>
In the same way as we can extract sublists of lists, we can extract
subarrays of arrays using slices.

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>table2[0:table2.shape[0], 1]  # 2nd column (index 1)
array([-22.,  -4.,  14.])

&gt;&gt;&gt; table2[0:, 1]             # same
array([-22.,  -4.,  14.])

&gt;&gt;&gt; table2[:, 1]              # same
array([-22.,  -4.,  14.])
</code></pre>
<!-- end verbatim block -->
To illustrate array slicing further, we create a bigger array:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; t = np.linspace(1, 30, 30).reshape(5, 6)
&gt;&gt;&gt; t
array([[  1.,   2.,   3.,   4.,   5.,   6.],
       [  7.,   8.,   9.,  10.,  11.,  12.],
       [ 13.,  14.,  15.,  16.,  17.,  18.],
       [ 19.,  20.,  21.,  22.,  23.,  24.],
       [ 25.,  26.,  27.,  28.,  29.,  30.]])

&gt;&gt;&gt; t[1:-1:2, 2:]
array([[  9.,  10.,  11.,  12.],
       [ 21.,  22.,  23.,  24.]])
</code></pre>
<!-- end verbatim block -->
To understand the slice, look at the original <code>t</code> array and pick out
the two rows corresponding to the first slice <code>1:-1:2</code>,

<p>
<!-- begin verbatim block  ccq-->
<pre><code>       [  7.,   8.,   9.,  10.,  11.,  12.]
       [ 19.,  20.,  21.,  22.,  23.,  24.]
</code></pre>
<!-- end verbatim block -->
Among the rows, pick the columns corresponding to the second slice <code>2:</code>,

<p>
<!-- begin verbatim block  ccq-->
<pre><code>       [  9.,  10.,  11.,  12.]
       [ 21.,  22.,  23.,  24.]
</code></pre>
<!-- end verbatim block -->

<p>
Another example is

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; t[:-2, :-1:2]
array([[  1.,   3.,   5.],
       [  7.,   9.,  11.],
       [ 13.,  15.,  17.]])
</code></pre>
<!-- end verbatim block -->
Generalized indexing as described for one-dimensional arrays in
the section <a href="._plot-solarized006.html#sec:plot:generalized:index">Generalized indexing</a> requires a more comprehensive
syntax for higher-dimensional arrays.  Say we want to extract a
subarray of <code>t</code> that consists of the rows with indices 0 and 3 and the
columns with indices 1 and 2:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; t[np.ix_([0,3], [1,2])]
array([[  2.,   3.],
       [ 20.,  21.]])
&gt;&gt;&gt; t[np.ix_([0,3], [1,2])] = 0
&gt;&gt;&gt; t
array([[  1.,   0.,   0.,   4.,   5.,   6.],
       [  7.,   8.,   9.,  10.,  11.,  12.],
       [ 13.,  14.,  15.,  16.,  17.,  18.],
       [ 19.,   0.,   0.,  22.,  23.,  24.],
       [ 25.,  26.,  27.,  28.,  29.,  30.]])
</code></pre>
<!-- end verbatim block -->

<p>
Recall that slices only gives a view to the array, not a copy of the values:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; a = t[1:-1:2, 1:-1]
&gt;&gt;&gt; a
array([[  8.,   9.,  10.,  11.],
       [  0.,   0.,  22.,  23.]])
&gt;&gt;&gt; a[:,:] = -99
&gt;&gt;&gt; a
array([[-99., -99., -99., -99.],
       [-99., -99., -99., -99.]])
&gt;&gt;&gt; t  # is t changed to? yes!
array([[  1.,   0.,   0.,   4.,   5.,   6.],
       [  7., -99., -99., -99., -99.,  12.],
       [ 13.,  14.,  15.,  16.,  17.,  18.],
       [ 19., -99., -99., -99., -99.,  24.],
       [ 25.,  26.,  27.,  28.,  29.,  30.]])
</code></pre>
<!-- end verbatim block -->

<h2 id="sec:plot:array2comp">Array computing</h2>

<p>
The operations on vectors in the section <a href="._plot-solarized001.html#sec:plot:arraycomp">Vector arithmetics and vector functions</a> can quite
straightforwardly be extended to arrays of any dimension.  Consider
the definition of applying a function \( f(v) \) to a vector \( v \): we apply
the function to each element \( v_i \) in \( v \).  For a two-dimensional
array \( A \) with elements \( A_{i,j} \), \( i=0,\ldots,m \), \( j=0,\ldots,n \), the
same definition yields

$$
\begin{equation*} f(A) = (f(A_{0,0}),\ldots,f(A_{m-1,0}),f(A_{1,0}),
\ldots,f(A_{m-1,n-1}))\tp \end{equation*}
$$

For an array \( B \) with any rank, \( f(B) \) means applying \( f \) to
each array entry.

<p>
The asterisk operation from the section <a href="._plot-solarized001.html#sec:plot:arraycomp">Vector arithmetics and vector functions</a> is also
naturally extended to arrays: \( A*B \) means multiplying an element in
\( A \) by the corresponding element in \( B \), i.e., element \( (i,j) \) in
\( A*B \) is \( A_{i,j}B_{i,j} \).  This definition naturally extends to
arrays of any rank, provided the two arrays have the same shape.

<p>
Adding a scalar to an array implies adding the scalar to each element
in the array. Compound expressions involving arrays, e.g.,
\( \exp(-A^2)*A +1 \), work as for vectors. One can in fact just imagine
that all the array elements are stored after each other in a long
vector (this is actually the way the array elements are stored in the
computer's memory), and the array operations can then easily be
defined in terms of the vector operations from the section <a href="._plot-solarized001.html#sec:plot:arraycomp">Vector arithmetics and vector functions</a>.

<h3 id="___sec66">Remark </h3>

<p>
Readers with knowledge of matrix computations may get confused by the
meaning of \( A^2 \) in matrix computing and \( A^2 \) in array computing. The
former is a matrix-matrix product, while the latter means squaring all
elements of \( A \). Which rule to apply, depends on the context, i.e.,
whether we are doing linear algebra or vectorized arithmetics. In
mathematical typesetting, \( A^2 \) can be written as \( AA \), while the
array computing expression \( A^2 \) can be alternatively written as
\( A*A \).  In a program, <code>A*A</code> and <code>A**2</code> are identical computations,
meaning squaring all elements (array arithmetics). With NumPy arrays
the matrix-matrix product is obtained by <code>dot(A, A)</code>. The
matrix-vector product \( Ax \), where \( x \) is a vector, is computed by
<code>dot(A, x)</code>. However, with matrix objects (see the section <a href="#sec:plot:numpy:matrix">Matrix objects</a>) <code>A*A</code> implies the mathematical matrix
multiplication \( AA \).

<p>
<!-- Copied out old_plot3d.do.txt -->

<p>
<!-- Insert linear algebra here -->

<h2 id="sec:plot:numpy:matrix">Matrix objects</h2>

<p>
This section only makes sense if you are familiar with basic linear
algebra and the matrix concept.  The arrays created so far have been
of type <code>ndarray</code>.  NumPy also has a matrix type called <code>matrix</code> or
<code>mat</code> for one- and two-dimensional arrays. One-dimensional arrays are
then extended with one extra dimension such that they become matrices,
i.e., either a row vector or a column vector:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; x1 = np.array([1, 2, 3], float)
&gt;&gt;&gt; x2 = np.matrix(x1)          # or mat(x1)
&gt;&gt;&gt; x2                          # row vector
matrix([[ 1.,  2.,  3.]])
&gt;&gt;&gt; x3 = mat(x1).T              # transpose = column vector
&gt;&gt;&gt; x3
matrix([[ 1.],
        [ 2.],
        [ 3.]])

&gt;&gt;&gt; type(x3)
&lt;class 'numpy.matrixlib.defmatrix.matrix'&gt;
&gt;&gt;&gt; isinstance(x3, np.matrix)
True
</code></pre>
<!-- end verbatim block -->
A special feature of <code>matrix</code> objects is that the multiplication
operator represents the matrix-matrix, vector-matrix, or matrix-vector
product as we know from linear algebra:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; A = np.eye(3)                 # identity matrix
&gt;&gt;&gt; A
array([[ 1.,  0.,  0.],
       [ 0.,  1.,  0.],
       [ 0.,  0.,  1.]])
&gt;&gt;&gt; A = mat(A)
&gt;&gt;&gt; A
matrix([[ 1.,  0.,  0.],
        [ 0.,  1.,  0.],
        [ 0.,  0.,  1.]])
&gt;&gt;&gt; y2 = x2*A                     # vector-matrix product
&gt;&gt;&gt; y2
matrix([[ 1.,  2.,  3.]])
&gt;&gt;&gt; y3 = A*x3                     # matrix-vector product
&gt;&gt;&gt; y3
matrix([[ 1.],
        [ 2.],
        [ 3.]])
</code></pre>
<!-- end verbatim block -->
One should note here that the multiplication operator between standard
<code>ndarray</code> objects is quite different!

<p>
Readers who are familiar with MATLAB, or intend to use Python and
MATLAB together, should seriously think about programming with
<code>matrix</code> objects instead of <code>ndarray</code> objects, because the <code>matrix</code>
type behaves quite similar to matrices and vectors in MATLAB.
Nevertheless, <code>matrix</code> cannot be used for arrays of larger dimension
than two.

<h1 id="___sec68">Some common linear algebra operations </h1>

<p>
Python has strong support for numerical linear algebra, much like the
functionality found in MATLAB. Some of the most widely used
operations are exemplified below.
<!-- Contrary to MATLAB, where the fundamental data structure is the matrix, -->
<!-- the NumPy package in Python features arrays of any dimension. -->

<h2 id="___sec69">Inverse, determinant, and eigenvalues </h2>

<p>
We start with showing how to find the inverse and the determinant of a
matrix, and how to compute the eigenvalues and eigenvectors:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; A = np.array([[2, 0], [0, 5]], dtype=float)

&gt;&gt;&gt; np.linalg.inv(A)  # inverse matrix
array([[ 0.5,  0. ],
       [ 0. ,  0.2]])

&gt;&gt;&gt; np.linalg.det(A)  # determinant
9.9999999999999982

&gt;&gt;&gt; eig_values, eig_vectors = np.linalg.eig(A)
&gt;&gt;&gt; eig_values
array([ 2.,  5.])
&gt;&gt;&gt; eig_vectors
array([[ 1.,  0.],
       [ 0.,  1.]])
</code></pre>
<!-- end verbatim block -->
The eigenvectors are normalized to have unit lengths.

<h2 id="___sec70">Products </h2>

<p>
The <code>np.dot</code> function is used for scalar or dot product as well as
matrix-vector and matrix-matrix products <em>between array objects</em>:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; a = np.array([4, 0])
&gt;&gt;&gt; b = np.array([0, 1])
&gt;&gt;&gt; np.dot(A, a)         # matrix vector product
array([ 8.,  0.])
&gt;&gt;&gt; np.dot(a, b)         # dot product between vectors
0
&gt;&gt;&gt;
&gt;&gt;&gt; B = np.ones((2, 2))  # 2x2 matrix with 1's
&gt;&gt;&gt; np.dot(A, B)         # matrix-matrix product
array([[ 2.,  2.],
       [ 5.,  5.]])
</code></pre>
<!-- end verbatim block -->

<p>
Note that using the <code>matrix</code> class instead of plain arrays
(see the section <a href="#sec:plot:numpy:matrix">Matrix objects</a>)
allows <code>*</code> to be used as operator for matrix-vector and matrix-matrix
products.

<p>
The cross product \( a\times b \),
between vectors \( a \) and \( b \) of length 3, is computed by

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; np.cross([1, 1, 1], [0, 0, 1])
array([ 1, -1,  0])
</code></pre>
<!-- end verbatim block -->
Finding the angle between vectors \( a \) and \( b \),

$$ \theta = \cos^{-1}\left(\frac{a\cdot b}{||a||\,||b||}\right),$$

goes like

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; np.arccos(np.dot(a, b)/(np.linalg.norm(a)*np.linalg.norm(b)))
1.5707963267948966
</code></pre>
<!-- end verbatim block -->

<h2 id="___sec71">Norms </h2>

<p>
Various norms of matrices and vectors are well supported by NumPy.
Some common examples are

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; np.linalg.norm(A)        # Frobenius norm for matrices
5.3851648071345037
&gt;&gt;&gt; np.sqrt(np.sum(A**2))    # Frobenius norm: direct formula
5.3851648071345037
&gt;&gt;&gt; np.linalg.norm(a)        # l2 norm for vectors
4.0
</code></pre>
<!-- end verbatim block -->
See <code>pydoc numpy.linalg.norm</code> for information on other norms.

<h2 id="___sec72">Sum and extreme values </h2>

<p>
The sum of all elements or of the elements in a particular row or column
is computed by <code>np.sum</code>:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; np.sum(B)          # sum of all elements
2.0
&gt;&gt;&gt; B.sum()            # sum of all elements; alternative syntax
2.0
&gt;&gt;&gt; np.sum(B, axis=0)  # sum over index 0 (rows)
array([ 4., -2.])
&gt;&gt;&gt; np.sum(B, axis=1)  # sum over index 1 (columns)
array([ 3., -1.])
</code></pre>
<!-- end verbatim block -->
The maximum or minimum value of an array is also often needed:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; np.max(B)          # max over all elements
3.0
&gt;&gt;&gt; B.max()            # max over all elements, alt. syntax
3.0
&gt;&gt;&gt; np.min(B)          # min over all elements
-4.0
&gt;&gt;&gt; np.abs(B).min()    # min absolute value
1.0
</code></pre>
<!-- end verbatim block -->
A very frequent application of computing the minimum absolute value
occurs in test functions where we want to verify a result, e.g.,
that \( AA^{-1}=I \), where \( I \) is the identity matrix. We then want to
check the smallest absolute value in \( AA^{-1}-I \):

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; I = np.eye(2)   # identity matrix of size 2
&gt;&gt;&gt; I
array([[ 1.,  0.],
       [ 0.,  1.]])
&gt;&gt;&gt; np.abs(np.dot(A, np.linalg.inv(A)) - I).max()
0.0
</code></pre>
<!-- end verbatim block -->

<p>
<div class="alert alert-block alert-warning alert-text-normal">
<b>Never use <code>==</code> when testing real numbers!</b>
<p>
It could be tempting to test \( AA^{-1}=I \) using the syntax

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; np.dot(A, np.linalg.inv(A)) == np.eye(2)
array([[ True,  True],
       [ True,  True]], dtype=bool)
</code></pre>
<!-- end verbatim block -->
but there are two major problems with this test:

<ol>
<li> the result is a boolean matrix, not suitable for an <code>if</code> test</li>
<li> using <code>==</code> for matrices with float elements may fail because of
   rounding errors</li>
</ol>

The second problem must be solved by
computing differences and comparing them against small tolerances, as we
did above.
Here is an example where <code>==</code> fails:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; A = np.array([[4, 0], [0, 49]], dtype=float)
&gt;&gt;&gt; np.dot(A, np.linalg.inv(A)) == np.eye(2)
array([[ True,  True],
       [ True, False]], dtype=bool)
</code></pre>
<!-- end verbatim block -->
(<code>1.0/49*49</code> is not exactly <code>1</code> because of rounding errors.)

<p>
The first problem is solved by using the <code>C.all()</code>, which returns one
boolean variable <code>True</code> if all elements in the boolean array <code>C</code> are <code>True</code>,
otherwise it returns <code>False</code>, as in the case above:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; (np.dot(A, np.linalg.inv(A)) == np.eye(2)).all()
False
</code></pre>
<!-- end verbatim block -->
</div>


<h2 id="___sec73">Indexing </h2>

<p>
Indexing an element is done by <code>A[i,j]</code>. A row or column
is extracted as

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; A[0,:]  # first row
array([ 2.,  0.])
&gt;&gt;&gt; A[:,1]  # second column
array([ 0.,  5.])
</code></pre>
<!-- end verbatim block -->
NumPy also supports
multiple values for the indices via the <code>np.ix_</code>
function. Here is an example where we
grab row 0 and 2, then column 1:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; C = np.array([[1,2,3],[4,5,6],[7,8,9]])
&gt;&gt;&gt; C[np.ix_([0,2], [1])]  # row 0 and 2, then column 1
array([[2],
       [8]])
</code></pre>
<!-- end verbatim block -->

<p>
You can also use the colon notation to pick out other parts of a matrix.
If <code>C</code> is a \( 3\times 5 \)-matrix,

<p>
<!-- begin verbatim block  pycod-->
<pre><code>C[1:3, 0:4]
</code></pre>
<!-- end verbatim block -->
gives a sub-matrix consisting of the two rows of <code>C</code> after the first, and the first four columns of <code>C</code> (recall that the upper limits, here <code>3</code> and <code>4</code>, are
not included).

<p>
Readers familiar with MATLAB should note that the indexing may
be a bit unexpected when referring to parts of a matrix: writing
<code>C[[0, 2], [0, 2]]</code> one would expect entries residing in rows/columns
\( 0 \) and \( 2 \), but that behavior requires in Python the <code>np.ix_</code>
command:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; C = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
&gt;&gt;&gt; C[np.ix_([0, 2], [0, 2])]
[[1 3]
 [7 9]]
&gt;&gt;&gt; # Grab row 0, 2, then column 0 from row 0 and column 2 from row 2
&gt;&gt;&gt; C[[0, 2], [0, 2]]
[1 9]
</code></pre>
<!-- end verbatim block -->

<h2 id="___sec74">Transpose and upper/lower triangular parts </h2>

<p>
The transpose of a matrix <code>B</code> is obtained by <code>B.T</code>:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; B = np.array([[1, 2], [3, -4]], dtype=float)
&gt;&gt;&gt; B.T                # the transpose
array([[ 1.,  3.],
       [ 2., -4.]])
</code></pre>
<!-- end verbatim block -->

<p>
NumPy has rich functionality for doing operations on array objects.
For example, one can strip down a matrix to its upper or lower triangular parts:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; np.triu(B)  # upper triangular part of B
array([[ 1.,  2.],
       [ 0., -4.]])
&gt;&gt;&gt; np.tril(B)  # lower triangular part of B
array([[ 1.,  0.],
       [ 3., -4.]])
</code></pre>
<!-- end verbatim block -->

<h2 id="___sec75">Solving linear systems </h2>

<p>
The perhaps most frequent operation in linear algebra is the solution
of systems of linear algebraic equations: \( Ax=b \), where \( A \) is a coefficient
matrix, \( b \) is a given right-hand side vector, and \( x \) is the solution vector.
The function <code>np.linalg.solve(A, b)</code> does the job:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; A = np.array([[1, 2], [-2, 2.5]])
&gt;&gt;&gt; x = np.array([-1, 1], dtype=float)  # pick a solution
&gt;&gt;&gt; b = np.dot(A, x)                    # find right-hand side

&gt;&gt;&gt; np.linalg.solve(A, b)               # will this compute x?
array([-1.,  1.])
</code></pre>
<!-- end verbatim block -->

<h2 id="___sec76">Matrix row and column operations </h2>

<p>
Implementing Gaussian elimination constitutes a good pedagogical example on
how to perform row and column operations on a matrix. Some
needed functionality is

<p>
<!-- begin verbatim block  pycod-->
<pre><code>A[[i, j]] = A[[j, i]]  # swap rows i and j
A[i] *= k              # multiply row i by a constant k
A[j] += k*A[i]         # add row i, multiplied by k, to row j
</code></pre>
<!-- end verbatim block -->
With these operations, Gaussian elimination is programmed as follows.

<p>
<!-- begin verbatim block  pycod-->
<pre><code>m, n = shape(A)
for j in range(n - 1):
    for i in range(j + 1, m):
        A[i,j:] -= (A[i,j]/A[j,j])*A[j,j:]
</code></pre>
<!-- end verbatim block -->
Note the special syntax <code>j:</code>, which refers to indices from j and up to the end of the array.
More generally, when referring to an array <code>a</code> with length <code>n</code>, the following are equivalent:
<!-- begin verbatim block  pycod-->
<pre><code>a[0:n]
a[:n]
a[0:]
a[:]
</code></pre>
<!-- end verbatim block -->
In the code for Gaussian elimination, we first eliminate the entries below the diagonal in the
first column, by adding a scaled version of the first row to the other
rows. Then the same procedure is applied for the second row, and so
on. The result is an upper triangular matrix. The code can fail if
some of the entries <code>A[j,j]</code> become zero along the way. To avoid
this, we can swap rows when the problem arises.  The following code
implements the idea and will not fail, even if some of the columns are zero.

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def Gaussian_elimination(A):
    rank = 0
    m, n = np.shape(A)
    i = 0
    for j in range(n):
        p = np.argmax(abs(A[i:m,j]))
        if p &gt; 0: # swap rows
            A[[i,p+i]] = A[[p+i, i]]
        if A[i,j] != 0:
            # j is a pivot column
            rank += 1
            for r in range(i+1, m):
                A[r,j:] -= (A[r,j]/A[i,j])*A[i,j:]
            i += 1
        if i &gt; m:
            break
    return A, rank
</code></pre>
<!-- end verbatim block -->
Note that we stick to the habit of returning all results from a function,
here the modified matrix <code>A</code> and its rank.

<h2 id="___sec77">Computing the rank of a matrix </h2>

<p>
The rank of a matrix equals the number of pivot columns after Gaussian
elimination.  The variable <code>rank</code> counts these in the code above.

<p>
Due to rounding errors, the computed rank may be higher than the
actual rank: the rounding errors may imply that <code>A[i,j] != 0</code> is true,
even if Gaussian elimination performed in exact arithmetics gives exactly zero.
Such situations can be avoided by replacing <code>if A[i,j] !=0:</code>
with <code>if abs(A[i,j]) &gt; tol:</code>, where <code>tol</code> is some small
tolerance.

<p>
A more reliable way to compute the rank is to compute the
singular value decomposition of <code>A</code>, and check how many of the
singular values that are larger than a threshold <code>epsilon</code>:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; A = np.array([[1, 2.01], [2.01, 4.0401]])
&gt;&gt;&gt; U, s, V = np.linalg.svd(A) # s are the singular values of A
# abs(s) &gt; tol gives an array with True and False values
# s.nonzero() lists indices k so that s[k] != 0
&gt;&gt;&gt; shape((abs(s) &gt; tol).nonzero())[1]  # rank
1
&gt;&gt;&gt; A, rank = Gaussian_elimination(A)
&gt;&gt;&gt; rank
2
</code></pre>
<!-- end verbatim block -->
If you use a tolerance check on the form <code>if abs(A[i,j]) &gt; 1E-10:</code>
in the function <code>Gaussian_elimination</code>, the code will say that the rank is 1,
which is the correct value also found by using the singular value
decomposition.

<p>
It is known that the determinant is nonzero if and only if the rank equals the number of rows/columns.
For the matrix \( A \) we used above, the determinant should thus be \( 0 \),
but also here roundoff errors come into play:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; A = np.array([[1, 2.01], [2.01, 4.0401]])
&gt;&gt;&gt; A[0, 0]*A[1, 1] - A[0, 1]*A[1, 0]
8.881784197e-16
&gt;&gt;&gt; np.linalg.det(A)
8.92619311799e-16
</code></pre>
<!-- end verbatim block -->

<p>
Using our own Gaussian elimination function for computing the rank is
less efficient than calling NumPy's singular value decomposition.
Here are timings for a random \( 100\times 100 \)-matrix:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>&gt;&gt;&gt; A = np.random.uniform(0, 1, (100, 100))
&gt;&gt;&gt; %timeit U, s, V = np.linalg.svd(A)
100 loops, best of 3: 3.7 ms per loop
&gt;&gt;&gt; %timeit A, rank = Gaussian_elimination(A)
100 loops, best of 3: 22.3 ms per loop
</code></pre>
<!-- end verbatim block -->

<h2 id="___sec78">Symbolic linear algebra </h2>

<p>
SymPy supports symbolic computations also for linear algebra operations.
We may create a matrix and find its inverse and determinant:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; import sympy as sym
&gt;&gt;&gt; A = sym.Matrix([[2, 0], [0, 5]])

&gt;&gt;&gt; A**-1    # the inverse
Matrix([
[1/2,   0],
[  0, 1/5]])

&gt;&gt;&gt; A.inv()  # the inverse
Matrix([
[1/2,   0],
[  0, 1/5]])

&gt;&gt;&gt; A.det()  # the determinant
10
</code></pre>
<!-- end verbatim block -->
Note that the entries in the inverse matrix are rational numbers
(<code>sym.Rational</code> objects to be precise).

<p>
Eigenvalues can also be computed exactly:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; A.eigenvals()
{2: 1, 5: 1}
</code></pre>
<!-- end verbatim block -->
The output is a dictionary
meaning here that 2 is an eigenvalue with multiplicity 1 and 5 is an
eigenvalue with multiplicity 1. It is more convenient to have the eigenvalues
in a list:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; e = list(A.eigenvals().keys())
&gt;&gt;&gt; e
[2, 5]
</code></pre>
<!-- end verbatim block -->
Eigenvector computations have a somewhat complicated output:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; A.eigenvects()
[(2, 1, [Matrix([
[1],
[0]])]), (5, 1, [Matrix([
[0],
[1]])])]
</code></pre>
<!-- end verbatim block -->
The output is a list of three-tuples, one for each eigenvalue and eigenvector.
The three-tuple contains the eigenvalue, its multiplicity, and the eigenvector
as a <code>sym.Matrix</code> object.
To isolate the first eigenvector, we can index the list and tuple:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; v1 = A.eigenvects()[0][2]
&gt;&gt;&gt; v1
Matrix([
[1],
[0]])
</code></pre>
<!-- end verbatim block -->
The vector is a <code>sym.Matrix</code> object with two indices. To extract the
vector elements in a plain list, we can do this:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; v1 = [v1[i,0] for i in range(v1.shape[0])]
&gt;&gt;&gt; v1
[1, 0]
</code></pre>
<!-- end verbatim block -->
The following code extracts all eigenvectors as a list of 2-lists, which may
be a convenient data structure for the eigenvectors:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; v = [[t[2][0][i,0] for i in range(t[2][0].shape[0])]
         for t in A.eigenvects()]
&gt;&gt;&gt; v
[[1, 0], [0, 1]]
</code></pre>
<!-- end verbatim block -->

<p>
The norm of a matrix or vector is an exact expression:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; A.norm()
sqrt(29)
&gt;&gt;&gt; a = sym.Matrix([1, 2])   # vector [1, 2]
&gt;&gt;&gt; a
Matrix([
[1],
[2]])
&gt;&gt;&gt; a.norm()
sqrt(5)
</code></pre>
<!-- end verbatim block -->

<p>
The matrix-vector product and the dot product between vectors are
done like this:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; A*a                      # matrix*vector
Matrix([
[ 2],
[10]])
&gt;&gt;&gt; b = sym.Matrix([2, -1])  # vector [2, -1]
&gt;&gt;&gt; a.dot(b)
0
</code></pre>
<!-- end verbatim block -->

<p>
Solving linear systems exactly is also possible:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; x = sym.Matrix([-1, 1])/2
&gt;&gt;&gt; x
Matrix([
[-1/2],
[ 1/2]])
&gt;&gt;&gt; b = A*x
&gt;&gt;&gt; x = A.LUsolve(b)  # does it compute x?
&gt;&gt;&gt; x                 # x is a matrix object
Matrix([
[-1/2],
[ 1/2]])
</code></pre>
<!-- end verbatim block -->
Sometimes one wants to convert <code>x</code> to a plain <code>numpy</code> array with
<code>float</code> values:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; x = np.array([float(x[i,0].evalf())
                  for i in range(x.shape[0])])
&gt;&gt;&gt; x
array([-0.5,  0.5])
</code></pre>
<!-- end verbatim block -->

<p>
Exact row operations can be done as exemplified here:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; A[1,:] + 2*A[0,:]  # [0,5] + 2*[2,0]
Matrix([[4, 5]])
</code></pre>
<!-- end verbatim block -->
We refer to the online <a href="http://docs.sympy.org/dev/tutorial/matrices.html" target="_self">SymPy linear algebra tutorial</a> for more information.

<h1 id="plot:surf">Plotting of scalar and vector fields</h1>

<p>
Visualization of scalar and vector fields in Python is commonly done
using Matplotlib or Mayavi. Both packages support basic visualization of
2D scalar and vector fields, but Mayavi offers more advanced
three-dimensional visualization techniques,
especially for 3D scalar and vector fields.

<p>
One can also use SciTools for visualizing 2D scalar and vector
fields, using either Matplotlib, Gnuplot, or VTK as plotting engines, but
this topic is omitted from the present book.
However, for fast visualization of large 2D
scalar fields, Gnuplot is a viable tool, and the SciTools interface
offers a convenient MATLAB-style set of commands to operate Gnuplot.

<p>
To exemplify visualization of scalar and vector fields with
Matplotlib and Mayavi,
we use a common set of examples. A scalar function of \( x \)
and \( y \) is visualized either as a flat two-dimensional plot with
contour lines of the field, or as a three-dimensional surface where
the height of the surface corresponds to the function value of the
field. In the latter case we also add a three-dimensional
parameterized curve to the plot.

<p>
To illustrate plotting of vector fields, we simply plot the gradient of the scalar field, together with the scalar field.
Our convention for variable names goes as follows:

<ul>
<li> <code>x</code>, <code>y</code> for one-dimensional coordinates along each axis direction.</li>
<li> <code>xv</code>, <code>yv</code> for the corresponding
  vectorized coordinates in a 2D.</li>
<li> <code>u</code>, <code>v</code> for the components of a vector field
  at points corresponding to <code>xv</code>, <code>yv</code>.</li>
</ul>

The following sections contain more mathematical details on the various
scalar and vector fields we aim to plot.
<!-- Most figures in this context -->
<!-- we generated by Matplotlib.  Succeeding sections explain the -->
<!-- corresponding code and how the same plots can be made with Mayavi. -->

<h2 id="plot:surf:install">Installation</h2>

<p>
Previously in the book we have explained how to obtain Matplotlib for various platforms.
To obtain Mayavi on Ubuntu platforms you can write

<p>
<!-- begin verbatim block  sys-->
<pre><code>pip install mayavi --upgrade
</code></pre>
<!-- end verbatim block -->
For Mac OS X and Windows, we recommend using Anaconda.
To obtain Mayavi for Anaconda you can write

<p>
<!-- begin verbatim block  sys-->
<pre><code>conda install mayavi
</code></pre>
<!-- end verbatim block -->

<h2 id="plot:surf:mesh_surf">Surface plots</h2>

<p>
We consider the 2D scalar field defined by

$$
\begin{equation}
h(x,y) = \frac{h_0}{1+ \frac{x^2+y^2}{R^2}}.
\tag{13}
\end{equation}
$$

\( h(x,y) \) may model the height of an isolated circular mountain,
\( h \) being the height above sea level,
while \( x \) and \( y \) are Cartesian coordinates on the earth's surface,
\( h_0 \) the height of the mountain, and \( R \) the radius of the mountain.
Since mountains are actually quite flat (or more precisely,
their heights are small compared to the horizontal extent), we use
meter as length unit for vertical distances (\( z \) direction) and km as length
unit for horizontal distances (\( x \) and \( y \) coordinates).
Prior to all code below we have initialized \( h_0 \) and \( R \) with
the following values: \( h_0=2277 \) m and \( R=4 \) km.

<h3 id="___sec82">Grid for 2D scalar fields </h3>

<p>
Before we can plot \( h(x,y) \), we need to create a rectangular grid in the \( xy \) plane with all the points used for plotting.
Regardless of which plotting package we will use later on, the grid can be made as follows:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>x = y = np.linspace(-10., 10., 41)
xv, yv = np.meshgrid(x, y, indexing='ij', sparse=False)

hv = h0/(1 + (xv**2+yv**2)/(R**2))
</code></pre>
<!-- end verbatim block -->
The grid is based on equally spaced coordinates <code>x</code> and <code>y</code> in the
interval \( [-10,10] \) km.
Note the mysterious extra parameters to <code>meshgrid</code> here, which are needed in order for the coordinates to have the right order such that the arithmetics
in the expression for <code>hv</code> becomes correct.
The expression computes the
surface value at the \( 41\times 41 \) grid points in one vectorized operation.

<p>
A surface plot of a 2D scalar field \( h(x,y) \) is a visualization of the surface \( z=h(x,y) \) in three-dimensional space.
Most plotting packages have functions which can be used to create surface plots of 2D scalar fields.
These can be either <em>wireframe plots</em>, where only lines connecting the grid points are drawn,
or plots where the faces of the surface are colored.
In Figure <a href="#plotmatplotlib">12</a> we have shown two such plots of the surface \( h(x,y) \). The section <a href="#matplotlibsurfaceplots">Surface plots</a> presents the code which generates these plots.

<p>
<center> <!-- figure label: --> <div id="plotmatplotlib"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 12:  Two different plots of a mountain. The right plot also shows a trajectory to the top of the mountain.  <!-- caption label: plotmatplotlib --> </p></center>
<p><img src="fig-plot/plot_matplotlib.png" align="bottom" ></p>
</center>

<h2 id="plot:surf:3Dcurve">Parameterized curve</h2>

<p>
To illustrate the plotting of three-dimensional parameterized curves,
we consider a trajectory that represents a circular climb to the top
of the mountain:

$$
\begin{align}
\boldsymbol{r}(t) = & \left( 10\left(1 - \frac{t}{2\pi}\right)\cos(t) \right) \boldsymbol{i} + \left( 10\left(1 - \frac{t}{2\pi}\right)\sin(t) \right) \boldsymbol{j} \nonumber\\ 
 & + \frac{h_0}{1 + \frac{100(1 - t/(2\pi))^2}{R^2}} \boldsymbol{k}.
\tag{14}
\end{align}
$$

Here \( \boldsymbol{i} \), \( \boldsymbol{j} \), and \( \boldsymbol{k} \) denote the unit vectors in the \( x \)-, \( y \)-, and \( z \)-directions, respectively.
The coordinates of \( \boldsymbol{r}(t) \) can be produced by

<p>
<!-- begin verbatim block  pycod-->
<pre><code>s = np.linspace(0, 2*np.pi, 100)
curve_x = 10*(1 - s/(2*np.pi))*np.cos(s)
curve_y = 10*(1 - s/(2*np.pi))*np.sin(s)
curve_z = h0/(1 + 100*(1 - s/(2*np.pi))**2/(R**2))
</code></pre>
<!-- end verbatim block -->
The parameterized curve is shown together with the surface \( h(x,y) \) in the right plot in Figure <a href="#plotmatplotlib">12</a>.

<h2 id="plot:surf:contours">Contour lines</h2>

<p>
Contour lines are lines defined by the implicit equation \( h(x,y)=C \), where
\( C \) is some constant representing the contour level.
Normally, we let \( C \) run over some equally spaced values, and very often, the
plotting program computes the \( C \) values.
To distinguish contours, one often associates each contour level \( C \) with its own color.

<p>
Figure <a href="#simplecontourmatplotlib">13</a> shows different ways contour lines
can be used to visualize the surface \( h(x,y) \).  The first and
last plot are visualizations utilizing two spatial dimensions.  The
first draws a small set of contour lines only, while the last one
displays the surface as an image, whose colors reflect the values of
the field, or equivalently, the height of the surface.  The third plot
actually combines three different types of contours, each type
corresponding to keeping a coordinate constant and projecting the
contours on a &quot;wall&quot;.  The code used to generate these plots is
presented in the section <a href="#matplotlibcontourplots">Contour plots</a>.

<p>
<center> <!-- figure label: --> <div id="simplecontourmatplotlib"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 13:  Different types of contour plots of a 2D scalar field in two and three dimensions.  <!-- caption label: simplecontourmatplotlib --> </p></center>
<p><img src="fig-plot/simple_contour_matplotlib.png" align="bottom" ></p>
</center>

<h2 id="plot:surf:gradient">The gradient vector field</h2>

<p>
The <em>gradient vector field</em> \( \nabla h \) of a 2D scalar field \( h(x,y) \) is defined by

$$
\begin{equation}
\nabla h = \frac{\partial h}{\partial x}\boldsymbol{i} +  \frac{\partial h}{\partial y}\boldsymbol{j}.
\tag{15}
\end{equation}
$$

One learns in vector calculus that the gradient points in the direction where \( h \) increases most, and
that the gradients are orthogonal to the contour lines.
This is something we can easily illustrate by creating 2D plots of the contours and the gradient field.
A challenge in making such plots is to get the right arrow lengths so
that the arrows are well visible, but they do not collide and make a
cluttered visual impression. Since the arrows are drawn at each point in
a 2D grid, one way of controlling the number of arrows is to control
the resolution of the grid.

<p>
So, let us create a grid with 20 instead of 40 intervals in the horizontal
directions:
<!-- begin verbatim block  pycod-->
<pre><code>x2 = y2 = np.linspace(-10.,10.,11)
x2v, y2v = np.meshgrid(x2, y2, indexing='ij', sparse=False)
h2v = h0/(1 + (x2v**2 + y2v**2)/(R**2)) # h on coarse grid
</code></pre>
<!-- end verbatim block -->
The gradient vector field of \( h(x,y) \) can now be computed using the function <code>np.gradient</code>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>dhdx, dhdy = np.gradient(h2v) # dh/dx, dh/dy
</code></pre>
<!-- end verbatim block -->
The gradient field <a href="#mjx-eqn-15">(15)</a> together with the contours appear in Figure <a href="#plot:surf:mpl:quiver:fig">14</a>,
from which the orthogonality can be easily seen.
The section <a href="#plot:surf:mpl:quiver">Vector field plots</a> explains the code needed to make this plot.

<p>
<center> <!-- figure label: --> <div id="plot:surf:mpl:quiver:fig"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 14:  Gradient field with contour plot.  <!-- caption label: plot:surf:mpl:quiver:fig --> </p></center>
<p><img src="fig-plot/quiver_matplotlib_advanced.png" align="bottom" ></p>
</center>

<h1 id="___sec86">Matplotlib </h1>

<p>
We import any visualization package under the name <code>plt</code>, so
for Matplotlib the import is done by

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import matplotlib.pyplot as plt
</code></pre>
<!-- end verbatim block -->
When creating two-dimensional plots of
scalar and vector fields, we shall make use
of a Matplotlib <code>Axes</code> object, named <code>ax</code> and made by

<p>
<!-- begin verbatim block  pycod-->
<pre><code>fig = plt.figure(1)   # Get current figure
ax = fig.gca()        # Get current axes
</code></pre>
<!-- end verbatim block -->
For three-dimensional visualization, we need the following alternative
lines:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>from mpl_toolkits.mplot3d import Axes3D

fig = plt.figure(1)
ax = fig.gca(projection='3d')
</code></pre>
<!-- end verbatim block -->

<h2 id="matplotlibsurfaceplots">Surface plots</h2>

<p>
The Matplotlib functions for producing surface plots of 2D scalar fields  are
<code>ax.plot_wireframe</code> and <code>ax.plot_surface</code>.
The first one produces a wireframe plot, and the second one colors the surface.
The following code uses the functions to produce the plots shown in Figure
<a href="#plotmatplotlib">12</a>, once the grid has been defined as in the section <a href="#plot:surf:mesh_surf">Surface plots</a>,
and the coordinates of the parameterized curve have been computed as in the section <a href="#plot:surf:3Dcurve">Parameterized curve</a>.

<p>
<!-- begin verbatim block  pycod-->
<pre><code>fig = plt.figure(1)
ax = fig.gca(projection='3d')
ax.plot_wireframe(xv, yv, hv, rstride=2, cstride=2)

# Simple plot of mountain and parametric curve
fig = plt.figure(2)
ax = fig.gca(projection='3d')
from matplotlib import cm
ax.plot_surface(xv, yv, hv, cmap=cm.coolwarm,
                rstride=1, cstride=1)

# add the parametric curve. linewidth controls the width of the curve
ax.plot(curve_x, curve_y, curve_z, linewidth=5)
</code></pre>
<!-- end verbatim block -->
Recall that a final
<code>plt.show()</code> command is necessary to force Matplotlib to show a plot on the screen.

<p>
Note that the second plot in this figure is drawn using a finer grid.
This is controlled with the <code>rstride</code> and <code>cstride</code> parameters, which
sets the number of grid lines in each direction.  Setting one of these
to 1 means that a grid line is drawn for every value in the grid in
the corresponding direction, and setting to 2 means that a grid line
will be drawn for every two values in the grid. You will normally need
to experiment with such parameters to get a visually attractive plot.

<p>
A surface with colors reflecting the height of the surface
needs specification of a <em>color map</em>, which is
a mapping between function values and colors.
Above we applied the common <code>coolwarm</code>
scheme which goes from blue (&quot;cool&quot; color for minimum values) to red
(&quot;warm&quot; color for maximum values).
There are lots of colormaps to choose from, and you have
to experiment to find appropriate choices according to your taste and
to the problem at hand.

<p>
To the latter plot we also added the parameterized curve \( \boldsymbol{r}(t) \),
defined by <a href="#mjx-eqn-14">(14)</a>, using the command <code>plot</code>.  The
attribute <code>linewidth</code> is increased here in order to make the curve thicker and
more visible.  By default, Matplotlib adds plots to each other without
any need for <code>plt.hold('on')</code>, although such a command can indeed be
used.

<h2 id="matplotlibcontourplots">Contour plots</h2>

<p>
The following code exemplifies different types of contour plots.  The
first two plots (default two-dimensional and three-dimensional contour
plots) are shown in Figure <a href="#simplecontourmatplotlib">13</a>. The next four
plots appear in Figure <a href="#advancedcontourmatplotlib">15</a>. Note that, when
we asked Matplotlib to plot 10 contours, the response was,
surprisingly, 9 contour lines, where one of the contours was
incomplete.  This kind of behavior may also be found in other plotting
packages (such as MATLAB): the package will do its best to plot the
requested number of complete contour lines, but there is no guarantee
that this number is achieved exactly.

<p>
<!-- begin verbatim block  pycod-->
<pre><code># Default two-dimensional contour plot with 7 colored lines
fig = plt.figure(3)
ax = fig.gca()
ax.contour(xv, yv, hv)
plt.axis('equal')

# Default three-dimensional contour plot
fig = plt.figure(4)
ax = fig.gca(projection='3d')
ax.contour(xv, yv, hv)

# Plot of mountain and contour lines projected on the
# coordinate planes
fig = plt.figure(5)
ax = fig.gca(projection='3d')
ax.plot_surface(xv, yv, hv, cmap=cm.coolwarm,
                rstride=1, cstride=1)
# zdir is the projection axis
# offset is the offset of the projection plane
ax.contour(xv, yv, hv, zdir='z', offset=-1000, cmap=cm.coolwarm)
ax.contour(xv, yv, hv, zdir='x', offset=-10,   cmap=cm.coolwarm)
ax.contour(xv, yv, hv, zdir='y', offset=10,    cmap=cm.coolwarm)

# View the contours by displaying as an image
fig = plt.figure(6)
ax = fig.gca()
ax.imshow(hv)

# 10 contour lines (equally spaced contour levels)
fig = plt.figure(7)
ax = fig.gca()
ax.contour(xv, yv, hv, 10)
plt.axis('equal')

# 10 black ('k') contour lines
fig = plt.figure(8)
ax = fig.gca()
ax.contour(xv, yv, hv, 10, colors='k')
plt.axis('equal')

# Specify the contour levels explicitly as a list
fig = plt.figure(9)
ax = fig.gca()
levels = [500., 1000., 1500., 2000.]
ax.contour(xv, yv, hv, levels=levels)
plt.axis('equal')

# Add labels with the contour level for each contour line
fig = plt.figure(10)
ax = fig.gca()
cs = ax.contour(xv, yv, hv)
plt.clabel(cs)
plt.axis('equal')
</code></pre>
<!-- end verbatim block -->

<p>
<center> <!-- figure label: --> <div id="advancedcontourmatplotlib"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 15:  Some other contour plots with Matplotlib: 10 contour lines (upper left), 10 black contour lines (upper right), specified contour levels (lower left), and labeled levels (lower right).  <!-- caption label: advancedcontourmatplotlib --> </p></center>
<p><img src="fig-plot/advanced_contour_matplotlib.png" align="bottom" height=400 width=600></p>
</center>

<h2 id="plot:surf:mpl:quiver">Vector field plots</h2>

<p>
The code for plotting the gradient field <a href="#mjx-eqn-15">(15)</a> together
with contours goes as explained below, once the grid has been defined as in
the section <a href="#plot:surf:gradient">The gradient vector field</a>.
The corresponding plot is shown in Figure <a href="#plot:surf:mpl:quiver:fig">14</a>.

<p>
<!-- begin verbatim block  pycod-->
<pre><code>fig = plt.figure(11)
ax = fig.gca()
ax.quiver(x2v, y2v, dhdx, dhdy, color='r',
          angles='xy', scale_units='xy')
ax.contour(xv, yv, hv)
plt.axis('equal')
</code></pre>
<!-- end verbatim block -->

<h1 id="___sec90">Mayavi </h1>

<p>
Mayavi is an advanced, free, easy to use, scientific data visualizer,
with an emphasis on three-dimensional visualization techniques.  The
package is written in Python, and uses the Visualization Toolkit (VTK)
in C++ for rendering graphics. Since VTK can be configured with
different backends, so can Mayavi.  Mayavi is cross platform and runs
on most platforms, including Mac OS X, Windows, and Linux.

<p>
The web page <a href="http://docs.enthought.com/mayavi/mayavi/" target="_self"><tt>http://docs.enthought.com/mayavi/mayavi/</tt></a> collects
pointers to all relevant documentation of Mayavi.  We shall primarily
deal with the <code>mayavi.mlab</code> module, which provides a simple interface
to plotting of 2D scalar and vector fields with commands that mimic
those of MATLAB.  Let us import this module under our usual name <code>plt</code>
for a plotting package:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import mayavi.mlab as plt
</code></pre>
<!-- end verbatim block -->

<p>
The official documentation of the <code>mlab</code> module is provided in two
places, one for the <a href="http://docs.enthought.com/mayavi/mayavi/auto/mlab_helper_functions.html" target="_self">basic functionality</a>
and one for <a href="http://docs.enthought.com/mayavi/mayavi/auto/mlab_other_functions.html" target="_self">further functionality</a>.
Basic <a href="http://docs.enthought.com/mayavi/mayavi/auto/mlab_figure.html" target="_self">figure
handling</a>
is very similar to the one we know from Matplotlib.  Just as for
Matplotlib, all plotting commands you do in <code>mlab</code> will go into the
same figure, until you manually change to a new figure.

<h2 id="___sec91">Surface plots </h2>

<p>
Mayavi has the functions <code>mesh</code> and <code>surf</code> for producing surface plots.
These are similar, but <code>surf</code> assumes an orthogonal grid, and uses this assumption to make efficient data structures, while
<code>mesh</code> makes no such assumptions on the grid.
Here we only use orthogonal grids and hence apply <code>surf</code>.
The following code plots the surface \( h(x,y) \) in <a href="#mjx-eqn-13">(13)</a>, as
well as the parameterized curve \( \boldsymbol{r}(t) \) in <a href="#mjx-eqn-14">(14)</a>.
The resulting graphics appears in Figure <a href="#plotmayavi">16</a>.

<p>
<!-- begin verbatim block  pycod-->
<pre><code>
# Create a figure with white background and black foreground
plt.figure(1, fgcolor=(.0, .0, .0), bgcolor=(1.0, 1.0, 1.0))
# 'representation' sets type of plot, here a wireframe plot
plt.surf(xv, yv, hv, extent=(0,1,0,1,0,1),
         representation='wireframe')
# Decorate axes (nb_labels is the number of labels used
# in each direction)
plt.axes(xlabel='x', ylabel='y', zlabel='z', nb_labels=5,
         color=(0., 0., 0.))
# Decorate the plot with a title
plt.title('h(x,y)', size=0.4)

# Simple plot of mountain and parametric curve.
plt.figure(2, fgcolor=(.0, .0, .0), bgcolor=(1.0, 1.0, 1.0))
# Here, representation has default: colored surface elements
plt.surf(xv, yv, hv, extent=(0,1,0,1,0,1))
# Add the parametric curve. tube_radius is the width of the
# curve (use 'extent' for auto-scaling)
plt.plot3d(curve_x, curve_y, curve_z, tube_radius=0.2,
           extent=(0,1,0,1,0,1))

plt.figure(3, fgcolor=(.0, .0, .0), bgcolor=(1.0, 1.0, 1.0))
# Use 'warp_scale' for vertical scaling
plt.surf(xv, yv, hv, warp_scale=0.01, color=(.5, .5, .5))
plt.plot3d(curve_x, curve_y, 0.01*curve_z, tube_radius=0.2)
</code></pre>
<!-- end verbatim block -->
<code>surf</code> can produce wireframe plots,
as well as plots where the faces of the surface are colored.
The parameter <code>representation</code> controls this,
as exemplified in the first two plots.
The first plot was also decorated with axes and a title.

<p>
<center> <!-- figure label: --> <div id="plotmayavi"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 16:  Surface plots produced with the <code>surf</code> function of Mayavi: The curve \( \boldsymbol{r}(t) \) is also shown in the two last plots.  <!-- caption label: plotmayavi --> </p></center>
<p><img src="fig-plot/plot_mayavi.png" align="bottom" ></p>
</center>

<p>
The calls to <code>plt.figure()</code> take three parameters: First the usual index for the plot, then two tuples of numbers ,
representing the RGB-values to be used for the foreground (<code>fgcolor</code>) and the background (<code>bgcolor</code>).
White and black are  (1,1,1) and (0,0,0), respectively. The foreground color is used for text and labels included in the plot.
The <code>color</code> attribute in <code>plt.surf</code> adjusts the surface so that it is colored with small variations from the provided base color, here <code>(.5, .5, .5)</code>.

<p>
The command <code>plot3d</code> is used to plot the curve \( \boldsymbol{r}(t) \).  We have here increased the
attribute <code>tube_radius</code> to make the curve thicker and more visible.

<p>
Mayavi does no auto-scaling of the axes by default (contrary to Matplotlib),
so if the magnitudes in the vertical and horizontal directions are very different, as they are for \( h(x,y) \),
the plots may be very concentrated in one direction.
We therefore need to apply some auto-scaling procedure.
In Figure <a href="#plotmayavi">16</a> two such procedures are exemplified.
In the first two plots the parameter <code>extent</code> is used.
It tells Mayavi to auto-scale the surface and curve to fit the contents described
by the six listed values (we will return to what these values mean when we have a more illustrating example).
Since the curve and the surface span different areas in space, we see that they are auto-scaled differently in the second plot,
with the undesired effect that \( \boldsymbol{r}(t) \) is not drawn on the surface.
The last plot has avoided this problem by using the <code>warp_scale</code> parameter for scaling the vertical direction.
Not all Mayavi functions accept this parameter. A remedy for this is to scale the \( z \)-coordinates manually,
as here exemplified in the last <code>plot3d</code>-call. As is seen, the curve is drawn correctly with respect to the surface in the last plot.
In the following we will use the <code>warp_scale</code> parameter to avoid such auto-scaling problems.

<h3 id="___sec92">Subplots </h3>

<p>
The two plots in Figure <a href="#plotmayavi">16</a> were created as separate figures. One can also create them as subplots within one figure:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>plt.figure(4, fgcolor=(.0, .0, .0), bgcolor=(1.0, 1.0, 1.0))
plt.mesh(xv, yv, hv, extent=(0, 0.25, 0, 0.25, 0, 0.25),
         colormap='cool')
plt.outline(plt.mesh(
    xv, yv, hv,
    extent=(0.375, 0.625, 0, 0.25, 0, 0.25),
    colormap='Accent'))
plt.outline(plt.mesh(
    xv, yv, hv, extent=(0.75, 1, 0, 0.25, 0, 0.25),
    colormap='prism'), color=(.5, .5, .5))
</code></pre>
<!-- end verbatim block -->
The result is shown in Figure <a href="#subplot">17</a>.
Three separate <code>mesh</code> commands are run, each producing a new plot in the current figure.
The commands use different values for the <code>colormap</code> attribute to color the surface in different ways.
When this attribute is not provided, as in the code producing the two first plots in Figure <a href="#plotmayavi">16</a>, a default colormap is used.

<p>
The <code>plt.outline</code> command is used to create a frame around the
subplots, and as seen, we exemplify this possibility for the last two
subplots, but not the first one.  We see that one of the two frames
has a different color, obtained by setting the <code>color</code> attribute of
the <code>plt.outline</code> command.

<p>
From the computer code it is hopefully clear that the six values listed in <code>extent</code> represent fractions of the cube <code>(0,1,0,1,0,1)</code>, where the corresponding plots are placed.
The extents for the three plots are here defined such that they do not overlap.

<p>
<center> <!-- figure label: --> <div id="subplot"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 17:  A plot with three subplots created with Mayavi.  <!-- caption label: subplot --> </p></center>
<p><img src="fig-plot/subplot.png" align="bottom" ></p>
</center>

<h2 id="___sec93">Contour plots </h2>

<p>
The following code exemplifies how one can produce contour plots with
Mayavi.  The code is very similar to that of Matplotlib, but one
difference is that the attribute <code>contours</code> now can represent the
number of levels, as well as the levels themselves.
The plots are shown in Figure <a href="#advancedcontourmayavi">18</a>.

<p>
<!-- begin verbatim block  pycod-->
<pre><code># Default contour plot plotted together with surf.
plt.figure(5, fgcolor=(.0, .0, .0), bgcolor=(1.0, 1.0, 1.0))
plt.surf(xv, yv, hv, warp_scale=0.01)
plt.contour_surf(xv, yv, hv, warp_scale=0.01)

# 10 contour lines (equally spaced contour levels).
plt.figure(6, fgcolor=(.0, .0, .0), bgcolor=(1.0, 1.0, 1.0))
plt.contour_surf(xv, yv, hv, contours=10, warp_scale=0.01)

# 10 contour lines (equally spaced contour levels) together
# with surf. Black color for contour lines.
plt.figure(7, fgcolor=(.0, .0, .0), bgcolor=(1.0, 1.0, 1.0))
plt.surf(xv, yv, hv, warp_scale=0.01)
plt.contour_surf(xv, yv, hv, contours=10, color=(0., 0., 0.),
                 warp_scale=0.01)

# Specify the contour levels explicitly as a list.
plt.figure(8, fgcolor=(.0, .0, .0), bgcolor=(1.0, 1.0, 1.0))
levels = [500., 1000., 1500., 2000.]
plt.contour_surf(xv, yv, hv, contours=levels, warp_scale=0.01)

# View the contours by displaying as an image.
plt.figure(9, fgcolor=(.0, .0, .0), bgcolor=(1.0, 1.0, 1.0))
plt.imshow(hv)
</code></pre>
<!-- end verbatim block -->
Note that there is no function in Mayavi which labels the contours.

<p>
Contour plots in Mayavi are shown in three-dimensional space, but you
can rotate and look at them from above if you want a two-dimensional
plot.  Their visual appearance may be enhanced by also including the
surface plot itself. We have done this for the top and middle left plots
in Figure <a href="#advancedcontourmayavi">18</a>.
There is a clear difference in visual impression between these
two plots: in the first one, default surface- and contour coloring is used,
resulting in less visible contours, but in the middle left plot (<code>plt.figure</code> 6), we set black contours to make them better stand out.

<p>
<center> <!-- figure label: --> <div id="advancedcontourmayavi"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 18:  Some contour plots with Mayavi.  <!-- caption label: advancedcontourmayavi --> </p></center>
<p><img src="fig-plot/advanced_contour_mayavi.png" align="bottom" height=400 width=600></p>
</center>

<h2 id="plot:surf:mayavi:quiver">Vector field plots</h2>

<p>
Mayavi supports only vector fields in three-dimensional space.
We will therefore visualize the two-dimensional gradient field <a href="#mjx-eqn-15">(15)</a> by adding a third component of zero.
The following code plots this gradient field  together with the contours of \( h \).

<p>
<!-- begin verbatim block  pycod-->
<pre><code>plt.figure(11, fgcolor=(.0, .0, .0), bgcolor=(1.0, 1.0, 1.0))
plt.contour_surf(xv, yv, hv, contours=20, warp_scale=0.01)

# mode controls the style how vectors are drawn
# color controls the colors of the vectors
# scale_mode='none' ensures that vectors are drawn with the same length
plt.quiver3d(x2v, y2v, 0.01*h2v, dhdx, dhdy, np.zeros_like(dhdx),
             mode='arrow', color=(1,0,0), scale_mode='none')
</code></pre>
<!-- end verbatim block -->
This will produce a 3D view, which we again can rotate to obtain a 2D view.
The result is shown in Figure <a href="#plot:surf:may:quiver:fig">19</a>, which is similar to Figure <a href="#plot:surf:mpl:quiver:fig">14</a>.

<p>
<center> <!-- figure label: --> <div id="plot:surf:may:quiver:fig"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 19:  Gradient field with contour plot.  <!-- caption label: plot:surf:may:quiver:fig --> </p></center>
<p><img src="fig-plot/quiver_mayavi_advanced.png" align="bottom" ></p>
</center>

<h2 id="___sec95">A 3D scalar field and its gradient field </h2>

<p>
Mayavi has functionality for drawing contour surfaces of 3D scalar fields.
Let us consider the 3D scalar field

$$
\begin{equation} \tag{16}
g(x,y,z) = z-h(x,y).
\end{equation}
$$

A three-dimensional grid for \( g \) can be computed as follows.

<p>
<!-- begin verbatim block  pycod-->
<pre><code>x = y = np.linspace(-10.,10.,41)
z = np.linspace(0, 50, 41)
xv, yv, zv = np.meshgrid(x, y, z,
                         sparse=False, indexing='ij')
hv = 0.01*h0/(1 + (xv**2+yv**2)/(R**2))
gv = zv - hv
</code></pre>
<!-- end verbatim block -->
The contours are now surfaces defined by the implicit equation \( g(x,y,z)=C \),
corresponding to vertical shifts of the surface \( h(x,y) \).

<p>
A corresponding vector field can be calculated:

$$
\begin{equation}
\nabla g = \frac{\partial g}{\partial x}\boldsymbol{i} +  \frac{\partial g}{\partial y}\boldsymbol{j} +  \frac{\partial g}{\partial z}\boldsymbol{k}.
\tag{17}
\end{equation}
$$

<code>numpy</code>'s gradient function can be used to compute a gradient vector field in
3D as well, but you
need a three-dimensional grid for the field as input.
For the field <a href="#mjx-eqn-16">(16)</a>, the gradient field is computed as follows.

<p>
<!-- begin verbatim block  pycod-->
<pre><code>x2 = y2 = np.linspace(-10.,10.,5)
z2 = np.linspace(0, 50, 5)
x2v, y2v, z2v = np.meshgrid(x2, y2, z2,
                            indexing='ij', sparse=False)
h2v = 0.01*h0/(1 + (x2v**2 + y2v**2)/(R**2))
g2v = z2v - h2v
dhdx, dhdy, dhdz = np.gradient(g2v)
</code></pre>
<!-- end verbatim block -->
Again we have used a coarser grid for the vector field.

<p>
To visualize the field <a href="#mjx-eqn-16">(16)</a> and its gradient field together,
we draw enough contours, as we did in the 2D case in Figure <a href="#plot:surf:mpl:quiver:fig">14</a>.
The following code can be used.

<p>
<!-- begin verbatim block  pycod-->
<pre><code>plt.figure(12, fgcolor=(.0, .0, .0), bgcolor=(1.0, 1.0, 1.0))
# opacity controls how contours are visible through each other
plt.contour3d(xv, yv, zv, gv, contours=7, opacity=0.5)
# scale_mode='none': vectors should not be scaled
plt.quiver3d(x2v, y2v, z2v, dhdx, dhdy, dhdz, mode='arrow',
             scale_mode='none', opacity=0.5)
</code></pre>
<!-- end verbatim block -->
The result is shown in Figure <a href="#fig:quiver:mayavi">20</a>.

<p>
<center> <!-- figure label: --> <div id="fig:quiver:mayavi"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 20:  The 3D scalar field <a href="#mjx-eqn-16">(16)</a> and its gradient field.  <!-- caption label: fig:quiver:mayavi --> </p></center>
<p><img src="fig-plot/quiver_mayavi.png" align="bottom" ></p>
</center>

<p>
This example demonstrates some of the challenges in plotting
three-dimensional vector fields.  The vectors must not be too dense,
and not too long.  It is inevitable that contours shadow one
another. Fortunately, Mayavi supports an opacity setting, which
controls how contours are visible through each other.  Visualizing a
3D scalar field is clearly challenging, and we have only touched the
subject.

<h2 id="___sec96">Animations </h2>

<p>
It is straightforward to create animations with Mayavi.
In the following code the function \( h(x,y) \) is scaled vertically,
for different scaling constants between \( 0 \) and \( 1 \),
and each plot is saved in its own file.
The files can then be combined to a standard video file.

<p>
<!-- begin verbatim block  pycod-->
<pre><code>plt.figure(13, fgcolor=(.0, .0, .0), bgcolor=(1.0, 1.0, 1.0))
s = plt.surf(xv, yv, hv, warp_scale=0.01)

for i in range(10):
    # s.mlab_source.scalars is a handle for the values of the surface,
    # and is updated here
    s.mlab_source.scalars = hv*0.1*(i+1)
    plt.savefig('tmp_%04d.png' % i)
</code></pre>
<!-- end verbatim block -->

<p>
<p>
<!-- begin bottom navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._plot-solarized006.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._plot-solarized008.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end bottom navigation -->
</p>

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

