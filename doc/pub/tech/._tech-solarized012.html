<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Technical topics">
<meta name="keywords" content="Idle,Emacs,Vim,Gedit,TextWrangler,Notepad++,run Python program,execute Python program,make a folder (in Python),directory,environment variables,move to a folder (in Python),rename file/folder (in Python),list files (in Python),check file/folder existence (in Python),remove files (in Python),delete files (in Python),remove folders (in Python),delete folders (in Python),copy files (in Python),copy folders (in Python),run programs (from Python),execute programs (from Python),split filename,positional arguments,keyword arguments,variable no. of function arguments,time system,time user,time CPU,time elapsed,system time,user time,elapsed time,CPU time measurements,timing utilities,efficiency,profiling,optimization of Python code">

<title>Technical topics</title>


<link href="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
code { padding: 0px; background-color: inherit; }
pre {
  border: 0pt solid #93a1a1;
  box-shadow: none;
}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [(' Accessing Python ', 1, 'sec:accesspy', 'sec:accesspy'),
              (' Required software ',
               2,
               'sec:accesspy:softwarelist',
               'sec:accesspy:softwarelist'),
              (' Installing software on your laptop: Mac OS X and Windows ',
               2,
               'sec:accesspy:MacWin',
               'sec:accesspy:MacWin'),
              (' Anaconda and Spyder ',
               2,
               'sec:accesspy:anaconda',
               'sec:accesspy:anaconda'),
              (' Spyder on Mac ', 3, None, '___sec4'),
              (' Installation of additional packages ', 3, None, '___sec5'),
              (' VMWare Fusion virtual machine ',
               2,
               'sec:accesspy:vmware',
               'sec:accesspy:vmware'),
              (' Installing Ubuntu ',
               3,
               'sec:accesspy:vmware:fullblown:machine',
               'sec:accesspy:vmware:fullblown:machine'),
              (' Installing software on Ubuntu ', 3, None, '___sec8'),
              (' File sharing ', 3, None, '___sec9'),
              (' Dual boot on Windows ', 2, None, '___sec10'),
              (' Vagrant virtual machine ',
               2,
               'sec:accesspy:vagrant',
               'sec:accesspy:vagrant'),
              (' How to write and run a Python program ',
               2,
               'sec:accesspy:writerun',
               'sec:accesspy:writerun'),
              (' The need for a text editor ', 3, None, '___sec13'),
              (' Spyder ', 3, None, '___sec14'),
              (' Text editors ', 3, None, '___sec15'),
              (' Terminal windows ', 3, None, '___sec16'),
              (' Using a plain text editor and a terminal window ',
               3,
               None,
               '___sec17'),
              (' The SageMathCloud and Wakari web services ',
               2,
               'sec:accesspy:sagemath:wakari',
               'sec:accesspy:sagemath:wakari'),
              (' Basic intro to SageMathCloud ', 3, None, '___sec19'),
              (' Basic intro to Wakari ', 3, None, '___sec20'),
              (' Installing your own Python packages ', 3, None, '___sec21'),
              (' Writing IPython notebooks ',
               2,
               'sec:accesspy:ipynb',
               'sec:accesspy:ipynb'),
              (' A simple program in the notebook ', 3, None, '___sec23'),
              (' Mixing text, mathematics, code, and graphics ',
               3,
               None,
               '___sec24'),
              (' Different ways of running Python programs ',
               1,
               'ch:runpy',
               'ch:runpy'),
              (' Executing Python programs in iPython ',
               2,
               'sec:runpy:ipy',
               'sec:runpy:ipy'),
              (' Executing Python programs in Unix ',
               2,
               'sec:runpy:unix',
               'sec:runpy:unix'),
              (' Executing Python programs in Windows ',
               2,
               'sec:runpy:win',
               'sec:runpy:win'),
              (' Double-clicking Python files ', 3, None, '___sec29'),
              (' Executing Python programs in Mac OS X ',
               2,
               None,
               '___sec30'),
              (' Making a complete stand-alone executable ',
               2,
               None,
               '___sec31'),
              (' Doing operating system tasks in Python ',
               1,
               'ch:ostasks',
               'ch:ostasks'),
              (' Make a folder ', 3, None, '___sec33'),
              (' Make intermediate folders ', 3, None, '___sec34'),
              (' Move to a folder ', 3, None, '___sec35'),
              (' Rename a file or folder ', 3, None, '___sec36'),
              (' List files ', 3, None, '___sec37'),
              (' List all files and folders in a folder ',
               3,
               None,
               '___sec38'),
              (' Check if a file or folder exists ', 3, None, '___sec39'),
              (' Remove files ', 3, None, '___sec40'),
              (' Remove a folder and all its subfolders ',
               3,
               None,
               '___sec41'),
              (' Copy a file to another file or folder ',
               3,
               None,
               '___sec42'),
              (' Copy a folder and all its subfolders ', 3, None, '___sec43'),
              (' Run any operating system command ', 3, None, '___sec44'),
              (' Split file or folder name ', 3, None, '___sec45'),
              (' Variable number of function arguments ',
               1,
               'sec:args:kwargs',
               'sec:args:kwargs'),
              (' Variable number of positional arguments ',
               2,
               'sec:misc:varargs:pos',
               'sec:misc:varargs:pos'),
              (' Example ', 3, None, '___sec48'),
              (' Variable number of keyword arguments ',
               2,
               'sec:misc:varargs:kw',
               'sec:misc:varargs:kw'),
              (' Example ', 3, None, '___sec50'),
              (' Evaluating program efficiency ', 1, None, '___sec51'),
              (' Making time measurements ',
               2,
               'sec:timing:measures',
               'sec:timing:measures'),
              (' The time module ', 3, None, '___sec53'),
              (' Using timeit from IPython ', 3, None, '___sec54'),
              (' Hardware information ', 3, None, '___sec55'),
              (' Profiling Python programs ',
               2,
               'sec:timing:profiler',
               'sec:timing:profiler'),
              (' References ', 1, None, '___sec57')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



    
<a name="part0012"></a>
<p>
<!-- begin top navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._tech-solarized011.html">&laquo; Previous</a></div>
</td><td>
</td></tr></table>
<!-- end top navigation -->
</p>

<p>
<!-- !split -->
<p style="font-size:80%">This</p>

<h3 id="___sec44">Run any operating system command </h3>

<p>
The simplest way of running another program from Python is to
use <code>os.system</code>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>cmd = 'python myprog.py 21 --mass 4'   # command to be run
failure = os.system(cmd)
if failure:
    print 'Execution of &quot;%s&quot; failed!\n' % cmd
    sys.exit(1)
</code></pre>
<!-- end verbatim block -->
The recommended way to run operating system commands is to use
the <code>subprocess</code> module. The above command is equivalent to

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import subprocess
cmd = 'python myprog.py 21 --mass 4'
failure = subprocess.call(cmd, shell=True)

# or
failure = subprocess.call(
            ['python', 'myprog.py', '21', '--mass', '4'])
</code></pre>
<!-- end verbatim block -->
The output of an operating system command can be stored in a string
object:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>try:
    output = subprocess.check_output(cmd, shell=True,
                                     stderr=subprocess.STDOUT)
except subprocess.CalledProcessError:
    print 'Execution of &quot;%s&quot; failed!\n' % cmd
    sys.exit(1)

# Process output
for line in output.splitlines():
    ...
</code></pre>
<!-- end verbatim block -->
The <code>stderr</code> argument ensures that the <code>output</code>
string contains everything that the command <code>cmd</code> wrote
to both standard output and standard error.

<p>
The constructions above are mainly used for running stand-alone programs.
Any file or folder listing or manipulation should be done by the
functionality in the <code>os</code> and <code>shutil</code> modules.

<h3 id="___sec45">Split file or folder name </h3>

<p>
Given <code>data/file1.dat</code> as a file path relative to the
home folder <code>/users/me</code> (<code>$HOME/data/file1.dat</code> in Unix).
Python has tools for extracting the complete folder name
<code>/users/me/data</code>, the basename <code>file1.dat</code>, and the extension
<code>.dat</code>:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; path = os.path.join(os.environ['HOME'], 'data', 'file1.dat')
&gt;&gt;&gt; path
'/users/me/data/file1.dat'
&gt;&gt;&gt; foldername, basename = os.path.split(path)
&gt;&gt;&gt; foldername
'/users/me/data'
&gt;&gt;&gt; basename
'file1.dat'
&gt;&gt;&gt; stem, ext = os.path.splitext(basename)
&gt;&gt;&gt; stem
'file1'
&gt;&gt;&gt; ext
'.dat'
&gt;&gt;&gt; outfile = stem + '.out'
&gt;&gt;&gt; outfile
'file1.out'
</code></pre>
<!-- end verbatim block -->

<h1 id="sec:args:kwargs">Variable number of function arguments</h1>

<p>
Arguments to Python functions are of four types:

<ul>
  <li> positional arguments, where each argument has a name,</li>
  <li> keyword arguments, where each argument has a name and a default value,</li>
  <li> a variable number of positional arguments, where each argument
    has no name, but just a location in a list,</li>
  <li> a variable number of keyword arguments, where each argument is
    a name-value pair in a dictionary.</li>
</ul>

The corresponding general function definition can be sketched as

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def f(pos1, pos2, key1=val1, key2=val2, *args, **kwargs):
</code></pre>
<!-- end verbatim block -->
Here, <code>pos1</code> and <code>pos2</code> are positional arguments,
<code>key1</code> and <code>key2</code> are keyword arguments,
<code>args</code> is a tuple holding a variable number of positional arguments,
and <code>kwargs</code> is a dictionary holding a variable number of
keyword arguments.
This document describes how to program with the
<code>args</code> and <code>kwargs</code> variables and why these are handy in many
situations.

<h2 id="sec:misc:varargs:pos">Variable number of positional arguments</h2>

<p>
Let us start by making
a function that takes an arbitrary number of arguments and computes
their sum:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; def add(*args):
...     print 'args:', args
...     s = 0
...     for arg in args:
...         s = s + arg
...     return s
...
&gt;&gt;&gt; add(1)
args: (1,)
1
&gt;&gt;&gt; add(1,5,10)
args: (1, 5, 10)
16
</code></pre>
<!-- end verbatim block -->
We observe that <code>args</code> is a tuple and that all the arguments we
provide in a call to <code>add</code> are stored in <code>args</code>.

<p>
Combination of ordinary positional arguments and a variable number of
arguments is allowed, but the <code>*args</code> argument must appear after
the ordinary positional arguments, e.g.,

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def f(pos1, pos2, pos3, *args):
</code></pre>
<!-- end verbatim block -->
In each call to <code>f</code> we must provide at least three arguments.
If more arguments are supplied in the call,
these are collected in the <code>args</code>
tuple inside the <code>f</code> function.

<h3 id="___sec48">Example </h3>

<p>
Consider a mathematical function with one independent variable
\( t \) and a parameter \( v_0 \), as in \( y(t;v_0) = v_0t - \frac{1}{2}gt^2 \).
A more general case with \( n \) parameters is
\( f(x; p_1,\ldots,p_n) \). The Python implementation
of such functions can take both the independent variable and the
parameters as arguments: <code>y(t, v0)</code> and <code>f(x, p1, p2, ...,pn)</code>.
Suppose that we have
a general library routine
that operates on functions of one variable. The routine can, e.g.,
perform numerical differentiation, integration, or root finding. A simple
example is a numerical differentiation function

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def diff(f, x, h):
    return (f(x+h) - f(x))/h
</code></pre>
<!-- end verbatim block -->
This <code>diff</code> function cannot be used with functions <code>f</code> that
take more than one argument. For example, passing an <code>y(t, v0)</code> function
as <code>f</code> leads to the exception

<p>
<!-- begin verbatim block  ccq-->
<pre><code>TypeError: y() takes exactly 2 arguments (1 given)
</code></pre>
<!-- end verbatim block -->
A good  solution to this problem is to make a class <code>Y</code> that
has a <code>__call__(self, t)</code> method and that stores \( v_0 \) as an attribute.
Here we shall describe an alternative solution that allows our
<code>y(t, v0)</code> function to be used as is.

<p>
The idea is that we pass additional arguments for the parameters in
the <code>f</code> function <em>through</em> the <code>diff</code> function.
That is, we view the <code>f</code> function as <code>f(x, *f_prms)</code> in <code>diff</code>.
Our <code>diff</code> routine can then be written as

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def diff(f, x, h, *f_prms):
    print 'x:', x, 'h:', h, 'f_prms:', f_prms
    return (f(x+h, *f_prms) - f(x, *f_prms))/h
</code></pre>
<!-- end verbatim block -->
Before explaining this function in detail, we demonstrate that it works
in an example:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def y(t, v0):
    g = 9.81
     return v0*t - 0.5*g*t**2

dydt = diff(y, 0.1, 1E-9, 3)  # t=0.1, h=1E-9, v0=3
</code></pre>
<!-- end verbatim block -->
The output from the call to <code>diff</code> becomes

<p>
<!-- begin verbatim block  ccq-->
<pre><code>x: 0.1 h: 1e-09 f_prms: (3,)
</code></pre>
<!-- end verbatim block -->
The point is that the <code>v0</code> parameter, which we want to pass on to
our <code>y</code> function, is now stored in <code>f_prms</code>.
Inside the <code>diff</code> function, calling

<p>
<!-- begin verbatim block  pycod-->
<pre><code>f(x, *f_prms)
</code></pre>
<!-- end verbatim block -->
is the same as if we had written

<p>
<!-- begin verbatim block  pycod-->
<pre><code>f(x, f_prms[0], f_prms[1], ...)
</code></pre>
<!-- end verbatim block -->
That is, <code>*f_prms</code> in a call takes all the values in
the tuple <code>*f_prms</code> and places them after each other as positional
arguments. In the present example with the <code>y</code> function,
<code>f(x, *f_prms)</code> implies
<code>f(x, f_prms[0])</code>, which for the current set of argument values
in our example
becomes a call <code>y(0.1, 3)</code>.

<p>
For a function with many parameters,

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def G(x, t, A, a, w):
    return A*exp(-a*t)*sin(w*x)
</code></pre>
<!-- end verbatim block -->
the output from

<p>
<!-- begin verbatim block  pycod-->
<pre><code>dGdx = diff(G, 0.5, 1E-9, 0, 1, 0.6, 100)
</code></pre>
<!-- end verbatim block -->
becomes

<p>
<!-- begin verbatim block  ccq-->
<pre><code>x: 0.5 h: 1e-09 f_prms: (0, 1, 1.5, 100)
</code></pre>
<!-- end verbatim block -->
We pass here the arguments <code>t</code>, <code>A</code>, <code>a</code>, and <code>w</code>,
in that sequence, as the last four arguments to <code>diff</code>, and all
the values are stored in the <code>f_prms</code> tuple.

<p>
The <code>diff</code> function also works for a plain function <code>f</code> with
one argument:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>from math import sin
mycos = diff(sin, 0, 1E-9)
</code></pre>
<!-- end verbatim block -->
In this case, <code>*f_prms</code> becomes an empty tuple, and
a call like <code>f(x, *f_prms)</code> is just <code>f(x)</code>.

<p>
The use of a variable set of arguments for sending problem-specific
parameters through a general library function, as we have demonstrated
here with the <code>diff</code> function, is perhaps the most frequent use of
<code>*args</code>-type arguments.

<h2 id="sec:misc:varargs:kw">Variable number of keyword arguments</h2>

<p>
A simple test function

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; def test(**kwargs):
...     print kwargs
</code></pre>
<!-- end verbatim block -->
exemplifies that <code>kwargs</code> is a dictionary inside the <code>test</code>
function, and that we can pass any set of keyword arguments to <code>test</code>,
e.g.,

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; test(a=1, q=9, method='Newton')
{'a': 1, 'q': 9, 'method': 'Newton'}
</code></pre>
<!-- end verbatim block -->
We can combine an arbitrary set of positional and keyword arguments,
provided all the keyword arguments appear at the end of the
call:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; def test(*args, **kwargs):
...     print args, kwargs
...
&gt;&gt;&gt; test(1,3,5,4,a=1,b=2)
(1, 3, 5, 4) {'a': 1, 'b': 2}
</code></pre>
<!-- end verbatim block -->
From the output we understand that all the arguments in the call where
we provide a name and a value are treated as keyword arguments and
hence placed in <code>kwargs</code>, while all the remaining arguments are
positional and placed in <code>args</code>.

<h3 id="___sec50">Example </h3>

 We may extend the example in the section <a href="#sec:misc:varargs:pos">Variable number of positional arguments</a> to make use of a variable number of keyword arguments instead of a variable number of positional arguments.
Suppose all functions with parameters in addition to an independent variable
take the parameters as keyword arguments. For example,

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def y(t, v0=1):
    g = 9.81
    return v0*t - 0.5*g*t**2
</code></pre>
<!-- end verbatim block -->
In the <code>diff</code> function we transfer the parameters in the <code>f</code>
function as a set of keyword arguments <code>**f_prms</code>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def diff(f, x, h=1E-10, **f_prms):
    print 'x:', x, 'h:', h, 'f_prms:', f_prms
    return (f(x+h, **f_prms) - f(x, **f_prms))/h
</code></pre>
<!-- end verbatim block -->
In general, the <code>**f_prms</code> argument in a call

<p>
<!-- begin verbatim block  pycod-->
<pre><code>f(x, **f_prms)
</code></pre>
<!-- end verbatim block -->
implies that all the key-value pairs in <code>**f_prms</code> are
provided as keyword arguments:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>f(x, key1=f_prms[key1], key2=f_prms[key2], ...)
</code></pre>
<!-- end verbatim block -->
In our special case with the <code>y</code> function and the call

<p>
<!-- begin verbatim block  pycod-->
<pre><code>dydt = diff(y, 0.1, h=1E-9, v0=3)
</code></pre>
<!-- end verbatim block -->
<code>f(x, **f_prms)</code> becomes <code>y(0.1, v0=3)</code>.
The output from <code>diff</code> is now

<p>
<!-- begin verbatim block  ccq-->
<pre><code>x: 0.1 h: 1e-09 f_prms: {'v0': 3}
</code></pre>
<!-- end verbatim block -->
showing explicitly that our <code>v0=3</code> in the call to <code>diff</code> is placed
in the <code>f_prms</code> dictionary.

<p>
The <code>G</code> function from the section <a href="#sec:misc:varargs:pos">Variable number of positional arguments</a>
can also have its parameters as keyword arguments:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def G(x, t=0, A=1, a=1, w=1):
    return A*exp(-a*t)*sin(w*x)
</code></pre>
<!-- end verbatim block -->
We can now make the call

<p>
<!-- begin verbatim block  pycod-->
<pre><code>dGdx = diff(G, 0.5, h=1E-9, t=0, A=1, w=100, a=1.5)
</code></pre>
<!-- end verbatim block -->
and view the output from <code>diff</code>,

<p>
<!-- begin verbatim block  ccq-->
<pre><code>x: 0.5 h: 1e-09 f_prms: {'A': 1, 'a': 1.5, 't': 0, 'w': 100}
</code></pre>
<!-- end verbatim block -->
to see that all the parameters get stored in <code>f_prms</code>.
The <code>h</code> parameter can be placed anywhere in the collection
of keyword arguments, e.g.,

<p>
<!-- begin verbatim block  pycod-->
<pre><code>dGdx = diff(G, 0.5, t=0, A=1, w=100, a=1.5, h=1E-9)
</code></pre>
<!-- end verbatim block -->

<p>
We can allow the <code>f</code> function of one variable and a set of parameters
to have the general form <code>f(x, *f_args, **f_kwargs)</code>. That is,
the parameters can either be positional or keyword arguments.
The <code>diff</code> function must take the arguments <code>*f_args</code>
and <code>**f_kwargs</code> and transfer these to <code>f</code>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def diff(f, x, h=1E-10, *f_args, **f_kwargs):
    print f_args, f_kwargs
    return (f(x+h, *f_args, **f_kwargs) -
            f(x,   *f_args, **f_kwargs))/h
</code></pre>
<!-- end verbatim block -->
This <code>diff</code> function gives the writer of an <code>f</code> function full
freedom to choose positional and/or keyword arguments for the
parameters. Here is an example of the <code>G</code> function where we
let the <code>t</code> parameter be positional and the other parameters be
keyword arguments:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def G(x, t, A=1, a=1, w=1):
    return A*exp(-a*t)*sin(w*x)
</code></pre>
<!-- end verbatim block -->
A call

<p>
<!-- begin verbatim block  pycod-->
<pre><code>dGdx = diff(G, 0.5, 1E-9, 0, A=1, w=100, a=1.5)
</code></pre>
<!-- end verbatim block -->
gives the output

<p>
<!-- begin verbatim block  ccq-->
<pre><code>(0,) {'A': 1, 'a': 1.5, 'w': 100}
</code></pre>
<!-- end verbatim block -->
showing that <code>t</code> is put in <code>f_args</code> and transferred as
positional argument to <code>G</code>, while <code>A</code>, <code>a</code>, and <code>w</code>
are put in <code>f_kwargs</code> and transferred as keyword arguments.
We remark that in the last call to <code>diff</code>, <code>h</code> and <code>t</code>
<em>must</em> be treated as positional arguments, i.e., we cannot write
<code>h=1E-9</code> and <code>t=0</code> unless <em>all</em> arguments in the call are on the
<code>name=value</code> form.

<p>
In the case we use both <code>*f_args</code> and
<code>**f_kwargs</code> arguments in <code>f</code> and there is no need for
these arguments, <code>*f_args</code> becomes an empty tuple and
<code>**f_kwargs</code> becomes an empty dictionary. The example

<p>
<!-- begin verbatim block  pycod-->
<pre><code>mycos = diff(sin, 0)
</code></pre>
<!-- end verbatim block -->
shows that the tuple and dictionary are indeed empty since <code>diff</code>
just prints out

<p>
<!-- begin verbatim block  ccq-->
<pre><code>() {}
</code></pre>
<!-- end verbatim block -->
Therefore, a variable set of positional and keyword arguments can
be incorporated in a general library function such as
<code>diff</code> without any disadvantage, just the benefit that <code>diff</code>
works with different types of <code>f</code> functions: parameters as global
variables, parameters as additional positional arguments,
parameters as additional keyword arguments, or parameters as instance
variables.

<p>
The program <code>varargs1.py</code> in the <a href="http://tinyurl.com/pwyasaa/tech" target="_self"><tt>src/varargs</tt></a>
folder implements the examples in this document.

<h1 id="___sec51">Evaluating program efficiency </h1>

<p>
<!-- taken from TCSE3! -->

<p>
<div id="ch:timing"></div>

<h2 id="sec:timing:measures">Making time measurements</h2>

<p>
The term <em>time</em> has multiple meanings on a computer.
The <em>elapsed time</em> or <em>wall clock time</em>
is the same time as you can measure on
a watch or wall clock,
while <em>CPU time</em> is the amount of time the program keeps
the central processing unit busy. The <em>system time</em> is the
time spent on operating system tasks like I/O.
The concept <em>user time</em> is the difference between the CPU and
system times.
If your computer is occupied  by many concurrent processes,
the CPU time of your program might be very different from the
elapsed time.

<h3 id="___sec53">The time module </h3>

<p>
Python has a <code>time</code> module with some useful functions for
measuring the elapsed time and the CPU time:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import time
e0 = time.time()     # elapsed time since the epoch
c0 = time.clock()    # total CPU time spent in the program so far
&lt;do tasks...&gt;
elapsed_time = time.time() - e0
cpu_time = time.clock() - c0
</code></pre>
<!-- end verbatim block -->
The term
<em>epoch</em> means initial time (<code>time.time()</code> would return 0), which
is 00:00:00 January 1, 1970.
The <code>time</code> module also has numerous functions for nice formatting
of dates and time, and the newer <code>datetime</code> module
has more functionality and an improved interface.
Although the timing has a finer resolution than seconds, one should
construct test cases that last some seconds to obtain reliable results.

<h3 id="___sec54">Using timeit from IPython </h3>

<p>
To measure the efficiency of a certain set of statements, an
expression, or a function call,
the code should be run a large number of times so the
overall CPU time is of order seconds.
Python's <code>timeit</code> module has functionality for
running a code segment repeatedly. The simplest and most convenient
way of using <code>timeit</code> is within an IPython shell. Here is a
session comparing the efficiency of <code>sin(1.2)</code> versus <code>math.sin(1.2)</code>:

<p>
<!-- begin verbatim block -->
<pre><code>In [1]: import math

In [2]: from math import sin

In [3]: %timeit sin(1.2)
10000000 loops, best of 3: 198 ns per loop

In [4]: %timeit math.sin(1.2)
1000000 loops, best of 3: 258 ns per loop
</code></pre>
<!-- end verbatim block -->
That is,
looking up <code>sin</code> through the <code>math</code> prefix degrades the performance by a
factor of \( 258/198\approx 1.3 \).

<p>
Any statement, including function calls, can be timed the same way.
Timing of multiple statements is possible by using <code>%%timeit</code>.
The <code>timeit</code> module can be used inside ordinary programs as demonstrated
in the file <a href="http://tinyurl.com/pwyasaa/random/pow_eff.py" target="_self"><tt>pow_eff.py</tt></a>.

<h3 id="___sec55">Hardware information </h3>

<p>
Along with CPU time measurements it is often convenient to print out
information about the hardware on which the experiment was done.
Python has a module <code>platform</code> with information on the current
hardware. The function <code>scitools.misc.hardware_info</code>
applies the <code>platform</code> module and other modules
to extract relevant hardware information. A sample call is

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; import scitools.misc, pprint
&gt;&gt;&gt; pprint.pprint(scitools.misc.hardware_info())
{'numpy.distutils.cpuinfo.cpu.info': [
 {'address sizes': '40 bits physical, 48 bits virtual',
  'bogomips': '4598.87',
  'cache size': '4096 KB',
  'cache_alignment': '64',
  'cpu MHz': '2299.435',
  ...
 },
 'platform module': {
  'identifier': 'Linux-3.11.0-12-generic-x86_64-with-Ubuntu-13.10',
  'python build': ('default', 'Sep 19 2013 13:48:49'),
  'python version': '2.7.5+',
  'uname': ('Linux', 'hpl-ubuntu2-mac11', '3.11.0-12-generic',
            '#19-Ubuntu SMP Wed Oct 9 16:20:46 UTC 2013',
            'x86_64', 'x86_64')}}
}
</code></pre>
<!-- end verbatim block -->

<h2 id="sec:timing:profiler">Profiling Python programs</h2>

<p>
A profiler computes the time spent in the various functions of a
program.  From the timings a ranked list of the most time-consuming
functions can be created. This is an indispensable tool for detecting
bottlenecks in the code, and you should always perform a profiling
before spending time on code
optimization. The golden rule is to first write an easy-to-understand
program, then verify it,
then profile it,
and then think about
optimization.

<p>

<!-- begin box -->
<div style="width: 95%; padding: 10px; border: 1px solid #000; border-radius: 4px;">
<blockquote>
    <em>Premature optimization is the root of all evil.</em> <br />
    Donald Knuth, computer scientist, 1938-.
</blockquote>
</div>
<!-- end box -->


<p>
Python 2.7 comes with two recommended
profilers, implemented in the modules <code>cProfile</code>
and <code>profiles</code>.
The section <a href="http://docs.python.org/2/library/profile.html" target="_self">The Python Profilers</a> in the Python Standard Library documentation
<a href="#Python:Library:Reference">[12]</a> has a good introduction to
the usage of these modules.
The results produced
by the modules are normally processed by a special statistics
utility <code>pstats</code> developed for analyzing profiling results.
The usage of the <code>profile</code>, <code>cProfile</code>,
and <code>pstats</code> modules is straightforward,
but somewhat tedious. The SciTools
package therefore comes with a command
<code>scitools profiler</code> that allows you to profile
any program (say) <code>m.py</code> by just writing

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; scitools profiler m.py c1 c2 c3
</code></pre>
<!-- end verbatim block -->
Here, <code>c1</code>, <code>c2</code>, and <code>c3</code> are command-line arguments
to <code>m.py</code>.

<p>
A sample output might read

<p>
<!-- begin verbatim block  cc-->
<pre><code>    1082 function calls (728 primitive calls) in 17.890 CPU seconds

Ordered by: internal time
List reduced from 210 to 20 due to restriction &lt;20&gt;

ncalls  tottime  percall  cumtime  percall filename:lineno(function)
     5    5.850    1.170    5.850    1.170 m.py:43(loop1)
     1    2.590    2.590    2.590    2.590 m.py:26(empty)
     5    2.510    0.502    2.510    0.502 m.py:32(myfunc2)
     5    2.490    0.498    2.490    0.498 m.py:37(init)
     1    2.190    2.190    2.190    2.190 m.py:13(run1)
     6    0.050    0.008   17.720    2.953 funcs.py:126(timer)
...
</code></pre>
<!-- end verbatim block -->
In this test, <code>loop1</code> is the most expensive function, using 5.85
seconds, which is to be compared with 2.59 seconds for the next most
time-consuming function, <code>empty</code>.  The <code>tottime</code> entry is the total
time spent in a specific function, while <code>cumtime</code> reflects the total
time spent in the function and all the functions it calls.  We refer
to the documentation of the profiling tools in the Python Standard
Library documentation for detailed information on how to interpret the
output.

<p>
The CPU time of a Python program typically increases with a factor of
about five when run under the administration of the <code>profile</code> module.
Nevertheless, the relative CPU time among the functions are
not much affected by the profiler overhead.

<h1 id="___sec57">References </h1>

<p>
<!-- begin bibliography -->

<ol>
 <li> <div id="Python"></div> Python Programming Language. 
    <a href="http://python.org" target="_self"><tt>http://python.org</tt></a>.</li>
 <li> <div id="NumPy"></div> <b>T. E. Oliphant et al.</b>. 
    NumPy Array Processing Package for Python,
    <a href="http://www.numpy.org" target="_self"><tt>http://www.numpy.org</tt></a>.</li>
 <li> <div id="NumPy:paper"></div> <b>T. E. Oliphant</b>. 
    Python for Scientific Computing,
    <em>Computing in Science &amp; Engineering</em>,
    9,
    2007.</li>
 <li> <div id="Matplotlib"></div> <b>J. D. Hunter et al.</b>. 
    Matplotlib: Software Package for 2D Graphics,
    <a href="http://matplotlib.org/" target="_self"><tt>http://matplotlib.org/</tt></a>.</li>
 <li> <div id="Matplotlib:paper"></div> <b>J. D. Hunter</b>. 
    Matplotlib: a 2D Graphics Environment,
    <em>Computing in Science &amp; Engineering</em>,
    9,
    2007.</li>
 <li> <div id="IPython"></div> <b>F. Perez, B. E. Granger et al.</b>. 
    IPython Software Package for Interactive Scientific Computing,
    <a href="http://ipython.org/" target="_self"><tt>http://ipython.org/</tt></a>.</li>
 <li> <div id="IPython:paper"></div> <b>F. Perez and B. E. Granger</b>. 
    IPython: a System for Interactive Scientific Computing,
    <em>Computing in Science &amp; Engineering</em>,
    9,
    2007.</li>
 <li> <div id="Hinsen:Scientific"></div> ScientificPython Software Package. 
    <a href="http://starship.python.net/crew/hinsen" target="_self"><tt>http://starship.python.net/crew/hinsen</tt></a>.</li>
 <li> <div id="SymPy"></div> <b>O. Certik et al.</b>. 
    SymPy: Python library for symbolic mathematics,
    <a href="http://sympy.org" target="_self"><tt>http://sympy.org</tt></a>.</li>
<li> <div id="SciPy"></div> <b>E. Jones, T. E. Oliphant, P. Peterson et al.</b>. 
    SciPy Scientific Computing Library for Python,
    <a href="http://scipy.org" target="_self"><tt>http://scipy.org</tt></a>.</li>
<li> <div id="Langtangen_TCSE6_debug"></div> <b>H. P. Langtangen</b>. 
    Debugging in Python,
    <a href="http://hplgit.github.io/primer.html/doc/pub/debug" target="_self"><tt>http://hplgit.github.io/primer.html/doc/pub/debug</tt></a>.</li>
<li> <div id="Python:Library:Reference"></div> <b>P. S. Foundation</b>. 
    The Python Standard Library,
    <a href="http://docs.python.org/2/library/" target="_self"><tt>http://docs.python.org/2/library/</tt></a>.</li>
</ol>

<!-- end bibliography -->

<p>

<p>
<!-- begin bottom navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._tech-solarized011.html">&laquo; Previous</a></div>
</td><td>
</td></tr></table>
<!-- end bottom navigation -->
</p>

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

