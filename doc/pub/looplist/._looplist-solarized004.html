<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Loops and lists">
<meta name="keywords" content="loops,boolean expressions,logical expressions,factorial,lists,method (class),list comprehension,list, nested,nested lists,list comprehension,pretty print,sublist,slicing,nested loops,tuples,list functionality,sequence (data type),sum ($\Sigma$) implementation,comparing floating-point numbers,comparing real numbers,comparing objects">

<title>Loops and lists</title>


<link href="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
code { padding: 0px; background-color: inherit; }
pre {
  border: 0pt solid #93a1a1;
  box-shadow: none;
}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [('Table of contents',
               1,
               'table_of_contents',
               'table_of_contents'),
              ('While loops', 1, 'sec:basic:loops', 'sec:basic:loops'),
              ('A naive solution', 2, 'sec:basic:naive', 'sec:basic:naive'),
              ('While loops', 2, 'sec:basic:while', 'sec:basic:while'),
              ('Boolean expressions',
               2,
               'sec:basic:boolexpr',
               'sec:basic:boolexpr'),
              ('Loop implementation of a sum',
               2,
               'sec:basic:sumloop',
               'sec:basic:sumloop'),
              ('Lists', 1, None, '___sec5'),
              ('Basic list operations',
               2,
               'sec:lists:basc:op',
               'sec:lists:basc:op'),
              ('For loops', 2, None, '___sec7'),
              ('The nature of for loops', 3, None, '___sec8'),
              ('Making the table', 3, None, '___sec9'),
              ('Alternative implementations with lists and loops',
               1,
               None,
               '___sec10'),
              ('While loop implementation of a for loop',
               2,
               None,
               '___sec11'),
              ('The range construction', 2, None, '___sec12'),
              ('For loops with list indices', 2, None, '___sec13'),
              ('Changing list elements', 2, None, '___sec14'),
              ('List comprehension',
               2,
               'sec:basic:list:comprehension',
               'sec:basic:list:comprehension'),
              ('Traversing multiple lists simultaneously',
               2,
               None,
               '___sec16'),
              ('Nested lists',
               1,
               'sec:basic:nestedlists',
               'sec:basic:nestedlists'),
              ('A table as a list of rows or columns', 2, None, '___sec18'),
              ('Printing objects', 2, None, '___sec19'),
              ('Modules for pretty print of objects', 3, None, '___sec20'),
              ('Manual printing', 3, None, '___sec21'),
              ('Extracting sublists',
               2,
               'sec:basic:slice',
               'sec:basic:slice'),
              ('Example', 3, None, '___sec23'),
              ('Traversing nested lists', 2, None, '___sec24'),
              ('Tuples', 1, 'sec:lists:tuples', 'sec:lists:tuples'),
              ('Summary', 1, 'sec:looplist:summary', 'sec:looplist:summary'),
              ('Chapter topics', 2, None, '___sec27'),
              ('While loops', 3, None, '___sec28'),
              ('Lists', 3, None, '___sec29'),
              ('Nested lists', 3, None, '___sec30'),
              ('Tuples', 3, None, '___sec31'),
              ('For loops', 3, None, '___sec32'),
              ('Pretty print', 3, None, '___sec33'),
              ('Terminology', 3, None, '___sec34'),
              ('Example: Analyzing list data',
               2,
               'sec:looplist:summary:ex',
               'sec:looplist:summary:ex'),
              ('Problem', 3, None, '___sec36'),
              ('Solution', 3, None, '___sec37'),
              ('Remark', 3, None, '___sec38'),
              ('How to find more Python information',
               2,
               'sec:basic:pyinfo',
               'sec:basic:pyinfo'),
              ('Exercises', 1, None, '___sec40'),
              ('Exercise 1: Make a Fahrenheit-Celsius conversion table',
               2,
               'sec:basic:ex41',
               'sec:basic:ex41'),
              ('Exercise 2: Generate an approximate Fahrenheit-Celsius conversion table',
               2,
               'sec:basic:ex1',
               'sec:basic:ex1'),
              ('Exercise 3: Work with a list',
               2,
               'sec:basic:ex00',
               'sec:basic:ex00'),
              ('Exercise 4: Generate odd numbers',
               2,
               'sec:basic:ex0',
               'sec:basic:ex0'),
              ('Exercise 5: Compute the sum of the first $n$ integers',
               2,
               'sec:basic:sum:no',
               'sec:basic:sum:no'),
              ('Exercise 6: Compute energy levels in an atom',
               2,
               'sec:basic:exer:hydrogen',
               'sec:basic:exer:hydrogen'),
              ('Exercise 7: Generate equally spaced coordinates',
               2,
               'sec:basic:ex44',
               'sec:basic:ex44'),
              ('Exercise 8: Make a table of values from a formula',
               2,
               'sec:basic:ex4',
               'sec:basic:ex4'),
              ('Exercise 9: Store values from a formula in lists',
               2,
               'sec:basic:ex4b',
               'sec:basic:ex4b'),
              ('Exercise 10: Simulate operations on lists by hand',
               2,
               'sec:basic:ex43',
               'sec:basic:ex43'),
              ('Exercise 11: Compute a mathematical sum',
               2,
               'sec:basic:ex29a',
               'sec:basic:ex29a'),
              ('Exercise 12: Replace a while loop by a for loop',
               2,
               'sec:basic:ex29b',
               'sec:basic:ex29b'),
              ('Exercise 13: Simulate a program by hand',
               2,
               'sec:basic:ex24a',
               'sec:basic:ex24a'),
              ('Exercise 14: Explore Python documentation',
               2,
               'sec:basic:ex47',
               'sec:basic:ex47'),
              ('Exercise 15: Index a nested list',
               2,
               'sec:basic:ex15n',
               'sec:basic:ex15n'),
              ('Exercise 16: Store data in lists',
               2,
               'sec:basic:ex1b',
               'sec:basic:ex1b'),
              ('Exercise 17: Store data in a nested list',
               2,
               'sec:basic:ex4c',
               'sec:basic:ex4c'),
              ('Exercise 18: Values of boolean expressions',
               2,
               'sec:basic:ex15b',
               'sec:basic:ex15b'),
              ('Exercise 19: Explore round-off errors from a large number of inverse operations',
               2,
               'sec:basic:ex14b',
               'sec:basic:ex14b'),
              ('Exercise 20: Explore what zero can be on a computer',
               2,
               'sec:basic:ex14',
               'sec:basic:ex14'),
              ('Remarks', 3, None, '___sec61'),
              ('Exercise 21: Compare two real numbers with a tolerance',
               2,
               'sec:formula:ex14c',
               'sec:formula:ex14c'),
              ('Exercise 22: Interpret a code',
               2,
               'sec:basic:ex16',
               'sec:basic:ex16'),
              ('Exercise 23: Explore problems with inaccurate indentation',
               2,
               'sec:basic:ex3',
               'sec:basic:ex3'),
              ('Remarks', 3, None, '___sec65'),
              ('Exercise 24: Explore punctuation in Python programs',
               2,
               'sec:input:ex33',
               'sec:input:ex33'),
              ('Exercise 25: Investigate a for loop over a changing list',
               2,
               'sec:basic:ex18',
               'sec:basic:ex18'),
              ('References', 1, None, '___sec68')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\tp}{\thinspace .}
$$




    
<a name="part0004"></a>
<p>
<!-- begin top navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._looplist-solarized003.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._looplist-solarized005.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end top navigation -->
</p>

<p>
<!-- !split -->
<p style="font-size:80%">This chapter is taken from the book <a href="http://www.springer.com/gp/book/9783662498866">A Primer on Scientific Programming with Python</a> by H. P. Langtangen, 5th edition, Springer, 2016.</p>

<h1 id="sec:basic:nestedlists">Nested lists</h1>

<p>
Nested lists are list objects where the elements in the lists can be
lists themselves. A couple of examples will motivate for nested lists
and illustrate the basic operations on such lists.

<h2 id="___sec18">A table as a list of rows or columns </h2>

<p>
Our table data have so far used one separate
list for each column. If there were \( n \) columns, we would need \( n \)
list objects to represent the data in the table.
However, we think of a table as <em>one</em> entity, not a collection of
\( n \) columns.  It would therefore
be natural to use one argument for the whole table.
This is easy to achieve using a <em>nested list</em>,
where each entry in the list is a list itself.
A table object, for instance, is a list of lists, either a list of
the row elements of the table or a list of the column elements of
the table.
Here is an example where the table is a list of two columns, and each
column is a list of numbers:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>Cdegrees = range(-20, 41, 5)   # -20, -15, ..., 35, 40
Fdegrees = [(9.0/5)*C + 32 for C in Cdegrees]

table = [Cdegrees, Fdegrees]
</code></pre>
<!-- end verbatim block -->
(Note that any value
in \( [41,45] \) can be used as second argument (stop value)
to <code>range</code> and will
ensure that 40 is included in the range of generate numbers.)

<p>
With the subscript <code>table[0]</code> we can access the
first element in <code>table</code>, which is nothing but the <code>Cdegrees</code> list,
and with <code>table[0][2]</code> we reach
the third element in the first element, i.e.,
<code>Cdegrees[2]</code>.

<p>
<center> <!-- figure label: --> <div id="sec:basic:fig2"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 2:  Two ways of creating a table as a nested list. Left: table of columns <code>C</code> and <code>F</code>, where <code>C</code> and <code>F</code> are lists. Right: table of rows, where each row <code>[C, F]</code> is a list of two floats.  <!-- caption label: sec:basic:fig2 --> </p></center>
<p><img src="fig-looplist/table12.png" align="bottom" width=400></p>
</center>

<p>
However, tabular data with rows and columns usually have the convention
that the underlying data is a nested list where the first index counts
the rows and the second index counts the columns.
To have <code>table</code> on this form, we must construct <code>table</code> as
a list of <code>[C, F]</code> pairs. The first index will then run over rows
<code>[C, F]</code>. Here is how we may construct the nested list:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>table = []
for C, F in zip(Cdegrees, Fdegrees):
    table.append([C, F])
</code></pre>
<!-- end verbatim block -->
We may shorten this code segment by introducing
a list comprehension:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>table = [[C, F] for C, F in zip(Cdegrees, Fdegrees)]
</code></pre>
<!-- end verbatim block -->
This construction loops through pairs <code>C</code> and <code>F</code>, and for each pass in
the loop we create a list element <code>[C, F]</code>.

<p>
The subscript <code>table[1]</code> refers to the second element in <code>table</code>,
which is a <code>[C, F]</code> pair, while <code>table[1][0]</code> is the
<code>C</code> value and <code>table[1][1]</code> is the <code>F</code> value.
Figure <a href="#sec:basic:fig2">2</a> illustrates both a list of columns and a list
of pairs. Using this figure, you can realize that the first index looks
up an element in the outer list, and that this element can be indexed
with the second index.

<h2 id="___sec19">Printing objects </h2>

<h3 id="___sec20">Modules for pretty print of objects </h3>

<p>
We may write
<code>print table</code>
to immediately view the nested list
<code>table</code> from the previous section. In fact, any Python object <code>obj</code>
can be printed to the screen
by the command <code>print obj</code>.
The output is usually one line, and this line may become very long if the
list has many elements. For example, a long list like our
<code>table</code> variable, demands a quite long line when printed.

<p>
<!-- begin verbatim block  ccq-->
<pre><code>[[-20, -4.0], [-15, 5.0], [-10, 14.0], ............., [40, 104.0]]
</code></pre>
<!-- end verbatim block -->

<p>
Splitting the output over several shorter lines makes the
layout nicer and more readable.
The <code>pprint</code> module offers a <em>pretty print</em> functionality for
this purpose. The usage of <code>pprint</code> looks like

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import pprint
pprint.pprint(table)
</code></pre>
<!-- end verbatim block -->
and the corresponding output becomes

<p>
<!-- begin verbatim block  ccq-->
<pre><code>[[-20, -4.0],
 [-15, 5.0],
 [-10, 14.0],
 [-5, 23.0],
 [0, 32.0],
 [5, 41.0],
 [10, 50.0],
 [15, 59.0],
 [20, 68.0],
 [25, 77.0],
 [30, 86.0],
 [35, 95.0],
 [40, 104.0]]
</code></pre>
<!-- end verbatim block -->
With this document comes a slightly modified <code>pprint</code> module having the
name <code>scitools.pprint2</code>. This module
allows full format control of the printing of the <code>float</code> objects
in lists by specifying <code>scitools.pprint2.float_format</code>
as a printf format string. The following example demonstrates how the
output format of real numbers can be changed:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; import pprint, scitools.pprint2
&gt;&gt;&gt; somelist = [15.8, [0.2, 1.7]]
&gt;&gt;&gt; pprint.pprint(somelist)
[15.800000000000001, [0.20000000000000001, 1.7]]
&gt;&gt;&gt; scitools.pprint2.pprint(somelist)
[15.8, [0.2, 1.7]]
&gt;&gt;&gt; # default output is '%g', change this to
&gt;&gt;&gt; scitools.pprint2.float_format = '%.2e'
&gt;&gt;&gt; scitools.pprint2.pprint(somelist)
[1.58e+01, [2.00e-01, 1.70e+00]]
</code></pre>
<!-- end verbatim block -->
As can be seen from this session, the <code>pprint</code> module writes
floating-point numbers with a lot of digits, in fact so many that we
explicitly see the round-off errors. Many find this type of output
is annoying and that the default output from the <code>scitools.pprint2</code>
module is more like one would desire and expect.

<p>
The <code>pprint</code> and <code>scitools.pprint2</code> modules also have a function
<code>pformat</code>, which works as the <code>pprint</code> function, but it returns
a pretty formatted string instead of printing the string:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>s = pprint.pformat(somelist)
print s
</code></pre>
<!-- end verbatim block -->
This last <code>print</code> statement prints the same as <code>pprint.pprint(somelist)</code>.

<h3 id="___sec21">Manual printing </h3>

<p>
Many will argue that tabular data such as those stored in the
nested <code>table</code> list are not printed in a particularly pretty way
by the <code>pprint</code> module. One would rather expect pretty output to
be a table with two nicely aligned columns. To produce such output we
need to code the formatting manually. This is quite easy: we loop over
each row, extract the two elements <code>C</code> and <code>F</code> in each row,
and print these in fixed-width fields using the printf syntax.
The code goes as follows:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>for C, F in table:
    print '%5d %5.1f' % (C, F)
</code></pre>
<!-- end verbatim block -->

<h2 id="sec:basic:slice">Extracting sublists</h2>

<p>
Python has a nice syntax for extracting parts of a list structure. Such
parts are known as <em>sublists</em> or <em>slices</em>:

<p>
<code>A[i:]</code> is the sublist starting with index <code>i</code> in <code>A</code>
and continuing to the end of <code>A</code>:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; A = [2, 3.5, 8, 10]
&gt;&gt;&gt; A[2:]
[8, 10]
</code></pre>
<!-- end verbatim block -->
<code>A[i:j]</code> is the sublist starting with index <code>i</code> in <code>A</code>
and continuing up to and including index <code>j-1</code>.
Make sure you remember that the element corresponding to
index <code>j</code> is not included in the sublist:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; A[1:3]
[3.5, 8]
</code></pre>
<!-- end verbatim block -->
<code>A[:i]</code> is the sublist starting with index 0 in <code>A</code> and
continuing up to and including the element with index <code>i-1</code>:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; A[:3]
[2, 3.5, 8]
</code></pre>
<!-- end verbatim block -->
<code>A[1:-1]</code> extracts all elements except the first and the last
(recall that index <code>-1</code> refers to the last element),
and <code>A[:]</code> is the whole list:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; A[1:-1]
[3.5, 8]
&gt;&gt;&gt; A[:]
[2, 3.5, 8, 10]
</code></pre>
<!-- end verbatim block -->

<p>
In nested lists we may use slices in the first index, e.g.,

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; table[4:]
[[0, 32.0], [5, 41.0], [10, 50.0], [15, 59.0], [20, 68.0],
 [25, 77.0], [30, 86.0], [35, 95.0], [40, 104.0]]
</code></pre>
<!-- end verbatim block -->
We can also slice the second index, or both indices:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; table[4:7][0:2]
[[0, 32.0], [5, 41.0]]
</code></pre>
<!-- end verbatim block -->
Observe that <code>table[4:7]</code> makes a list
<code>[[0, 32.0], [5, 41.0], [10, 50.0]]</code> with three elements.
The slice <code>[0:2]</code> acts on this sublist and picks out its
first two elements,
with indices 0 and 1.

<p>
Sublists are always copies of the original list, so if you modify
the sublist the original list remains unaltered and vice versa:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; l1 = [1, 4, 3]
&gt;&gt;&gt; l2 = l1[:-1]
&gt;&gt;&gt; l2
[1, 4]
&gt;&gt;&gt; l1[0] = 100
&gt;&gt;&gt; l1             # l1 is modified
[100, 4, 3]
&gt;&gt;&gt; l2             # l2 is not modified
[1, 4]
</code></pre>
<!-- end verbatim block -->
The fact that slicing makes a copy can also be illustrated by the
following code:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; B = A[:]
&gt;&gt;&gt; C = A
&gt;&gt;&gt; B == A
True
&gt;&gt;&gt; B is A
False
&gt;&gt;&gt; C is A
True
</code></pre>
<!-- end verbatim block -->
The <code>B == A</code> boolean expression is <code>True</code> if all elements in <code>B</code>
are equal to the corresponding elements in <code>A</code>. The test
<code>B is A</code> is <code>True</code> if <code>A</code> and <code>B</code> are names for the
same list. Setting <code>C = A</code> makes <code>C</code> refer to the same
list object as <code>A</code>, while <code>B = A[:]</code> makes <code>B</code> refer to
a copy of the list referred to by <code>A</code>.

<h3 id="___sec23">Example </h3>

<p>
We end this information on sublists by writing
out the part of the <code>table</code> list of <code>[C, F]</code> rows
(see the section <a href="#sec:basic:nestedlists">Nested lists</a>) where
the Celsius degrees are between 10 and 35 (not including 35):

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; for C, F in table[Cdegrees.index(10):Cdegrees.index(35)]:
...     print '%5.0f %5.1f' % (C, F)
...
   10  50.0
   15  59.0
   20  68.0
   25  77.0
   30  86.0
</code></pre>
<!-- end verbatim block -->
You should always stop reading and convince yourself that you understand
why a code segment produces the printed output. In this latter example,
<code>Cdegrees.index(10)</code> returns the index corresponding to the value
<code>10</code> in the <code>Cdegrees</code> list. Looking at the <code>Cdegrees</code>
elements, one realizes (do it!) that the <code>for</code> loop is equivalent to

<p>
<!-- begin verbatim block  pycod-->
<pre><code>for C, F in table[6:11]:
</code></pre>
<!-- end verbatim block -->
This loop runs over the indices \( 6, 7, \ldots, 10 \) in <code>table</code>.

<h2 id="___sec24">Traversing nested lists </h2>

<p>
We have seen that traversing the nested list <code>table</code> could be
done by a loop of the form

<p>
<!-- begin verbatim block  pycod-->
<pre><code>for C, F in table:
    # process C and F
</code></pre>
<!-- end verbatim block -->
This is natural code when we know that <code>table</code> is a list of
<code>[C, F]</code> lists.
Now we shall address more general nested
lists where we do not necessarily know how many elements there are
in each list element of the list.

<p>
Suppose we use a nested list <code>scores</code> to record the scores of players in
a game: <code>scores[i]</code> holds a list of the historical scores obtained by player
number <code>i</code>. Different players have played the game a different number
of times, so the length of <code>scores[i]</code> depends on <code>i</code>.
Some code may help to make this clearer:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>scores = []
# score of player no. 0:
scores.append([12, 16, 11, 12])
# score of player no. 1:
scores.append([9])
# score of player no. 2:
scores.append([6, 9, 11, 14, 17, 15, 14, 20])
</code></pre>
<!-- end verbatim block -->
The list <code>scores</code> has three elements, each element
corresponding to a player.
The element no. <code>g</code> in the list
<code>scores[p]</code> corresponds to the score obtained in
game number <code>g</code> played by player number <code>p</code>.
The length of the lists <code>scores[p]</code>
varies and equals 4, 1, and 8 for <code>p</code> equal to 0, 1, and 2,
respectively.

<p>
In the general case we may have \( n \) players, and some may have played the
game a large number of times, making <code>scores</code> potentially a big
nested list.
How can we traverse the <code>scores</code> list
and write it out in a table format with nicely formatted columns?
Each row in the table corresponds to a player, while columns correspond
to scores.
For example,
the data initialized above can be written out as

<p>
<!-- begin verbatim block  ccq-->
<pre><code>  12  16  11  12
   9
   6   9  11  14  17  15  14  20
</code></pre>
<!-- end verbatim block -->
In a program, we must use
two <em>nested loops</em>, one for the elements
in <code>scores</code> and one for the elements in the sublists of <code>scores</code>.
The example below will make this clear.

<p>
There are two basic ways of traversing a nested list: either we use
integer indices for each index, or we use variables for the list elements.
Let us first exemplify the index-based version:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>for p in range(len(scores)):
    for g in range(len(scores[p])):
        score = scores[p][g]
        print '%4d' % score,
    print
</code></pre>
<!-- end verbatim block -->
With the trailing comma after the print string, we avoid a newline so
that the column values in the table (i.e., scores for one player)
appear at the same line. The single <code>print</code>
command after the loop over <code>c</code> adds a newline after each table row.
The reader is encouraged to go through the loops by hand and simulate
what happens in each statement (use the simple <code>scores</code> list initialized
above).

<p>
The alternative version where we use variables for iterating over the
elements in the <code>scores</code> list and its sublists looks like this:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>for player in scores:
    for game in player:
        print '%4d' % game,
    print
</code></pre>
<!-- end verbatim block -->
Again, the reader should step through the code by hand and realize what
the values of <code>player</code> and <code>game</code> are in each pass of the loops.

<p>
In the very general case, we have a nested list with many indices:
<code>somelist[i1][i2][i3]...</code>. To visit each of the elements
in the list, we use as many nested <code>for</code> loops as there are
indices. With four indices, iterating over integer indices look as

<p>
<!-- begin verbatim block  pycod-->
<pre><code>for i1 in range(len(somelist)):
    for i2 in range(len(somelist[i1])):
        for i3 in range(len(somelist[i1][i2])):
            for i4 in range(len(somelist[i1][i2][i3])):
                value = somelist[i1][i2][i3][i4]
                # work with value
</code></pre>
<!-- end verbatim block -->
The corresponding version iterating over sublists becomes

<p>
<!-- begin verbatim block  pycod-->
<pre><code>for sublist1 in somelist:
    for sublist2 in sublist1:
        for sublist3 in sublist2:
            for sublist4 in sublist3:
                value = sublist4
                # work with value
</code></pre>
<!-- end verbatim block -->

<p>
<p>
<!-- begin bottom navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._looplist-solarized003.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._looplist-solarized005.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end bottom navigation -->
</p>

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

