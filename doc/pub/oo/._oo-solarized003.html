<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Object-oriented programming">
<meta name="keywords" content="object-based programming,class hierarchy,class relationship superclass,class relationship derived class,class relationship inheritance,derived class,parent class,base class,superclass,subclass,class relationship subclass,Online Python Tutor,check an object's type,is-a class relationship,has-a class relationship,class relationship is-a,class relationship has-a,dynamic binding,factory function,closure,functional programming,Midpoint rule for integration,Trapezoidal rule for integration,overloading (of methods),polymorphism,Midpoint rule for integration,Trapezoidal rule for integration,recursive function calls,multiple inheritance,convergence rate,Trapezoidal rule for integration,Midpoint rule for integration,object-oriented programming">

<title>Object-oriented programming</title>


<link href="https://raw.githubusercontent.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [(' Inheritance and class hierarchies ',
               1,
               'sec:oo:inheritance',
               'sec:oo:inheritance'),
              (' A class for straight lines ',
               2,
               'sec:oo:Line',
               'sec:oo:Line'),
              (' A first try on a class for parabolas ',
               2,
               'sec:oo:Parabola1',
               'sec:oo:Parabola1'),
              (' A class for parabolas using inheritance ',
               2,
               None,
               '___sec3'),
              (' Program flow ', 3, None, '___sec4'),
              (' Checking the class type ', 2, None, '___sec5'),
              (' Attribute vs inheritance: has-a vs is-a relationship ',
               2,
               None,
               '___sec6'),
              (' Superclass for defining an interface ',
               2,
               'sec:oo:Func',
               'sec:oo:Func'),
              (' Class hierarchy for numerical differentiation ',
               1,
               'sec:oo:numdiff',
               'sec:oo:numdiff'),
              (' Classes for differentiation ',
               2,
               'sec:oo:Diff',
               'sec:oo:Diff'),
              (' Computer science remark ', 3, None, '___sec10'),
              (' Verification ', 2, None, '___sec11'),
              (' A flexible main program ', 2, None, '___sec12'),
              (' Extensions ', 2, 'sec:oo:Diff:extend', 'sec:oo:Diff:extend'),
              (' Application ', 3, None, '___sec14'),
              (' Alternative implementation via functions ',
               2,
               'sec:oo:diff:alt:func',
               'sec:oo:diff:alt:func'),
              (' Alternative implementation via functional programming ',
               2,
               'sec:oo:diff:alt:FP',
               'sec:oo:diff:alt:FP'),
              (' Alternative implementation via a single class ',
               2,
               'sec:oo:diff:oneclass',
               'sec:oo:diff:oneclass'),
              (' Remark ', 3, None, '___sec18'),
              (' Class hierarchy for numerical integration ',
               1,
               'sec:oo:int',
               'sec:oo:int'),
              (' Numerical integration methods ',
               2,
               'sec:oo:int:methods',
               'sec:oo:int:methods'),
              (' Classes for integration ',
               2,
               'sec:oo:Integrator',
               'sec:oo:Integrator'),
              (' Verification ', 2, None, '___sec22'),
              (' Using the class hierarchy ', 2, None, '___sec23'),
              (' About object-oriented programming ', 2, None, '___sec24'),
              (' Class hierarchy for making drawings ',
               1,
               'sec:oo:shapes',
               'sec:oo:shapes'),
              (' Using the object collection ', 2, None, '___sec26'),
              (' Basic drawing ', 3, None, '___sec27'),
              (' Groups of objects ', 3, None, '___sec28'),
              (' Changing line styles and colors ', 3, None, '___sec29'),
              (' The figure composition as an object hierarchy ',
               3,
               None,
               '___sec30'),
              (' Animation: translating the vehicle ', 3, None, '___sec31'),
              (' Animation: rolling the wheels ',
               3,
               'sketcher:vehicle1:anim',
               'sketcher:vehicle1:anim'),
              (' Example of classes for geometric objects ',
               2,
               None,
               '___sec33'),
              (' Simple geometric objects ', 3, None, '___sec34'),
              (' Class curve ', 3, None, '___sec35'),
              (' Compound geometric objects ', 3, None, '___sec36'),
              (' Adding functionality via recursion ', 2, None, '___sec37'),
              (' Basic principles of recursion ', 3, None, '___sec38'),
              (' Explaining recursion ', 3, None, '___sec39'),
              (' Scaling, translating, and rotating a figure ',
               2,
               'sketcher:scaling',
               'sketcher:scaling'),
              (' Scaling ', 3, None, '___sec41'),
              (' Translation ', 3, None, '___sec42'),
              (' Rotation ', 3, None, '___sec43'),
              (' Classes for DNA analysis ', 1, 'bioinf:oo', 'bioinf:oo'),
              (' Class for regions ', 2, None, '___sec45'),
              (' Class for genes ', 2, None, '___sec46'),
              (' Basic features of class gene ', 3, None, '___sec47'),
              (' Flexible constructor ', 3, None, '___sec48'),
              (' Other methods ', 3, None, '___sec49'),
              (' Subclasses ', 2, None, '___sec50'),
              (' Summary ', 1, None, '___sec51'),
              (' Chapter topics ', 2, None, '___sec52'),
              (' Subclass example ', 3, None, '___sec53'),
              (' Subclassing in general ', 3, None, '___sec54'),
              (' Terminology ', 3, None, '___sec55'),
              (' Example: Input data reader ',
               2,
               'sec:oo:ReadInput',
               'sec:oo:ReadInput'),
              (' Problem ', 3, None, '___sec57'),
              (' Solution ', 3, None, '___sec58'),
              (' Prompting the user ', 3, None, '___sec59'),
              (' Reading from file ', 3, None, '___sec60'),
              (' Reading from the command line ', 3, None, '___sec61'),
              (' Reading from a gui ', 3, None, '___sec62'),
              (' More flexibility in the superclass ', 3, None, '___sec63'),
              (' Demonstrating the tool ', 3, None, '___sec64'),
              (' Exercises ', 1, None, '___sec65'),
              (' Exercise 1: Demonstrate the magic of inheritance ',
               2,
               'sec:oo:ex1',
               'sec:oo:ex1'),
              (' Exercise 2: Make polynomial subclasses of parabolas ',
               2,
               'sec:oo:ex2',
               'sec:oo:ex2'),
              (' Remarks ', 3, None, '___sec68'),
              (' Exercise 3: Implement a class for a function as a subclass ',
               2,
               'sec:oo:ex3',
               'sec:oo:ex3'),
              (' Exercise 4: Create an alternative class hierarchy for polynomials ',
               2,
               'sec:oo:ex5',
               'sec:oo:ex5'),
              (' Exercise 5: Make circle a subclass of an ellipse ',
               2,
               'sec:oo:ex5b',
               'sec:oo:ex5b'),
              (' Exercise 6: Make super- and subclass for a point ',
               2,
               'sec:oo:ex17',
               'sec:oo:ex17'),
              (' Exercise 7: Modify a function class by subclassing ',
               2,
               'sec:oo:ex7',
               'sec:oo:ex7'),
              (' Exercise 8: Explore the accuracy of difference formulas ',
               2,
               'sec:oo:ex18',
               'sec:oo:ex18'),
              (' Exercise 9: Implement a subclass ',
               2,
               'sec:oo:ex15b',
               'sec:oo:ex15b'),
              (' Exercise 10: Make classes for numerical differentiation ',
               2,
               'sec:oo:ex33',
               'sec:oo:ex33'),
              (' Exercise 11: Implement a new subclass for differentiation ',
               2,
               'sec:oo:ex31',
               'sec:oo:ex31'),
              (' Exercise 12: Understand if a class can be used recursively ',
               2,
               'sec:oo:ex14',
               'sec:oo:ex14'),
              (' Exercise 13: Represent people by a class hierarchy ',
               2,
               'sec:oo:ex4',
               'sec:oo:ex4'),
              (' Remark ', 3, None, '___sec80'),
              (' Exercise 14: Add a new class in a class hierarchy ',
               2,
               'sec:oo:ex15',
               'sec:oo:ex15'),
              (' Exercise 15: Compute convergence rates of numerical integration methods ',
               2,
               'sec:oo:ex16',
               'sec:oo:ex16'),
              (' Exercise 16: Add common functionality in a class hierarchy ',
               2,
               'sec:oo:ex6',
               'sec:oo:ex6'),
              (' Exercise 17: Make a class hierarchy for root finding ',
               2,
               'sec:oo:ex41',
               'sec:oo:ex41'),
              (' Exercise 18: Make a calculus calculator class ',
               2,
               'sec:plot:ex30',
               'sec:plot:ex30'),
              (' Exercise 19: Compute inverse functions ',
               2,
               'sec:plot:ex30b',
               'sec:plot:ex30b'),
              (' Exercise 20: Make line drawing of a person; program ',
               2,
               'pysketcher:exer:person:prog',
               'pysketcher:exer:person:prog'),
              (' Exercise 21: Make line drawing of a person; class ',
               2,
               'pysketcher:exer:person:class',
               'pysketcher:exer:person:class'),
              (' Exercise 22: Animate a person with waving hands ',
               2,
               'pysketcher:exer:person:anim',
               'pysketcher:exer:person:anim'),
              (' References ', 1, None, '___sec90')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\tp}{\thinspace .}
$$




    
<a name="part0003"></a>
<p>
<!-- begin top navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._oo-solarized002.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._oo-solarized004.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end top navigation -->
</p>

<p>
<!-- !split -->

<h1>Class hierarchy for numerical integration <a name="sec:oo:int"></a></h1>

<p>
There are many different numerical methods for integrating a
mathematical function, just as there are many different methods for
differentiating a function.  It is thus obvious that the idea of
object-oriented programming and class hierarchies can be applied to
numerical integration formulas in the same manner as we did in the section <a href="._oo-solarized002.html#sec:oo:numdiff">Class hierarchy for numerical differentiation</a>.

<h2>Numerical integration methods <a name="sec:oo:int:methods"></a></h2>

<p>
First, we list some different methods for integrating \( \int_a^bf(x)dx \)
using \( n \) evaluation points. All the methods can be written
as

$$
\begin{equation}
\int_a^b f(x)dx \approx \sum_{i=0}^{n-1} w_i f(x_i),
\end{equation}
$$

where \( w_i \) are weights and \( x_i \) are evaluation points,
\( i=0,\ldots,n-1 \).
The Midpoint method has

$$
\begin{equation}
x_i = a + {h\over 2} + ih,\quad w_i=h,\quad h={b-a\over n},\quad i=0,\ldots,n-1\tp
\tag{7}
\end{equation}
$$

The Trapezoidal method has the points

$$
\begin{equation}
x_i = a+ih, \quad h={b-a\over n-1},\quad i=0,\ldots,n-1,
\end{equation}
$$

and the weights

$$
\begin{equation}
w_0=w_{n-1}={h\over2},\ w_i=h, \quad i=1,\ldots,n-2\tp
\end{equation}
$$

Simpson's rule has the same evaluation points as the Trapezoidal rule, but

$$
\begin{equation}
h = 2{b-a\over n-1},\quad w_0=w_{n-1}={h\over6},
\end{equation}
$$


$$
\begin{equation}
w_i={h\over3}\hbox{ for } i=2,4,\ldots,n-3,
\end{equation}
$$


$$
\begin{equation}
w_i={2h\over3}\hbox{ for } i=1,3,5,\ldots,n-2\tp
\end{equation}
$$

Note that \( n \) must be odd in Simpson's rule.
A Two-Point Gauss-Legendre method takes the form

$$
\begin{equation}
x_i = a+(i+ \frac{1}{2})h - {1\over\sqrt{3}}{h\over2}\quad\hbox{for } i=0,2,4,\ldots,n-2,
\end{equation}
$$


$$
\begin{equation}
x_i = a+(i+ \frac{1}{2})h + {1\over\sqrt{3}}{h\over2}\quad\hbox{for } i=1,3,5,\ldots,n-1,
\end{equation}
$$

with \( h=2(b-a)/n \). Here \( n \) must be even.
All the weights have the same value: \( w_i=h/2 \), \( i=0,\ldots,n-1 \).
Figure <a href="#fig:intpoints">3</a> illustrates how the points in various integration
rules are distributed over a few intervals.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 3:  Illustration of the distribution of points for various   numerical integration methods.   The Gauss-Legendre method has 10 points, while the other methods have   11 points in \( [0,10] \). <a name="fig:intpoints"></a> </p></center>
<p><img src="fig-oo/integration_rules.png" align="bottom" width=400></p>
</center>

<h2>Classes for integration <a name="sec:oo:Integrator"></a></h2>

<p>
We may store \( x_i \) and \( w_i \) in two NumPy arrays and compute the
integral as \( \sum_{i=0}^{n-1} w_if(x_i) \).  This operation can also be
vectorized as a dot (inner) product between the \( w_i \) vector and the
\( f(x_i) \) vector, provided \( f(x) \) is implemented in a vectorizable
form.

<p>
We argued in the section ref{sec:class:autoint} that it pays off to
implement a numerical integration formula as a class.  If we do so
with the different methods from the previous section, a typical class
looks like this:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class SomeIntegrationMethod:
    def __init__(self, a, b, n):
        # Compute self.points and self.weights

    def integrate(self, f):
        s = 0
        for i in range(len(self.weights)):
            s += self.weights[i]*f(self.points[i])
        return s
</code></pre>
<!-- end verbatim block -->
Making such classes for many different integration methods soon
reveals that all the classes contain common code, namely the
<code>integrate</code> method for computing \( \sum_{i=0}^{n-1} w_if(x_i) \).
Therefore, this common code can be placed in a superclass, and
subclasses can just add the code that is specific to a certain
numerical integration formula, namely the definition of the weights
\( w_i \) and the points \( x_i \).

<p>
Let us start with the superclass:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class Integrator:
    def __init__(self, a, b, n):
        self.a, self.b, self.n = a, b, n
        self.points, self.weights = self.construct_method()

    def construct_method(self):
        raise NotImplementedError('no rule in class %s' %
                                  self.__class__.__name__)

    def integrate(self, f):
        s = 0
        for i in range(len(self.weights)):
            s += self.weights[i]*f(self.points[i])
        return s
</code></pre>
<!-- end verbatim block -->

<p>
As we have seen, we store the \( a \), \( b \), and \( n \) data about the
integration method in the constructor. Moreover, we compute arrays or
lists <code>self.points</code> for the \( x_i \) points and <code>self.weights</code> for the
\( w_i \) weights. All this code can now be inherited by all subclasses.

<p>
The initialization of points and weights is put in a separate method,
<code>construct_method</code>, which is supposed to be implemented in each
subclass, but the superclass provides a default implementation, which
tells the user that the method is not implemented.  What happens is
that when subclasses redefine a method, that method overrides the
method inherited from the superclass. Hence, if we forget to redefine
<code>construct_method</code> in a subclass, we will inherit the one from the
superclass, and this method issues an error message. The construction
of this error message is quite clever in the sense that it will tell
in which class the <code>construct_method</code> method is missing (<code>self</code> will
be the subclass instance and its <code>__class__.__name__</code> is a string with
the corresponding subclass name).

<p>
In computer science one usually speaks about <em>overloading</em> a method in
a subclass, but the words redefining and overriding are also used.  A
method that is overloaded is said to be <em>polymorphic</em>.  A related
term, <em>polymorphism</em>, refers to coding with polymorphic methods. Very
often, a superclass provides some default implementation of a method,
and a subclass overloads the method with the purpose of tailoring the
method to a particular application.

<p>
The <code>integrate</code> method is common for all integration rules, i.e., for
all subclasses, so it can be inherited as it is.  A vectorized version
can also be added in the superclass to make it automatically available
also in all subclasses:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>    def vectorized_integrate(self, f):
        return np.dot(self.weights, f(self.points))
</code></pre>
<!-- end verbatim block -->

<p>
Let us then implement a subclass. Only the <code>construct_method</code> method
needs to be written. For the Midpoint rule, this is a matter of
translating the formulas in <a href="#mjx-eqn-7">(7)</a> to Python:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class Midpoint(Integrator):
    def construct_method(self):
        a, b, n = self.a, self.b, self.n  # quick forms
        h = (b-a)/float(n)
        x = np.linspace(a + 0.5*h, b - 0.5*h, n)
        w = np.zeros(len(x)) + h
        return x, w
</code></pre>
<!-- end verbatim block -->
Observe that we implemented directly a vectorized code. We could also have
used (slow) loops and explicit indexing:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>        x = np.zeros(n)
        w = np.zeros(n)
        for i in range(n):
            x[i] = a + 0.5*h + i*h
            w[i] = h
</code></pre>
<!-- end verbatim block -->

<p>
Before we continue with other subclasses for other numerical
integration formulas, we will have a look at the program flow when we
use class <code>Midpoint</code>.  Suppose we want to integrate \( \int_0^2x^2dx \)
using \( 101 \) points:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def f(x): return x*x
m = Midpoint(0, 2, 101)
print m.integrate(f)
</code></pre>
<!-- end verbatim block -->
How is the program flow? The assignment to <code>m</code> invokes the constructor
in class <code>Midpoint</code>. Since this class has no constructor, we invoke
the inherited one from the superclass <code>Integrator</code>. Here attributes
are stored, and then the <code>construct_method</code> method is called. Since
<code>self</code> is a <code>Midpoint</code> instance, it is the <code>construct_method</code> in the
<code>Midpoint</code> class that is invoked, even if there is a method with the
same name in the superclass. Class <code>Midpoint</code> overloads
<code>construct_method</code> in the superclass. In a way, we &quot;jump down&quot; from
the constructor in class <code>Integrator</code> to the <code>construct_method</code> in the
<code>Midpoint</code> class.  The next statement, <code>m.integrate(f)</code>, just calls
the inherited <code>integral</code> method that is common to all subclasses.

<p>
The points and weights for a Trapezoidal rule can be implemented
in a vectorized way in another subclass with name <code>Trapezoidal</code>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class Trapezoidal(Integrator):
    def construct_method(self):
        x = np.linspace(self.a, self.b, self.n)
        h = (self.b - self.a)/float(self.n - 1)
        w = np.zeros(len(x)) + h
        w[0] /= 2
        w[-1] /= 2
        return x, w
</code></pre>
<!-- end verbatim block -->
Observe how we divide the first and last weight by 2, using index 0
(the first) and -1 (the last)
and the <code>/=</code> operator (<code>a /= b</code> is equivalent to <code>a = a/b</code>).
We could also have implemented a scalar version with loops.
The relevant code is in function <code>trapezoidal</code> in the section ref{sec:class:autoint}.

<p>
Class Simpson has a slightly more demanding rule, at least if we want
to vectorize the expression, since the weights
are of two types.

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class Simpson(Integrator):
    def construct_method(self):
        if self.n % 2 != 1:
            print 'n=%d must be odd, 1 is added' % self.n
            self.n += 1
        x = np.linspace(self.a, self.b, self.n)
        h = (self.b - self.a)/float(self.n - 1)*2
        w = np.zeros(len(x))
        w[0:self.n:2] = h*1.0/3
        w[1:self.n-1:2] = h*2.0/3
        w[0] /= 2
        w[-1] /= 2
        return x, w
</code></pre>
<!-- end verbatim block -->
We first control that we have an odd number of points, by checking
that the remainder of <code>self.n</code> divided by two is 1.  If not, an
exception could be raised, but for smooth operation of the class, we
simply increase \( n \) so it becomes odd. Such automatic adjustments of
input is not a rule to be followed in general. Wrong input is best
notified explicitly.  However, sometimes it is user friendly to make
small adjustments of the input, as we do here, to achieve a smooth and
successful operation.  (In cases like this, a user might become
uncertain whether the answer can be trusted if she (later) understands
that the input should not yield a correct result. Therefore, do the
adjusted computation, and provide a notification to the user about
what has taken place.)

<p>
The computation of the weights <code>w</code> in class <code>Simpson</code> applies slices
with stride (jump/step) 2 such that the operation is vectorized for
speed.  Recall that the upper limit of a slice is not included in the
set, so <code>self.n-1</code> is the largest index in the first case, and
<code>self.n-2</code> is the largest index in the second case.  Instead of the
vectorized operation of slices for computing <code>w</code>, we could use
(slower) straight loops:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>        for i in range(0, self.n, 2):
            w[i] = h*1.0/3
        for i in range(1, self.n-1, 2):
            w[i] = h*2.0/3
</code></pre>
<!-- end verbatim block -->

<p>
The points in the Two-Point Gauss-Legendre rule are
slightly more complicated to calculate, so here we apply straight loops
to make a safe first implementation:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class GaussLegendre2(Integrator):
    def construct_method(self):
        if self.n % 2 != 0:
            print 'n=%d must be even, 1 is subtracted' % self.n
            self.n -= 1
        nintervals = int(self.n/2.0)
        h = (self.b - self.a)/float(nintervals)
        x = np.zeros(self.n)
        sqrt3 = 1.0/math.sqrt(3)
	for i in range(nintervals):
            x[2*i]   = self.a + (i+0.5)*h - 0.5*sqrt3*h
            x[2*i+1] = self.a + (i+0.5)*h + 0.5*sqrt3*h
        w = np.zeros(len(x)) + h/2.0
        return x, w
</code></pre>
<!-- end verbatim block -->

<p>
A vectorized calculation of <code>x</code> is possible by observing that the
<code>(i+0.5)*h</code> expression can be computed by <code>np.linspace</code>, and then we
can add the remaining two terms:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>m = np.linspace(0.5*h, (nintervals-1+0.5)*h, nintervals)
x[0:self.n-1:2] = m + self.a - 0.5*sqrt3*h
x[1:self.n:2]   = m + self.a + 0.5*sqrt3*h
</code></pre>
<!-- end verbatim block -->
The array on the right-hand side has half the length of <code>x</code> (\( n/2 \)),
but the length matches exactly the slice with stride 2 on the left-hand side.

<p>
The code snippets above are found in the module file
<a href="http://tinyurl.com/pwyasaa/oo/integrate.py" target="_self"><tt>integrate.py</tt></a>.

<h2>Verification  <a name="___sec22"></a></h2>

<p>
To verify the implementation we use the fact that all the subclasses
implement methods that can integrate a linear function exactly.
A suitable test function is therefore

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def test_Integrate():
    def f(x):
        return x + 2

    def F(x):
        &quot;&quot;&quot;Integral of f.&quot;&quot;&quot;
        return 0.5*x**2 + 2*x

    a = 2; b = 3; n = 4     # test data
    I_exact = F(b) - F(a)
    tol = 1E-15

    methods = [Midpoint, Trapezoidal, Simpson, GaussLegendre2,
               GaussLegendre2_vec]
    for method in methods:
        integrator = method(a, b, n)

        I = integrator.integrate(f)
        assert abs(I_exact - I) &lt; tol

        I_vec = integrator.vectorized_integrate(f)
        assert abs(I_exact - I_vec) &lt; tol
</code></pre>
<!-- end verbatim block -->

<p>
A stronger method of verification is to compute how the error
varies with \( n \). <a href="._oo-solarized006.html#sec:oo:ex16">Exercise 15: Compute convergence rates of numerical integration methods</a> explains the details.

<h2>Using the class hierarchy  <a name="___sec23"></a></h2>

<p>
To verify the implementation, we first try to integrate a linear
function.  All methods should compute the correct integral value
regardless of the number of evaluation points:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def f(x):
    return x + 2

a = 2; b = 3; n = 4
for Method in Midpoint, Trapezoidal, Simpson, GaussLegendre2:
    m = Method(a, b, n)
    print m.__class__.__name__, m.integrate(f)
</code></pre>
<!-- end verbatim block -->
Observe how we simply list the class names as a tuple (comma-separated
objects), and <code>Method</code> will in the <code>for</code> loop attain the values
<code>Midpoint</code>, <code>Trapezoidal</code>, and so forth. For example, in the first
pass of the loop, <code>Method(a, b, n)</code> is identical to <code>Midpoint(a, b,
n)</code>.

<p>
The output of the test above becomes

<p>
<!-- begin verbatim block  ccq-->
<pre><code>Midpoint 4.5
Trapezoidal 4.5
n=4 must be odd, 1 is added
Simpson 4.5
GaussLegendre2 4.5
</code></pre>
<!-- end verbatim block -->
Since \( \int_2^3 (x+2)dx = \frac{9}{2}=4.5 \), all methods passed this simple test.

<p>
A more challenging integral, from a numerical point of view, is

$$
\begin{equation*} \int\limits_0^1 \left(1 + {1\over m}\right)t^{1\over m} dt= 1 \tp\end{equation*}
$$

To use any subclass in the <code>Integrator</code> hierarchy, the integrand
must be a function of one variable
only. For the present integrand, which depends on
\( t \) and \( m \), we use a class to represent it:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class F:
    def __init__(self, m):
        self.m = float(m)

    def __call__(self, t):
        m = self.m
        return (1 + 1/m)*t**(1/m)
</code></pre>
<!-- end verbatim block -->
We now ask the question: how much is the error in the integral
reduced as we increase the number of integration points (\( n \))?
It appears that the error decreases exponentially with \( n \), so if
we want to plot the errors versus \( n \), it is best to plot the
logarithm of the error versus \( \ln n \). We expect this graph to be
a straight line, and the steeper the line is, the faster the error
goes to zero as \( n \) increases. A common conception is to regard one
numerical method as better than another if the error goes faster
to zero as we increase the computational work (here \( n \)).

<p>
For a given \( m \) and method, the following function computes two lists
containing the logarithm of the \( n \) values, and the logarithm of the
corresponding errors in a series of experiments:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def error_vs_n(f, exact, n_values, Method, a, b):
    log_n = []  # log of actual n values (Method may adjust n)
    log_e = []  # log of corresponding errors
    for n_value in n_values:
        method = Method(a, b, n_value)
        error = abs(exact - method.integrate(f))
        log_n.append(log(method.n))
        log_e.append(log(error))
    return log_n, log_e
</code></pre>
<!-- end verbatim block -->
We can plot the error versus \( n \) for several methods in the same plot
and make one plot for each \( m \) value.  The loop over \( m \) below makes
such plots:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>n_values = [10, 20, 40, 80, 160, 320, 640]
for m in 1./4, 1./8., 2, 4, 16:
    f = F(m)
    figure()
    for Method in Midpoint, Trapezoidal, \ 
            Simpson, GaussLegendre2:
        n, e = error_vs_n(f, 1, n_values, Method, 0, 1)
        plot(n, e); legend(Method.__name__); hold('on')
    title('m=%g' % m); xlabel('ln(n)'); ylabel('ln(error)')
</code></pre>
<!-- end verbatim block -->
The code snippets above are collected in a function <code>test</code>
in the <code>integrate.py</code> file.

<p>
The plots for \( m>1 \) look very similar. The plots for \( 0 < m < 1 \) are also
similar, but different from the \( m>1 \) cases. Let us have a look at the
results for \( m=1/4 \) and \( m=2 \).  The first, \( m=1/4 \), corresponds to
\( \int_0^1 5x^4dx \).  Figure <a href="#fig:powerfunc:fig1">4</a> shows that the
error curves for the Trapezoidal and Midpoint methods converge more
slowly compared to the error curves for Simpson's rule and the
Gauss-Legendre method. This is the usual situation for these methods,
and mathematical analysis of the methods can confirm the results in
Figure <a href="#fig:powerfunc:fig1">4</a>.

<p>
However, when we consider the integral
\( \int_0^1\frac{3}{2}\sqrt{x}dx \), (\( m=2 \)) and \( m>1 \) in general, all the
methods converge with the same speed, as shown in Figure
<a href="#fig:powerfunc:fig2">5</a>. Our integral is difficult to compute
numerically when \( m>1 \), and the theoretically better methods
(Simpson's rule and the Gauss-Legendre method) do not converge faster
than the simpler methods. The difficulty is due to the infinite slope
(derivative) of the integrand at \( x=0 \).

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 4:  The logarithm of the error versus the logarithm of integration points   for integral \( 5x^4 \) computed by the Trapezoidal and Midpoint methods   (upper two lines), and Simpson's rule and the Gauss-Legendre methods (lower   two lines). <a name="fig:powerfunc:fig1"></a> </p></center>
<p><img src="fig-oo/power_int_m1.png" align="bottom" width=400></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 5:  The logarithm of the error versus the logarithm of integration points   for integral \( \frac{3}{2}\sqrt{x} \) computed by the Trapezoidal method and Simpson's rule   (upper two lines), and Midpoint and Gauss-Legendre methods (lower   two lines). <a name="fig:powerfunc:fig2"></a> </p></center>
<p><img src="fig-oo/power_int_m2.png" align="bottom" width=400></p>
</center>

<h2>About object-oriented programming  <a name="___sec24"></a></h2>

<p>
From an implementational point of view, the advantage of class
hierarchies in Python is that we can save coding by inheriting
functionality from a superclass.  In programming languages where each
variable must be specified with a fixed type, class hierarchies are
particularly useful because a function argument with a special type
also works with all subclasses of that type. Suppose we have a
function where we need to integrate:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def do_math(arg1, arg2, integrator):
    ...
    I = integrator.integrate(myfunc)
    ...
</code></pre>
<!-- end verbatim block -->
That is, <code>integrator</code> must be an instance of some class, or a
module, such that the syntax <code>integrator.integrate(myfunc)</code>
corresponds to a function call, but nothing more (like having a
particular type) is demanded.

<p>
This Python code will run as long as <code>integrator</code> has a method
<code>integrate</code> taking one argument. In other languages, the function
arguments are specified with a type, say in Java we would write

<p>
<!-- begin verbatim block  ccq-->
<pre><code>void do_math(double arg1, int arg2, Simpson integrator)
</code></pre>
<!-- end verbatim block -->
A compiler will examine all calls to <code>do_math</code> and control that the
arguments are of the right type.  Instead of specifying the
integration method to be of type <code>Simpson</code>, one can in Java and other
object-oriented languages specify <code>integrator</code> to be of the superclass
type <code>Integrator</code>:

<p>
<!-- begin verbatim block  ccq-->
<pre><code>void do_math(double arg1, int arg2, Integrator integrator)
</code></pre>
<!-- end verbatim block -->
Now it is allowed to pass an object of any subclass type of
<code>Integrator</code> as the third argument. That is, this method works with
<code>integrator</code> of type <code>Midpoint</code>, <code>Trapezoidal</code>, <code>Simpson</code>, etc., not
just one of them.  Class hierarchies and object-oriented programming
are therefore important means for parameterizing away types in
languages like Java, C++, and C#.  We do not need to parameterize
types in Python, since arguments are not declared with a fixed
type. Object-oriented programming is hence not so technically
important in Python as in other languages for providing increased
flexibility in programs.

<p>
Is there then any use for object-oriented programming beyond
inheritance? The answer is yes! For many code developers
object-oriented programming is not just a technical way of sharing
code, but it is more a way of modeling the world, and understanding
the problem that the program is supposed to solve.  In mathematical
applications we already have objects, defined by the mathematics, and
standard programming concepts such as functions, arrays, lists, and
loops are often sufficient for solving simpler problems.  In the
non-mathematical world the concept of objects is very useful because
it helps to structure the problem to be solved.  As an example, think
of the phone book and message list software in a mobile phone.  Class
<code>Person</code> can be introduced to hold the data about one person in the
phone book, while class <code>Message</code> can hold data related to an SMS
message. Clearly, we need to know who sent a message so a <code>Message</code>
object will have an associated <code>Person</code> object, or just a phone number
if the number is not registered in the phone book.  Classes help to
structure both the problem and the program.  The impact of classes and
object-oriented programming on modern software development can hardly
be exaggerated.

<p>
A good, real-world, pedagogical example on inheritance is the class
hierarchy for numerical methods for ordinary differential equations
described in the document <a href="http://tcse6.on.net/ode2" target="_self">Programming of ordinary
differential equations</a>
<a href="._oo-solarized006.html#Langtangen_TCSE6_ode2">[4]</a>.

<p>
<p>
<!-- begin bottom navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._oo-solarized002.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._oo-solarized004.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end bottom navigation -->
</p>

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

