<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Object-oriented programming">
<meta name="keywords" content="object-based programming,class hierarchy,class relationship superclass,class relationship derived class,class relationship inheritance,derived class,parent class,base class,superclass,subclass,class relationship subclass,Online Python Tutor,check an object's type,is-a class relationship,has-a class relationship,class relationship is-a,class relationship has-a,dynamic binding,factory function,closure,functional programming,Midpoint rule for integration,Trapezoidal rule for integration,overloading (of methods),polymorphism,Midpoint rule for integration,Trapezoidal rule for integration,tree data structure,recursive function calls,multiple inheritance,convergence rate,Trapezoidal rule for integration,Midpoint rule for integration,object-oriented programming">

<title>Object-oriented programming</title>


<link href="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
code { padding: 0px; background-color: inherit; }
pre {
  border: 0pt solid #93a1a1;
  box-shadow: none;
}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [('Table of contents',
               1,
               'table_of_contents',
               'table_of_contents'),
              ('Inheritance and class hierarchies',
               1,
               'sec:oo:inheritance',
               'sec:oo:inheritance'),
              ('A class for straight lines', 2, 'sec:oo:Line', 'sec:oo:Line'),
              ('A first try on a class for parabolas',
               2,
               'sec:oo:Parabola1',
               'sec:oo:Parabola1'),
              ('A class for parabolas using inheritance', 2, None, '___sec3'),
              ('Program flow', 3, None, '___sec4'),
              ('Checking the class type', 2, None, '___sec5'),
              ('Attribute vs inheritance: has-a vs is-a relationship',
               2,
               None,
               '___sec6'),
              ('Superclass for defining an interface',
               2,
               'sec:oo:Func',
               'sec:oo:Func'),
              ('Class hierarchy for numerical differentiation',
               1,
               'sec:oo:numdiff',
               'sec:oo:numdiff'),
              ('Classes for differentiation',
               2,
               'sec:oo:Diff',
               'sec:oo:Diff'),
              ('Computer science remark', 3, None, '___sec10'),
              ('Verification', 2, None, '___sec11'),
              ('A flexible main program', 2, None, '___sec12'),
              ('Extensions', 2, 'sec:oo:Diff:extend', 'sec:oo:Diff:extend'),
              ('Application', 3, None, '___sec14'),
              ('Alternative implementation via functions',
               2,
               'sec:oo:diff:alt:func',
               'sec:oo:diff:alt:func'),
              ('Alternative implementation via functional programming',
               2,
               'sec:oo:diff:alt:FP',
               'sec:oo:diff:alt:FP'),
              ('Alternative implementation via a single class',
               2,
               'sec:oo:diff:oneclass',
               'sec:oo:diff:oneclass'),
              ('Remark', 3, None, '___sec18'),
              ('Class hierarchy for numerical integration',
               1,
               'sec:oo:int',
               'sec:oo:int'),
              ('Numerical integration methods',
               2,
               'sec:oo:int:methods',
               'sec:oo:int:methods'),
              ('Classes for integration',
               2,
               'sec:oo:Integrator',
               'sec:oo:Integrator'),
              ('Verification', 2, None, '___sec22'),
              ('Using the class hierarchy', 2, None, '___sec23'),
              ('About object-oriented programming', 2, None, '___sec24'),
              ('Class hierarchy for making drawings',
               1,
               'sec:oo:shapes',
               'sec:oo:shapes'),
              ('A first glimpse of Pysketcher', 1, None, '___sec26'),
              ('Basic construction of sketches', 2, None, '___sec27'),
              ('Basic drawing', 3, None, '___sec28'),
              ('Groups of objects', 3, None, '___sec29'),
              ('Changing line styles and colors', 3, None, '___sec30'),
              ('The figure composition as an object hierarchy',
               3,
               None,
               '___sec31'),
              ('Animation: translating the vehicle', 3, None, '___sec32'),
              ('Animation: rolling the wheels',
               3,
               'sketcher:vehicle1:anim',
               'sketcher:vehicle1:anim'),
              ('Inner workings of the Pysketcher tool', 1, None, '___sec34'),
              ('Example of classes for geometric objects',
               2,
               None,
               '___sec35'),
              ('Simple geometric objects', 3, None, '___sec36'),
              ('Class curve', 3, None, '___sec37'),
              ('Compound geometric objects', 3, None, '___sec38'),
              ('Adding functionality via recursion', 2, None, '___sec39'),
              ('Basic principles of recursion', 3, None, '___sec40'),
              ('Explaining recursion', 3, None, '___sec41'),
              ('Scaling, translating, and rotating a figure',
               2,
               'sketcher:scaling',
               'sketcher:scaling'),
              ('Scaling', 3, None, '___sec43'),
              ('Translation', 3, None, '___sec44'),
              ('Rotation', 3, None, '___sec45'),
              ('Classes for DNA analysis', 1, 'bioinf:oo', 'bioinf:oo'),
              ('Class for regions', 2, None, '___sec47'),
              ('Class for genes', 2, None, '___sec48'),
              ('Basic features of class gene', 3, None, '___sec49'),
              ('Flexible constructor', 3, None, '___sec50'),
              ('Other methods', 3, None, '___sec51'),
              ('Subclasses', 2, None, '___sec52'),
              ('Summary', 1, None, '___sec53'),
              ('Chapter topics', 2, None, '___sec54'),
              ('Subclass example', 3, None, '___sec55'),
              ('Subclassing in general', 3, None, '___sec56'),
              ('Terminology', 3, None, '___sec57'),
              ('Example: Input data reader',
               2,
               'sec:oo:ReadInput',
               'sec:oo:ReadInput'),
              ('Problem', 3, None, '___sec59'),
              ('Solution', 3, None, '___sec60'),
              ('Prompting the user', 3, None, '___sec61'),
              ('Reading from file', 3, None, '___sec62'),
              ('Reading from the command line', 3, None, '___sec63'),
              ('Reading from a gui', 3, None, '___sec64'),
              ('More flexibility in the superclass', 3, None, '___sec65'),
              ('Demonstrating the tool', 3, None, '___sec66'),
              ('Exercises', 1, None, '___sec67'),
              ('Exercise 1: Demonstrate the magic of inheritance',
               2,
               'sec:oo:ex1',
               'sec:oo:ex1'),
              ('Exercise 2: Make polynomial subclasses of parabolas',
               2,
               'sec:oo:ex2',
               'sec:oo:ex2'),
              ('Remarks', 3, None, '___sec70'),
              ('Exercise 3: Implement a class for a function as a subclass',
               2,
               'sec:oo:ex3',
               'sec:oo:ex3'),
              ('Exercise 4: Create an alternative class hierarchy for polynomials',
               2,
               'sec:oo:ex5',
               'sec:oo:ex5'),
              ('Exercise 5: Make circle a subclass of an ellipse',
               2,
               'sec:oo:ex5b',
               'sec:oo:ex5b'),
              ('Exercise 6: Make super- and subclass for a point',
               2,
               'sec:oo:ex17',
               'sec:oo:ex17'),
              ('Exercise 7: Modify a function class by subclassing',
               2,
               'sec:oo:ex7',
               'sec:oo:ex7'),
              ('Exercise 8: Explore the accuracy of difference formulas',
               2,
               'sec:oo:ex18',
               'sec:oo:ex18'),
              ('Exercise 9: Implement a subclass',
               2,
               'sec:oo:ex15b',
               'sec:oo:ex15b'),
              ('Exercise 10: Make classes for numerical differentiation',
               2,
               'sec:oo:ex33',
               'sec:oo:ex33'),
              ('Exercise 11: Implement a new subclass for differentiation',
               2,
               'sec:oo:ex31',
               'sec:oo:ex31'),
              ('Exercise 12: Understand if a class can be used recursively',
               2,
               'sec:oo:ex14',
               'sec:oo:ex14'),
              ('Exercise 13: Represent people by a class hierarchy',
               2,
               'sec:oo:ex4',
               'sec:oo:ex4'),
              ('Remark', 3, None, '___sec82'),
              ('Exercise 14: Add a new class in a class hierarchy',
               2,
               'sec:oo:ex15',
               'sec:oo:ex15'),
              ('Exercise 15: Compute convergence rates of numerical integration methods',
               2,
               'sec:oo:ex16',
               'sec:oo:ex16'),
              ('Exercise 16: Add common functionality in a class hierarchy',
               2,
               'sec:oo:ex6',
               'sec:oo:ex6'),
              ('Exercise 17: Make a class hierarchy for root finding',
               2,
               'sec:oo:ex41',
               'sec:oo:ex41'),
              ('Exercise 18: Make a calculus calculator class',
               2,
               'sec:plot:ex30',
               'sec:plot:ex30'),
              ('Exercise 19: Compute inverse functions',
               2,
               'sec:plot:ex30b',
               'sec:plot:ex30b'),
              ('Exercises', 1, None, '___sec89'),
              ('Exercise 20: Make line drawing of a person; program',
               2,
               'pysketcher:exer:person:prog',
               'pysketcher:exer:person:prog'),
              ('Exercise 21: Make line drawing of a person; class',
               2,
               'pysketcher:exer:person:class',
               'pysketcher:exer:person:class'),
              ('Exercise 22: Animate a person with waving hands',
               2,
               'pysketcher:exer:person:anim',
               'pysketcher:exer:person:anim'),
              ('References', 1, None, '___sec93')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\tp}{\thinspace .}
$$




    
<a name="part0001"></a>
<p>
<!-- begin top navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._oo-solarized000.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._oo-solarized002.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end top navigation -->
</p>

<p>
<!-- !split -->
<p style="font-size:80%">This chapter is taken from the book <a href="http://www.springer.com/gp/book/9783662498866">A Primer on Scientific Programming with Python</a> by H. P. Langtangen, 5th edition, Springer, 2016.</p>

<h1 id="sec:oo:inheritance">Inheritance and class hierarchies</h1>

<p>
Most of this document tells you how to put related classes together
in families such that the family can be viewed as one unit.  This idea
helps to hide details in a program, and makes it easier to modify or
extend the program.

<p>
A family of classes is known as a <em>class hierarchy</em>.  As in a
biological family, there are parent classes and child classes.  Child
classes can <em>inherit</em> data and methods from parent classes, they can
modify these data and methods, and they can add their own data and
methods. This means that if we have a class with some functionality,
we can extend this class by creating a child class and simply add the
functionality we need. The original class is still available and the
separate child class is small, since it does not need to repeat the
code in the parent class.

<p>
The magic of object-oriented programming is that other parts of the
code do not need to distinguish whether an object is the parent or the
child - all generations in a family tree can be treated as a unified
object. In other words, one piece of code can work with all members in
a class family or hierarchy.  This principle has revolutionized the
development of large computer systems. As an illustration, two of the
most widely used computer languages today are Java and <code>C#</code>, and both
of them force programs to be written in an object-oriented style.

<p>
The concepts of classes and object-oriented programming first appeared
in the Simula programming language in the 1960s. Simula was invented
by the Norwegian computer scientists Ole-Johan Dahl and Kristen
Nygaard, and the impact of the language is particularly evident in
C++, Java, and C#, three of the most dominating programming languages
in the world today.  The invention of object-oriented programming was
a remarkable achievement, and the professors Dahl and Nygaard received
two very prestigious prizes: the von Neumann medal and the Turing
prize (popularly known as the Nobel prize of computer science).

<p>
A parent class is usually called <em>base class</em> or <em>superclass</em>, while
the child class is known as a <em>subclass</em> or <em>derived class</em>.  We shall
use the terms superclass and subclass from now on.

<h2 id="sec:oo:Line">A class for straight lines</h2>

<p>
Assume that we have written a class for straight lines, \( y=c_0 + c_1x \):

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class Line(object):
    def __init__(self, c0, c1):
        self.c0 = c0
        self.c1 = c1

    def __call__(self, x):
        return self.c0 + self.c1*x

    def table(self, L, R, n):
        &quot;&quot;&quot;Return a table with n points for L &lt;= x &lt;= R.&quot;&quot;&quot;
        s = ''
        import numpy as np
        for x in np.linspace(L, R, n):
            y = self(x)
            s += '%12g %12g\n' % (x, y)
        return s
</code></pre>
<!-- end verbatim block -->
The constructor <code>__init__</code> initializes the coefficients \( c_0 \) and
\( c_1 \) in the expression for the straight line: \( y=c_0 + c_1x \).  The
call operator <code>__call__</code> evaluates the function \( c_1x+c_0 \), while the
<code>table</code> method samples the function at <code>n</code> points and creates a table
of \( x \) and \( y \) values.

<h2 id="sec:oo:Parabola1">A first try on a class for parabolas</h2>

<p>
A parabola \( y=c_0 + c_1x + c_2x^2 \) contains a straight line as a
special case (\( c_2=0 \)). A class for parabolas will therefore be
similar to a class for straight lines. All we have do to is to add the
new term \( c_2x^2 \) in the function evaluation and store \( c_2 \) in the
constructor:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class Parabola(object):
    def __init__(self, c0, c1, c2):
        self.c0 = c0
        self.c1 = c1
        self.c2 = c2

    def __call__(self, x):
        return self.c2*x**2 + self.c1*x + self.c0

    def table(self, L, R, n):
        &quot;&quot;&quot;Return a table with n points for L &lt;= x &lt;= R.&quot;&quot;&quot;
        s = ''
        import numpy as np
        for x in np.linspace(L, R, n):
            y = self(x)
            s += '%12g %12g\n' % (x, y)
        return s
</code></pre>
<!-- end verbatim block -->
Observe that we can copy the <code>table</code> method from class <code>Line</code>
without any modifications.

<h2 id="___sec3">A class for parabolas using inheritance </h2>

<p>
Python and other languages that support object-oriented programming
have a special construct, so that class <code>Parabola</code> does not need
to repeat the code that we have already written in class <code>Line</code>.
We can specify that class <code>Parabola</code> <em>inherits</em> all code from class
<code>Line</code> by adding <code>(Line)</code> in the class headline:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class Parabola(Line):
</code></pre>
<!-- end verbatim block -->
Class <code>Parabola</code> now automatically gets all the code from class
<code>Line</code>. <a href="._oo-solarized006.html#sec:oo:ex1">Exercise 1: Demonstrate the magic of inheritance</a> asks you to explicitly demonstrate
the validity of this assertion.  We say that class <code>Parabola</code> is
<em>derived</em> from class <code>Line</code>, or equivalently, that class <code>Parabola</code> is
a subclass of its superclass <code>Line</code>.

<p>
Now, class <code>Parabola</code> should not be identical to class <code>Line</code>: it
needs to add data in the constructor (for the new term) and to modify
the call operator (because of the new term), but the <code>table</code> method
can be inherited as it is.  If we implement the constructor and the
call operator in class <code>Parabola</code>, these will <em>override</em> the inherited
versions from class <code>Line</code>. If we do not implement a <code>table</code> method,
the one inherited from class <code>Line</code> is available as if it were coded
visibly in class <code>Parabola</code>.

<p>
Class <code>Parabola</code> must first have the statements from the class <code>Line</code>
methods <code>__call__</code> and <code>__init__</code>, and then add extra code in these
methods. An important principle in computer programming is to avoid
repeating code. We should therefore call up functionality in class
<code>Line</code> instead of copying statements from class <code>Line</code> methods to
<code>Parabola</code> methods.  Any method in the superclass <code>Line</code> can be called
using the syntax

<p>
<!-- begin verbatim block  pycod-->
<pre><code>Line.methodname(self, arg1, arg2, ...)
# or
super(Parabola, self).methodname(arg1, arg2, ...)
</code></pre>
<!-- end verbatim block -->
The latter construction only works if the super class is derived from
Python's general super class <code>object</code> (i.e., class <code>Line</code> must be a
new-style class).

<p>
Let us now show how to write class <code>Parabola</code> as a subclass of class
<code>Line</code>, and implement just the new additional code that we need and
that is not already written in the superclass:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class Parabola(Line):
    def __init__(self, c0, c1, c2):
        Line.__init__(self, c0, c1)  # let Line store c0 and c1
        self.c2 = c2

    def __call__(self, x):
        return Line.__call__(self, x) + self.c2*x**2
</code></pre>
<!-- end verbatim block -->
This short implementation of class <code>Parabola</code> provides exactly the
same functionality as the first version of class <code>Parabola</code> that
we showed in the section <a href="#sec:oo:Parabola1">A first try on a class for parabolas</a> and that did not inherit
from class <code>Line</code>. Figure <a href="#fig:oo:Parabola:fig">1</a> shows the
class hierarchy in UML fashion. The arrow from one class to another
indicates inheritance.

<p>
<center> <!-- figure label: --> <div id="fig:oo:Parabola:fig"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 1:  UML diagram for the class hierarchy with superclass <code>Line</code>   and subclass <code>Parabola</code>.  <!-- caption label: fig:oo:Parabola:fig --> </p></center>
<p><img src="fig-oo/lumpy_Parabola_hier.png" align="bottom" width=400></p>
</center>

<p>
A quick demo of the <code>Parabola</code> class in a main program,

<p>
<!-- begin verbatim block  pycod-->
<pre><code>p = Parabola(1, -2, 2)
p1 = p(x=2.5)
print p1
print p.table(0, 1, 3)
</code></pre>
<!-- end verbatim block -->
gives this output:

<p>
<!-- begin verbatim block  ccq-->
<pre><code>8.5
           0            1
         0.5          0.5
           1            1
</code></pre>
<!-- end verbatim block -->

<h3 id="___sec4">Program flow </h3>

<p>
The program flow can be somewhat complicated when we work with class
hierarchies. Consider the code segment

<p>
<!-- begin verbatim block  pycod-->
<pre><code>p = Parabola(1, -1, 2)
p1 = p(x=2.5)
</code></pre>
<!-- end verbatim block -->
Let us explain the program flow in detail for these two statements.
As always, you can monitor the program flow in a debugger as explained
in the document <a href="http://hplgit.github.io/primer.html/doc/pub/debug" target="_self">Debugging in Python</a> <a href="._oo-solarized006.html#Langtangen_TCSE6_debug">[1]</a> or you can
invoke the very illustrative <a href="http://www.pythontutor.com/" target="_self">Online Python Tutor</a>.

<p>
Calling <code>Parabola(1, -1, 2)</code> leads to a call to the constructor method
<code>__init__</code>, where the arguments <code>c0</code>, <code>c1</code>, and <code>c2</code> in this case are
<code>int</code> objects with values 1, -1, and 2.  The <code>self</code> argument in the
constructor is the object that will be returned and referred to by the
variable <code>p</code>.  Inside the constructor in class <code>Parabola</code> we call the
constructor in class <code>Line</code>. In this latter method, we create two
data attributes in the <code>self</code> object. Printing out <code>dir(self)</code> will
explicitly demonstrate what <code>self</code> contains so far in the construction
process.  Back in class <code>Parabola</code>'s constructor, we add a third
attribute <code>c2</code> to the same <code>self</code> object.  Then the <code>self</code> object is
invisibly returned and referred to by <code>p</code>.

<p>
The other statement, <code>p1 = p(x=2.5)</code>, has a similar program
flow. First we enter the <code>p.__call__</code> method with <code>self</code> as <code>p</code> and
<code>x</code> as a <code>float</code> object with value 2.5.  The program flow jumps to the
<code>__call__</code> method in class <code>Line</code> for evaluating the linear part
\( c_1x+c_0 \) of the expression for the parabola, and then the flow jumps
back to the <code>__call__</code> method in class <code>Parabola</code> where we add the new
quadratic term.

<h2 id="___sec5">Checking the class type </h2>

<p>
Python has the function <code>isinstance(i,t)</code> for checking if an
instance <code>i</code> is of class type <code>t</code>:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; l = Line(-1, 1)
&gt;&gt;&gt; isinstance(l, Line)
True
&gt;&gt;&gt; isinstance(l, Parabola)
False
</code></pre>
<!-- end verbatim block -->
A <code>Line</code> is not a <code>Parabola</code>, but is a <code>Parabola</code> a
<code>Line</code>?

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; p = Parabola(-1, 0, 10)
&gt;&gt;&gt; isinstance(p, Parabola)
True
&gt;&gt;&gt; isinstance(p, Line)
True
</code></pre>
<!-- end verbatim block -->
Yes, from a class hierarchy perspective, a <code>Parabola</code>
instance is regarded as a
<code>Line</code> instance too, since it contains everything that a <code>Line</code>
instance contains.

<p>
Every instance has an attribute <code>__class__</code> that holds the
type of class:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; p.__class__
&lt;class __main__.Parabola at 0xb68f108c&gt;
&gt;&gt;&gt; p.__class__ == Parabola
True
&gt;&gt;&gt; p.__class__.__name__   # string version of the class name
'Parabola'
</code></pre>
<!-- end verbatim block -->
Note that <code>p.__class__</code> is a <code>class</code> object (or class
definition one may say), while <code>p.__class__.__name__</code>
is a string.
These two variables can be used as an alternative test for
the class type:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>if p.__class__.__name__ == 'Parabola':
    ...
# or
if p.__class__ == Parabola:
    ...
</code></pre>
<!-- end verbatim block -->
However, <code>isinstance(p, Parabola)</code> is the recommended programming style
for checking the type of an object.

<p>
A function
<code>issubclass(c1, c2)</code> tests if class <code>c1</code> is a subclass of class
<code>c2</code>, e.g.,

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; issubclass(Parabola, Line)
True
&gt;&gt;&gt; issubclass(Line, Parabola)
False
</code></pre>
<!-- end verbatim block -->
The superclasses of a class are stored as a tuple in the
<code>__bases__</code> attribute of the class object:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; p.__class__.__bases__
(&lt;class __main__.Line at 0xb7c5d2fc&gt;,)
&gt;&gt;&gt; p.__class__.__bases__[0].__name__  # extract name as string
'Line'
</code></pre>
<!-- end verbatim block -->

<h2 id="___sec6">Attribute vs inheritance: has-a vs is-a relationship </h2>

<p>
Instead of letting class <code>Parabola</code>
inherit from a class <code>Line</code>, we may let it <em>contain</em> a
class <code>Line</code> instance as a data attribute:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class Parabola(object):
    def __init__(self, c0, c1, c2):
        self.line = Line(c0, c1)  # let Line store c0 and c1
        self.c2 = c2

    def __call__(self, x):
        return self.line(x) + self.c2*x**2
</code></pre>
<!-- end verbatim block -->
Whether to use inheritance or an attribute depends on the problem
being solved.

<p>
If it is natural to say that class <code>Parabola</code> <em>is</em> a <code>Line</code> object, we
say that <code>Parabola</code> has an <em>is-a relationship</em> with class
<code>Line</code>. Alternatively, if it is natural to think that class <code>Parabola</code>
<em>has a</em> <code>Line</code> object, we speak about a <em>has-a relationship</em> with
class <code>Line</code>.  In the present example, we may argue that technically
the expression for the parabola <em>is a</em> straight line plus another term
and hence claim an is-a relationship, but we can also view a parabola
as a quantity that <em>has a</em> line plus an extra term, which makes the
<em>has-a</em> relationship relevant.

<p>
From a mathematical point of view, many will say that a parabola <em>is
not</em> a line, but that a line is a special case of a parabola.
Adopting this reasoning reverses the dependency of the classes: now it
is more natural to let <code>Line</code> is a subclass of <code>Parabola</code> (<code>Line</code> <em>is
a</em> <code>Parabola</code>).  This easy, and all we have to do is

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class Parabola(object):
    def __init__(self, c0, c1, c2):
        self.c0, self.c1, self.c2 = c0, c2, c2

    def __call__(self, x):
        return self.c0 + self.c1*x + self.c2*x**2

    def table(self, L, R, n):  # implemented as shown above

class Line(Parabola):
    def __init__(self, c0, c1):
        Parabola.__init__(self, c0, c1, 0)
</code></pre>
<!-- end verbatim block -->
The inherited <code>__call__</code> method from class <code>Parabola</code> will
work since the <code>c2</code> coefficient is zero.
<a href="._oo-solarized006.html#sec:oo:ex5">Exercise 4: Create an alternative class hierarchy for polynomials</a> suggests deriving <code>Parabola</code> from
a general class <code>Polynomial</code> and asks you to discuss the alternative class
designs.

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Extension and restriction of a superclass.</b>
<p>
In the example where <code>Parabola</code> as a subclass of <code>Line</code>, we
used inheritance to <em>extend</em> the functionality of the superclass.
The case where <code>Line</code> is a subclass of <code>Parabola</code> is an example on
<em>restricting</em> the superclass functionality in a subclass.
</div>


<p>
How classes depend on each other is influenced by two factors: sharing
of code and logical relations. From a sharing of code perspective,
many will say that class <code>Parabola</code> is naturally a subclass of <code>Line</code>,
the former adds code to the latter.  On the other hand, <code>Line</code> is
naturally a subclass of <code>Parabola</code> from the logical relations in
mathematics.  Computational efficiency is a third perspective when we
implement mathematics.  When <code>Line</code> is a subclass of <code>Parabola</code> we
always evaluate the \( c_2x^2 \) term in the parabola although this term
is zero.  Nevertheless, when <code>Parabola</code> is a subclass of <code>Line</code>, we
call <code>Line.__call__</code> to evaluate the linear part of the second-degree
polynomial, and this call is costly in Python.  From a pure efficiency
point of view, we would reprogram the linear part in
<code>Parabola.__call__</code> (which is against the programming habit we have
been arguing for!). This little discussion here highlights the many
different considerations that come into play when establishing class
relations.

<h2 id="sec:oo:Func">Superclass for defining an interface</h2>

<p>
As another example of class hierarchies, we now want to represent
functions by classes, as described in the document
<a href="http://hplgit.github.io/primer.html/doc/pub/class" target="_self">Introduction to classes in Python</a>
<a href="._oo-solarized006.html#Langtangen_TCSE6_class">[2]</a>, but in addition to the <code>__call__</code>
method, we also want to provide methods for the first and second
derivative. The class can be sketched as

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class SomeFunc(object):
    def __init__(self, parameter1, parameter2, ...)
        # Store parameters
    def __call__(self, x):
        # Evaluate function
    def df(self, x):
        # Evaluate the first derivative
    def ddf(self, x):
        # Evaluate the second derivative
</code></pre>
<!-- end verbatim block -->
For a given function, the analytical expressions for first and second
derivative must be manually coded. However, we could think of
inheriting general functions for computing these derivatives
numerically, such that the only thing we must always implement is the
function itself. To realize this idea, we create a superclass

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class FuncWithDerivatives(object):
    def __init__(self, h=1.0E-5):
        self.h = h  # spacing for numerical derivatives

    def __call__(self, x):
        raise NotImplementedError\ 
        ('___call__ missing in class %s' % self.__class__.__name__)

    def df(self, x):
        &quot;&quot;&quot;Return the 1st derivative of self.f.&quot;&quot;&quot;
        # Compute first derivative by a finite difference
        h = self.h
        return (self(x+h) - self(x-h))/(2.0*h)

    def ddf(self, x):
        &quot;&quot;&quot;Return the 2nd derivative of self.f.&quot;&quot;&quot;
        # Compute second derivative by a finite difference:
        h = self.h
        return (self(x+h) - 2*self(x) + self(x-h))/(float(h)**2)
</code></pre>
<!-- end verbatim block -->
This class is only meant as a superclass of other classes.
For a particular function, say \( f(x)=\cos (ax)+x^3 \), we represent it by
a subclass:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class MyFunc(FuncWithDerivatives):
    def __init__(self, a):
        self.a = a

    def __call__(self, x):
        return cos(self.a*x) + x**3

    def df(self, x):
        a = self.a
        return -a*sin(a*x) + 3*x**2

    def ddf(self, x):
        a = self.a
        return -a*a*cos(a*x) + 6*x
</code></pre>
<!-- end verbatim block -->
The superclass constructor is never called, hence <code>h</code> is never
initialized, and there are no possibilities for using numerical
approximations via the superclass methods
<code>df</code> and <code>ddf</code>.
Instead, we override all the inherited methods and implement our own
versions.

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Tip.</b>
<p>
Many think it is a good programming style
to always call the superclass constructor in a subclass constructor,
even in simple classes where
we do not need the functionality of the superclass constructor.
</div>


<p>
For a more complicated function, e.g., \( f(x)=\ln |p\tanh(qx\cos rx)| \),
we may skip the analytical derivation of the derivatives, and just code
\( f(x) \) and rely on the difference approximations inherited from the
superclass to compute the derivatives:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class MyComplicatedFunc(FuncWithDerivatives):
    def __init__(self, p, q, r, h=1.0E-5):
        FuncWithDerivatives.__init__(self, h)
        self.p, self.q, self.r = p, q, r

    def __call__(self, x):
        return log(abs(self.p*tanh(self.q*x*cos(self.r*x))))
</code></pre>
<!-- end verbatim block -->
That's it! We are now ready to use this class:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; f = MyComplicatedFunc(1, 1, 1)
&gt;&gt;&gt; x = pi/2
&gt;&gt;&gt; f(x)
-36.880306514638988
&gt;&gt;&gt; f.df(x)
-60.593693618216086
&gt;&gt;&gt; f.ddf(x)
3.3217246931444789e+19
</code></pre>
<!-- end verbatim block -->
Class <code>MyComplicatedFunc</code> inherits the <code>df</code> and <code>ddf</code> methods from the
superclass <code>FuncWithDerivatives</code>. These methods compute the first and
second derivatives approximately, provided that we have defined a
<code>__call__</code> method. If we fail to define this method, we will inherit
<code>__call__</code> from the superclass, which just raises an exception, saying
that the method is not properly implemented in class
<code>MyComplicatedFunc</code>.

<p>
The important message in this subsection is that we introduced a super
class to mainly define an <em>interface</em>, i.e., the operations (in terms
of methods) that one can do with a class in this class hierarchy. The
superclass itself is of no direct use, since it does not implement any
function evaluation in the <code>__call__</code> method. However, it stores a
variable common to all subclasses (<code>h</code>), and it implements general
methods <code>df</code> and <code>ddf</code> that any subclass can make use of.  A specific
mathematical function must be represented as a subclass, where the
programmer can decide whether analytical derivatives are to be used,
or if the more lazy approach of inheriting general functionality (<code>df</code>
and <code>ddf</code>) for computing numerical derivatives is satisfactory.

<p>
In object-oriented programming, the superclass very often defines an
interface, and instances of the superclass have no applications on
their own - only instances of subclasses can do anything useful.

<p>
To digest the present material on inheritance, we recommend doing <a href="._oo-solarized006.html#sec:oo:ex1">Exercise 1: Demonstrate the magic of inheritance</a>-<a href="._oo-solarized006.html#sec:oo:ex5">Exercise 4: Create an alternative class hierarchy for polynomials</a> before reading the next section.

<p>
<p>
<!-- begin bottom navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._oo-solarized000.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._oo-solarized002.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end bottom navigation -->
</p>

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

