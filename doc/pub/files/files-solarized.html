<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Files, strings, and dictionaries">
<meta name="keywords" content="dictionary,keys (dictionaries),immutable objects,mutable objects,dictionary comprehensions,nested dictionaries,dictionary nested,date conversion,plotting data vs date,string slicing,slicing,substrings,string substrings,string searching,string substitution,substitution (in text),string splitting,string case change,string testing for number,whitespace,blank lines in files,string stripping leading/trailing blanks,string joining list elements,frequency matrix,dictionary,dictionary functionality">

<title>Files, strings, and dictionaries</title>


<link href="https://raw.githubusercontent.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="http://www.peterhaschke.com/assets/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */

div { text-align: justify; text-justify: inter-word; }
</style>

</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [(u' Dictionaries ', 1, u'sec:files:dicts', u'sec:files:dicts'),
              (u' Making dictionaries ', 2, None, '___sec1'),
              (u' Dictionary operations ', 2, None, '___sec2'),
              (u' Remark ', 3, None, '___sec3'),
              (u' Example: Polynomials as dictionaries ',
               2,
               u'sec:files:poly',
               u'sec:files:poly'),
              (u' Dictionaries with default values and ordering ',
               2,
               u'sec:files:dict:default:order',
               u'sec:files:dict:default:order'),
              (u' Dictionaries with default values ', 3, None, '___sec6'),
              (u' Ordered dictionaries ', 3, None, '___sec7'),
              (u' Example: File data in dictionaries ',
               2,
               u'sec:files:dict:density',
               u'sec:files:dict:density'),
              (u' Problem ', 3, None, '___sec9'),
              (u' Solution ', 3, None, '___sec10'),
              (u' Example: File data in nested dictionaries ',
               2,
               u'sec:files:dictdict',
               u'sec:files:dictdict'),
              (u' Problem ', 3, None, '___sec12'),
              (u' Algorithm ', 3, None, '___sec13'),
              (u' Implementation ', 3, None, '___sec14'),
              (u' Dissection ', 3, None, '___sec15'),
              (u' Example: Reading and plotting data recorded at specific dates ',
               2,
               u'sec:files:stockprices',
               u'sec:files:stockprices'),
              (u' Problem ', 3, None, '___sec17'),
              (u' Solution ', 3, None, '___sec18'),
              (u' Strings ', 1, u'sec:files:str', u'sec:files:str'),
              (u' Common operations on strings ',
               2,
               u'sec:files:stringop',
               u'sec:files:stringop'),
              (u' Substring specification ', 3, None, '___sec21'),
              (u' Searching for substrings ', 3, None, '___sec22'),
              (u' Substitution ', 3, None, '___sec23'),
              (u' String splitting ', 3, None, '___sec24'),
              (u' Upper and lower case ', 3, None, '___sec25'),
              (u' Strings are constant ', 3, None, '___sec26'),
              (u' Strings with digits only ', 3, None, '___sec27'),
              (u' Whitespace ', 3, None, '___sec28'),
              (u' Joining strings ', 3, None, '___sec29'),
              (u' Example: Reading pairs of numbers ',
               2,
               u'sec:files:pairs',
               u'sec:files:pairs'),
              (u' Problem ', 3, None, '___sec31'),
              (u' Solution ', 3, None, '___sec32'),
              (u' Example: Reading coordinates ', 2, None, '___sec33'),
              (u' Problem ', 3, None, '___sec34'),
              (u' Solution 1: substring extraction ', 3, None, '___sec35'),
              (u' Solution 2: string search ', 3, None, '___sec36'),
              (u' Solution 3: string split ', 3, None, '___sec37'),
              (u' Reading data from web pages ',
               1,
               u'sec:files:webtxt',
               u'sec:files:webtxt'),
              (u' About web pages ',
               2,
               u'sec:files:HTMLintro',
               u'sec:files:HTMLintro'),
              (u' How to access web pages in programs ',
               2,
               u'sec:files:urllib',
               u'sec:files:urllib'),
              (u' Alternative 1 ', 3, None, '___sec41'),
              (u' Alternative 2 ', 3, None, '___sec42'),
              (u' Example: Reading pure text files ',
               2,
               u'sec:files:url:weather',
               u'sec:files:url:weather'),
              (u' Example: Extracting data from HTML ',
               2,
               u'sec:files:url:interpret',
               u'sec:files:url:interpret'),
              (u' Handling non-English text ',
               2,
               u'sec:files:encoding',
               u'sec:files:encoding'),
              (u' Reading and writing spreadsheet files ',
               1,
               u'sec:files:csv',
               u'sec:files:csv'),
              (u' CSV files ', 2, None, '___sec47'),
              (u' Reading CSV files ', 2, None, '___sec48'),
              (u' Processing spreadsheet data ', 2, None, '___sec49'),
              (u' Writing CSV files ', 2, None, '___sec50'),
              (u' Remark ', 3, None, '___sec51'),
              (u' Representing number cells with Numerical Python arrays ',
               2,
               None,
               '___sec52'),
              (u' Using more high-level Numerical Python functionality ',
               2,
               None,
               '___sec53'),
              (u' Examples from analyzing DNA ',
               1,
               u'bioinf:DNAanalysis',
               u'bioinf:DNAanalysis'),
              (u' Computing frequencies ',
               2,
               u'bioinf:freqm',
               u'bioinf:freqm'),
              (u' Separate frequency lists ', 3, None, '___sec56'),
              (u' Nested list ', 3, None, '___sec57'),
              (u' Dictionary for more convenient indexing ',
               3,
               None,
               '___sec58'),
              (u' Numerical Python array ', 3, None, '___sec59'),
              (u' Dictionary of lists ', 3, None, '___sec60'),
              (u' Dictionary of dictionaries ', 3, None, '___sec61'),
              (u' Using dictionaries with default values ',
               3,
               None,
               '___sec62'),
              (u' Using arrays and vectorization ', 3, None, '___sec63'),
              (u' Analyzing the frequency matrix ',
               2,
               u'bioinf:freq:analysis',
               u'bioinf:freq:analysis'),
              (u' List of lists frequency matrix ', 3, None, '___sec65'),
              (u' Dict of dicts frequency matrix ', 3, None, '___sec66'),
              (u' Finding base frequencies ',
               2,
               u'bioinf:basefreq',
               u'bioinf:basefreq'),
              (u' Translating genes into proteins ',
               2,
               u'bioinf:gene2protein',
               u'bioinf:gene2protein'),
              (u' Some humans can drink milk, while others cannot ',
               2,
               u'bioinf:lactase:milk',
               u'bioinf:lactase:milk'),
              (u' Summary ', 1, None, '___sec70'),
              (u' Chapter topics ', 2, None, '___sec71'),
              (u' Dictionaries ', 3, None, '___sec72'),
              (u' Strings ', 3, None, '___sec73'),
              (u' Downloading Internet files ', 3, None, '___sec74'),
              (u' Terminology ', 3, None, '___sec75'),
              (u' Example: A file database ',
               2,
               u'sec:files:sumex',
               u'sec:files:sumex'),
              (u' Problem ', 3, None, '___sec77'),
              (u' Solution ', 3, None, '___sec78'),
              (u' Exercises ',
               1,
               u'sec:files:exercises',
               u'sec:files:exercises'),
              (u' Exercise 1: Make a dictionary from a table ',
               2,
               u'sec:files:ex2b:basic',
               u'sec:files:ex2b:basic'),
              (u' Exercise 2: Explore syntax differences: lists vs. dicts ',
               2,
               u'sec:files:ex2',
               u'sec:files:ex2'),
              (u' Exercise 3: Use string operations to improve a program ',
               2,
               u'sec:files:ex17',
               u'sec:files:ex17'),
              (u' Exercise 4: Interpret output from a program ',
               2,
               u'sec:files:ex13',
               u'sec:files:ex13'),
              (u' Exercise 5: Make a dictionary ',
               2,
               u'sec:files:ex2b',
               u'sec:files:ex2b'),
              (u' Exercise 6: Make a nested dictionary ',
               2,
               u'sec:files:ex2c',
               u'sec:files:ex2c'),
              (u' Exercise 7: Make a nested dictionary from a file ',
               2,
               u'sec:files:ex2d:nested',
               u'sec:files:ex2d:nested'),
              (u' Exercise 8: Make a nested dictionary from a file ',
               2,
               u'sec:files:ex2d:nested2',
               u'sec:files:ex2d:nested2'),
              (u' Exercise 9: Compute the area of a triangle ',
               2,
               u'sec:files:ex2d',
               u'sec:files:ex2d'),
              (u' Exercise 10: Compare data structures for polynomials ',
               2,
               u'sec:files:ex16',
               u'sec:files:ex16'),
              (u' Exercise 11: Compute the derivative of a polynomial ',
               2,
               u'sec:files:ex3',
               u'sec:files:ex3'),
              (u' Exercise 12: Specify functions on the command line ',
               2,
               u'sec:basic:ex10',
               u'sec:basic:ex10'),
              (u' Exercise 13: Interpret function specifications ',
               2,
               u'sec:basic:ex10b',
               u'sec:basic:ex10b'),
              (u' Exercise 14: Compare average temperatures in cities ',
               2,
               u'sec:files:ex8',
               u'sec:files:ex8'),
              (u' Exercise 15: Generate an HTML report with figures ',
               2,
               u'sec:files:ex21',
               u'sec:files:ex21'),
              (u' Exercise 16: Allow different types for a function argument ',
               2,
               u'bioinf:exer:freq:fargs',
               u'bioinf:exer:freq:fargs'),
              (u' Exercise 17: Make a function more robust ',
               2,
               u'bioinf:exer:get_base_counts2',
               u'bioinf:exer:get_base_counts2'),
              (u' Exercise 18: Find proportion of bases inside/outside exons ',
               2,
               u'bioinf:exer:Ainsouts:exons',
               u'bioinf:exer:Ainsouts:exons'),
              (u' References ', 1, None, '___sec98')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\tp}{\thinspace .}
$$




    
<a name="part0000"></a>
<p>
<!-- begin top navigation -->
<table style="width: 100%"><tr><td>
</td><td>
</td></tr></table>
<!-- end top navigation -->
</p>

<p>
<!-- ------------------- main content ---------------------- -->



<center><h1>Files, strings, and dictionaries</h1></center>  <!-- document title -->

<p>
<!-- author(s): Hans Petter Langtangen -->

<center>
<b>Hans Petter Langtangen</b> [1, 2]
</center>


<p>
<!-- institution(s) -->

<center>[1] <b>Center for Biomedical Computing, Simula Research Laboratory</b></center>
<center>[2] <b>Department of Informatics, University of Oslo</b></center>
<p>
<center><h4>Aug 31, 2014</h4></center> <!-- date -->

<h2>Table of contents</h2>

<a href="#sec:files:dicts"> Dictionaries </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec1"> Making dictionaries </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec2"> Dictionary operations </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec3"> Remark </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:poly"> Example: Polynomials as dictionaries </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:dict:default:order"> Dictionaries with default values and ordering </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec6"> Dictionaries with default values </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec7"> Ordered dictionaries </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:dict:density"> Example: File data in dictionaries </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec9"> Problem </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec10"> Solution </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:dictdict"> Example: File data in nested dictionaries </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec12"> Problem </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec13"> Algorithm </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec14"> Implementation </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec15"> Dissection </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:stockprices"> Example: Reading and plotting data recorded at specific dates </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec17"> Problem </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec18"> Solution </a><br>
<a href="#sec:files:str"> Strings </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:stringop"> Common operations on strings </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec21"> Substring specification </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec22"> Searching for substrings </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec23"> Substitution </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec24"> String splitting </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec25"> Upper and lower case </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec26"> Strings are constant </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec27"> Strings with digits only </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec28"> Whitespace </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec29"> Joining strings </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:pairs"> Example: Reading pairs of numbers </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec31"> Problem </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec32"> Solution </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec33"> Example: Reading coordinates </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec34"> Problem </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec35"> Solution 1: substring extraction </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec36"> Solution 2: string search </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec37"> Solution 3: string split </a><br>
<a href="#sec:files:webtxt"> Reading data from web pages </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:HTMLintro"> About web pages </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:urllib"> How to access web pages in programs </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec41"> Alternative 1 </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec42"> Alternative 2 </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:url:weather"> Example: Reading pure text files </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:url:interpret"> Example: Extracting data from HTML </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:encoding"> Handling non-English text </a><br>
<a href="#sec:files:csv"> Reading and writing spreadsheet files </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec47"> CSV files </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec48"> Reading CSV files </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec49"> Processing spreadsheet data </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec50"> Writing CSV files </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec51"> Remark </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec52"> Representing number cells with Numerical Python arrays </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec53"> Using more high-level Numerical Python functionality </a><br>
<a href="#bioinf:DNAanalysis"> Examples from analyzing DNA </a><br>
&nbsp; &nbsp; &nbsp; <a href="#bioinf:freqm"> Computing frequencies </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec56"> Separate frequency lists </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec57"> Nested list </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec58"> Dictionary for more convenient indexing </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec59"> Numerical Python array </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec60"> Dictionary of lists </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec61"> Dictionary of dictionaries </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec62"> Using dictionaries with default values </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec63"> Using arrays and vectorization </a><br>
&nbsp; &nbsp; &nbsp; <a href="#bioinf:freq:analysis"> Analyzing the frequency matrix </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec65"> List of lists frequency matrix </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec66"> Dict of dicts frequency matrix </a><br>
&nbsp; &nbsp; &nbsp; <a href="#bioinf:basefreq"> Finding base frequencies </a><br>
&nbsp; &nbsp; &nbsp; <a href="#bioinf:gene2protein"> Translating genes into proteins </a><br>
&nbsp; &nbsp; &nbsp; <a href="#bioinf:lactase:milk"> Some humans can drink milk, while others cannot </a><br>
<a href="#___sec70"> Summary </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec71"> Chapter topics </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec72"> Dictionaries </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec73"> Strings </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec74"> Downloading Internet files </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec75"> Terminology </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:sumex"> Example: A file database </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec77"> Problem </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec78"> Solution </a><br>
<a href="#sec:files:exercises"> Exercises </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:ex2b:basic"> Exercise 1: Make a dictionary from a table </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:ex2"> Exercise 2: Explore syntax differences: lists vs. dicts </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:ex17"> Exercise 3: Use string operations to improve a program </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:ex13"> Exercise 4: Interpret output from a program </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:ex2b"> Exercise 5: Make a dictionary </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:ex2c"> Exercise 6: Make a nested dictionary </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:ex2d:nested"> Exercise 7: Make a nested dictionary from a file </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:ex2d:nested2"> Exercise 8: Make a nested dictionary from a file </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:ex2d"> Exercise 9: Compute the area of a triangle </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:ex16"> Exercise 10: Compare data structures for polynomials </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:ex3"> Exercise 11: Compute the derivative of a polynomial </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:basic:ex10"> Exercise 12: Specify functions on the command line </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:basic:ex10b"> Exercise 13: Interpret function specifications </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:ex8"> Exercise 14: Compare average temperatures in cities </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:ex21"> Exercise 15: Generate an HTML report with figures </a><br>
&nbsp; &nbsp; &nbsp; <a href="#bioinf:exer:freq:fargs"> Exercise 16: Allow different types for a function argument </a><br>
&nbsp; &nbsp; &nbsp; <a href="#bioinf:exer:get_base_counts2"> Exercise 17: Make a function more robust </a><br>
&nbsp; &nbsp; &nbsp; <a href="#bioinf:exer:Ainsouts:exons"> Exercise 18: Find proportion of bases inside/outside exons </a><br>
<a href="#___sec98"> References </a><br>
</p>
<p>
<!-- Externaldocuments: ../formulas/main_formulas, ../looplist/main_looplist, ../funcif/main_funcif, ../input/main_input, ../plot/main_plot, ../class/main_class, ../random/main_random, ../oo/main_oo, ../diffeq/main_diffeq, ../discalc/main_discalc, ../ode1/main_ode1, ../boxspring/main_boxspring, ../ode2/main_ode2, ../debug/main_debug, ../cython/main_cython, ../tech/main_timing, ../tech/main_varargs, ../tech/main_runpy, ../tech/main_ostasks, ../tech/main_accesspy, ../tech/main_nose -->

<p>
<a name="ch:files"></a>

<p>
The present chapter addresses many techniques for interpreting
information in files and storing the data in convenient Python objects
for further data analysis. A particularly handy object for many
purposes is the dictionary, which maps objects to objects, very often
strings to various kinds of data that later can be looked up through
the strings.  The section <a href="#sec:files:dicts">Dictionaries</a> is devoted to dictionaries.

<p>
Information in files often appear as pure text, so to interpret and
extract data from files it is sometimes necessary to carry out
sophisticated operations on the text.  Python strings have many
methods for performing such operations, and the most important
functionality is described in the section <a href="#sec:files:str">Strings</a>.

<p>
The World Wide Web is full of information and scientific data that may
be useful to access from a program. The section <a href="#sec:files:webtxt">Reading data from web pages</a>
tells you how to read web pages from a program and interpret the
contents using string operations.

<p>
Working with data often involves spreadsheets. Python programs not
only need to extract data from spreadsheet files, but it can be
advantageous and convenient to actually to the data processing in a
Python program rather than in a spreadsheet program like Microsoft
Excel or LibreOffice.  The section <a href="#sec:files:csv">Reading and writing spreadsheet files</a> goes through relevant
techniques for reading and writing files in the common CSV format for
spreadsheets.

<p>
The present chapter builds on fundamental programming concepts such as
loops, lists, arrays, <code>if</code> tests, command-line arguments, and curve
plotting.  The folder <a href="http://tinyurl.com/pwyasaa/files" target="_self"><tt>src/files</tt></a> contains all
the relevant program example files and associated data files.

<h1>Dictionaries <a name="sec:files:dicts"></a></h1>

So far in the document we have stored information in various types
of objects, such as numbers, strings, list, and arrays.
A <em>dictionary</em> is a very flexible object for
storing various kind of information, and in particular
when reading files. It is therefore
time to introduce the dictionary type.

<p>
A list is a collection of objects indexed by an integer going from
0 to the number of elements minus one.  Instead of looking up an element
through an integer index, it can be more handy to use a text.
Roughly speaking, a list where the index can be a text is called
a {dictionary} in Python. Other computer languages use other
names for the same thing: HashMap, hash, associative array, or
map.

<h2>Making dictionaries  <a name="___sec1"></a></h2>

Suppose we need to store
the temperatures from three cities: Oslo, London,
and Paris. For this purpose we can use a list,

<p>
<!-- begin verbatim block  pycod-->
<pre><code>temps = [13, 15.4, 17.5]
</code></pre>
<!-- end verbatim block -->
but then we need to remember the sequence of cities, e.g., that index 0
corresponds to Oslo, index 1 to London, and index 2 to Paris.
That is, the London temperature is obtained as <code>temps[1]</code>.
A dictionary with the city name as index is more convenient, because
this allows us to write <code>temps['London']</code> to look up the temperature
in London. Such a dictionary is created by one of the following two statements

<p>
<!-- begin verbatim block  pycod-->
<pre><code>temps = {'Oslo': 13, 'London': 15.4, 'Paris': 17.5}
# or
temps = dict(Oslo=13, London=15.4, Paris=17.5)
</code></pre>
<!-- end verbatim block -->
Additional text-value pairs can be added when desired. We can, for instance,
write

<p>
<!-- begin verbatim block  pycod-->
<pre><code>temps['Madrid'] = 26.0
</code></pre>
<!-- end verbatim block -->
The <code>temps</code> dictionary has now four text-value pairs, and
a <code>print temps</code> yields

<p>
<!-- begin verbatim block  ccq-->
<pre><code>{'Oslo': 13, 'London': 15.4, 'Paris': 17.5, 'Madrid': 26.0}
</code></pre>
<!-- end verbatim block -->

<h2>Dictionary operations  <a name="___sec2"></a></h2>

The string &quot;indices&quot; in a dictionary are called <em>keys</em>.
To loop over the keys in a dictionary <code>d</code>, one writes
<code>for key in d:</code> and works with <code>key</code> and the
corresponding value <code>d[key]</code>
inside the loop. We may apply this technique to write out the
temperatures in the <code>temps</code> dictionary from the previous paragraph:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; for city in temps:
...     print 'The temperature in %s is %g' % (city, temps[city])
...
The temperature in Paris is 17.5
The temperature in Oslo is 13
The temperature in London is 15.4
The temperature in Madrid is 26
</code></pre>
<!-- end verbatim block -->
We can check if a key is present in a dictionary by the syntax
<code>if key in d</code>:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; if 'Berlin' in temps:
...     print 'Berlin:', temps['Berlin']
... else:
...     print 'No temperature data for Berlin'
...
No temperature data for Berlin
</code></pre>
<!-- end verbatim block -->
Writing <code>key in d</code> yields a standard boolean expression, e.g.,

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; 'Oslo' in temps
True
</code></pre>
<!-- end verbatim block -->
The keys and values can be extracted as lists from a dictionary:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; temps.keys()
['Paris', 'Oslo', 'London', 'Madrid']
&gt;&gt;&gt; temps.values()
[17.5, 13, 15.4, 26.0]
</code></pre>
<!-- end verbatim block -->
An important feature of the <code>keys</code> method in dictionaries
is that the order of the returned list of
keys is unpredictable. If you need to traverse the keys in a certain
order, you can sort the keys. A loop over the keys in the
<code>temps</code> dictionary in alphabetic order is written as

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; for city in sorted(temps):
...     print city
...
London
Madrid
Oslo
Paris
</code></pre>
<!-- end verbatim block -->
Python also has a special dictionary type <code>OrderedDict</code>
where the key-value pairs has a specific order, see
the section <a href="#sec:files:dict:default:order">Dictionaries with default values and ordering</a>.

<p>
A key-value pair can be removed by <code>del d[key]</code>:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; del temps['Oslo']
&gt;&gt;&gt; temps
{'Paris': 17.5, 'London': 15.4, 'Madrid': 26.0}
&gt;&gt;&gt; len(temps)  # no of key-value pairs in dictionary
3
</code></pre>
<!-- end verbatim block -->

<p>
Sometimes we need to take a copy of a dictionary:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; temps_copy = temps.copy()
&gt;&gt;&gt; del temps_copy['Paris']   # this does not affect temps
&gt;&gt;&gt; temps_copy
{'London': 15.4, 'Madrid': 26.0}
&gt;&gt;&gt; temps
{'Paris': 17.5, 'London': 15.4, 'Madrid': 26.0}
</code></pre>
<!-- end verbatim block -->
Note that if two variables refer to the same dictionary and we change
the contents of the dictionary through either of the variables,
the change will be seen in both variables:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; t1 = temps
&gt;&gt;&gt; t1['Stockholm'] = 10.0    # change t1
&gt;&gt;&gt; temps                     # temps is also changed
{'Stockholm': 10.0, 'Paris': 17.5, 'London': 15.4, 'Madrid': 26.0}
</code></pre>
<!-- end verbatim block -->
To avoid that <code>temps</code> is affected by adding a new key-value pair
to <code>t1</code>, <code>t1</code> must be a copy of <code>temps</code>.

<h3>Remark  <a name="___sec3"></a></h3>

In Python version 2.x, <code>temps.keys()</code> returns a list object while
in Python version 3.x, <code>temps.keys()</code> only enables iterating over
the keys. To write code that works with both versions one can
use <code>list(temps.keys())</code> in the cases where a list is really
needed and just <code>temps.keys()</code> in a <code>for</code> loop over the keys.

<h2>Example: Polynomials as dictionaries <a name="sec:files:poly"></a></h2>
<a name="sec:files:mutable"></a>

<p>
Python objects that cannot change their contents
are known as <em>immutable</em> data types
and consist of <code>int</code>, <code>float</code>, <code>complex</code>,
<code>str</code>, and <code>tuple</code>. Lists and dictionaries
can change their contents and are called
<em>mutable</em> objects.

<p>
The keys in a dictionary are not restricted to be strings. In fact,
any immutable Python object can be used as key.
For example, if you want a list as key, it cannot be used since lists
can change their contents are hence mutable objects, but a tuple
will do, since it is immutable.

<p>
A common type of key in dictionaries is integers.
Next we shall explain how dictionaries with integers as key provide
a handy way of representing polynomials.
Consider the polynomial

$$
\begin{equation*} p(x)=-1 + x^2 + 3x^7\tp \end{equation*}
$$

The data associated with this polynomial can be viewed as
a set of power-coefficient pairs, in this case the coefficient \( -1 \)
belongs to power 0, the coefficient 1 belongs to power 2, and the
coefficient 3 belongs to power 7. A dictionary can be used to map a
power to a coefficient:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>p = {0: -1, 2: 1, 7: 3}
</code></pre>
<!-- end verbatim block -->
A list can, of course, also be used, but in this case we must
fill in all the zero coefficients too, since the index must match the power:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>p = [-1, 0, 1, 0, 0, 0, 0, 3]
</code></pre>
<!-- end verbatim block -->
The advantage with a dictionary is that we need to store only the
non-zero coefficients. For the polynomial \( 1+x^{100} \) the dictionary
holds two elements while the list holds 101 elements (see <a href="#sec:files:ex16">Exercise 10: Compare data structures for polynomials</a>).

<p>
The following function can be used to evaluate a polynomial represented
as a dictionary:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def poly1(data, x):
    sum = 0.0
    for power in data:
        sum += data[power]*x**power
    return sum
</code></pre>
<!-- end verbatim block -->
The <code>data</code> argument must be a dictionary where <code>data[power]</code>
holds the coefficient associated with the term <code>x**power</code>.
A more compact implementation can make use of Python's <code>sum</code>
function to sum the elements of a list:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def poly1_lc(data, x):
    return sum([data[p]*x**p for p in data])
</code></pre>
<!-- end verbatim block -->
That is, we first make a list of the terms in the polynomial using a
list comprehension, and then we feed this list to the <code>sum</code>
function (we can in fact drop the brackets and storing the list -
<code>sum</code> can directly add the <code>data[p]*x**p</code> terms).
Note that the name <code>sum</code> is different in the two
implementations: in the first, <code>sum</code> is a <code>float</code> object, and in the
second, <code>sum</code> is a function. When we set <code>sum=0.0</code> in the first
implementation, we bind the name <code>sum</code> to a new <code>float</code> object, and
the built-in Python function associated with the name <code>sum</code> is then no
longer accessible inside the <code>poly1</code> function (actually, this is not
strictly correct, because <code>sum</code> is a local variable while the
summation function is associated with a global name <code>sum</code>, which can
always be reached through <code>globals()['sum']</code>).  Outside the function,
nevertheless, <code>sum</code> will be the summation function (unless we have
bound the global name <code>sum</code> to another object somewhere else in the
main program.

<p>
With a list instead of dictionary for representing
the polynomial, a slightly different evaluation function is needed:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def poly2(data, x):
    sum = 0
    for power in range(len(data)):
        sum += data[power]*x**power
    return sum
</code></pre>
<!-- end verbatim block -->
If there are many zeros in the <code>data</code> list, <code>poly2</code> must
perform all the multiplications with the zeros, while <code>poly1</code>
computes with the non-zero coefficients only and is hence more
efficient.

<p>
Another major advantage of using a dictionary to represent a polynomial rather
than a list is that negative powers are easily allowed, e.g.,

<p>
<!-- begin verbatim block  pycod-->
<pre><code>p = {-3: 0.5, 4: 2}
</code></pre>
<!-- end verbatim block -->
can represent \( \frac{1}{2}x^{-3} + 2x^4 \). With a list representation,
negative powers require much more book-keeping. We may, for example,
set

<p>
<!-- begin verbatim block  pycod-->
<pre><code>p = [0.5, 0, 0, 0, 0, 0, 0, 2]
</code></pre>
<!-- end verbatim block -->
and remember that <code>p[i]</code> is the coefficient associated with the
power <code>i-3</code>. In particular, the <code>poly2</code> function will no longer
work for such lists, while the <code>poly1</code> function
works also for dictionaries with negative keys (powers).

<p>
There is a dictionary counterpart to list comprehensions, called
<em>dictionary comprehensions</em>, for quickly generating parameterized
key-value pairs
with a <code>for</code> loop. Such a construction is convenient to generate
the coefficients in a polynomial:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>from math import factorial
d = {k: (-1)**k/factorial(k) for k in range(n+1)}
</code></pre>
<!-- end verbatim block -->
The <code>d</code> dictionary now contains the power-coefficient pairs of the
Taylor polynomial of degree <code>n</code> for \( e^{-x} \).

<p>
You are now encouraged to solve <a href="#sec:files:ex3">Exercise 11: Compute the derivative of a polynomial</a>
to become more familiar with the concept
of dictionaries.

<h2>Dictionaries with default values and ordering <a name="sec:files:dict:default:order"></a></h2>

<h3>Dictionaries with default values  <a name="___sec6"></a></h3>

Looking up keys that are not present in the dictionary requires
special treatment. Consider a polynomial dictionary of the type
introduced in the section <a href="#sec:files:poly">Example: Polynomials as dictionaries</a>. Say we have
\( 2x^{-3} -1.5x^{-1} -2x^2 \) represented by

<p>
<!-- begin verbatim block  pycod-->
<pre><code>p1 = {-3: 2, -1: -1.5, 2: -2}
</code></pre>
<!-- end verbatim block -->
If the code tries to look up <code>p1[1]</code>,
this operation results in a <code>KeyError</code> since <code>1</code> is
not a registered key in <code>p1</code>. We therefore need to do either

<p>
<!-- begin verbatim block  pycod-->
<pre><code>if key in p1:
   value = p1[key]
</code></pre>
<!-- end verbatim block -->
or use

<p>
<!-- begin verbatim block  pycod-->
<pre><code>value = p1.get(key, 0.0)
</code></pre>
<!-- end verbatim block -->
where <code>p1.get</code> returns <code>p1[key]</code> if <code>key in p1</code>
and the default value <code>0.0</code> if not.
A third possibility is to work with a dictionary with a
default value:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>from collections import defaultdict

def polynomial_coeff_default():
    # default value for polynomial dictionary
    return 0.0

p2 = defaultdict(polynomial_coeff_default)
p2.update(p1)
</code></pre>
<!-- end verbatim block -->
The <code>p2</code> can be indexed by any key, and for unregistered keys
the <code>polynomial_coeff_default</code> function is called to provide
a value. This must be a function without arguments. Usually,
a separate function is never made, but either a type is inserted
or a lambda function. The example above is equivalent to

<p>
<!-- begin verbatim block  pycod-->
<pre><code>p2 = defaultdict(lambda: 0.0)
p2 = defaultdict(float)
</code></pre>
<!-- end verbatim block -->
In the latter case <code>float()</code> is called for each unknown key,
and <code>float()</code> returns a <code>float</code> object with zero value.
Now we can look up <code>p2[1]</code> and get the default value 0.
It must be remarked that this key is then a part of the dictionary:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; p2 = defaultdict(lambda: 0.0)
&gt;&gt;&gt; p2.update({2: 8})  # only one key
&gt;&gt;&gt; p2[1]
0.0
&gt;&gt;&gt; p2[0]
0.0
&gt;&gt;&gt; p2[-2]
0.0
&gt;&gt;&gt; print p2
{0: 0.0, 1: 0.0, 2: 8, -2: 0.0}
</code></pre>
<!-- end verbatim block -->

<h3>Ordered dictionaries  <a name="___sec7"></a></h3>

The elements of a dictionary have an undefined order. For example,

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; p1 = {-3: 2, -1: -1.5, 2: -2}
&gt;&gt;&gt; print p1
{2: -2, -3: 2, -1: -1.5}
</code></pre>
<!-- end verbatim block -->
One can control the order my sorting the keys, either by the
default sorting (alphabetically for string keys, ascending order
for number keys):

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; for key in sorted(p1):
...     print key, p1[key]
...
-3 2
-1 -1.5
2 -2
</code></pre>
<!-- end verbatim block -->
The <code>sorted</code> function also accept an optional argument where
the user can supply a function that sorts two keys
(see ref{sec:basic:ex28}).

<p>
However, Python features a dictionary type that preserves the order
of the keys as they were registered:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; from collections import OrderedDict
&gt;&gt;&gt; p2 = OrderedDict({-3: 2, -1: -1.5, 2: -2})
&gt;&gt;&gt; print p2
OrderedDict([(2, -2), (-3, 2), (-1, -1.5)])
&gt;&gt;&gt; p2[-5] = 6
&gt;&gt;&gt; for key in p2:
...     print key, p2[key]
...
2 -2
-3 2
-1 -1.5
-5 6
</code></pre>
<!-- end verbatim block -->

<p>
Here is an example with dates as keys where the order is important.

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; data = {'Jan 2': 33, 'Jan 16': 0.1, 'Feb 2': 2}
&gt;&gt;&gt; for date in data:
...     print date, data[date]
...
Feb 2 2
Jan 2 33
Jan 16 0.1
</code></pre>
<!-- end verbatim block -->
The order of the keys in the loop is not the right registered order,
but this is easily achieved by <code>OrderedDict</code>

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; data = OrderedDict()
&gt;&gt;&gt; data['Jan 2'] = 33
&gt;&gt;&gt; data['Jan 16'] = 0.1
&gt;&gt;&gt; data['Feb 2'] = 2
&gt;&gt;&gt; for date in data:
...     print date, data[date]
...
Jan2 33
Jan 16 0.1
Feb 2 2
</code></pre>
<!-- end verbatim block -->

<p>
A comment on alternative solutions
should be made here. Trying to sort the <code>data</code> dictionary
when it is an ordinary <code>dict</code> object does not help, as by
default the sorting will be alphabetically, resulting in
the sequence <code>'Feb 2'</code>, <code>'Jan 16'</code>, and <code>'Jan 2'</code>.
What does help, however, is to use Python's <code>datetime</code> objects
as keys reflecting dates, since these objects will be correctly
sorted. A <code>datetime</code> object can be created from
a string like <code>'Jan 2, 2017'</code> using a special syntax
(see the module documentation). The relevant code is

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; import datetime
&gt;&gt;&gt; data = {}
&gt;&gt;&gt; d = datetime.datetime.strptime  # short form
&gt;&gt;&gt; data[d('Jan 2, 2017', '%b %d, %Y')] = 33
&gt;&gt;&gt; data[d('Jan 16, 2017', '%b %d, %Y')] = 0.1
&gt;&gt;&gt; data[d('Feb 2, 2017', '%b %d, %Y')] = 2
</code></pre>
<!-- end verbatim block -->
Printing out in sorted order gives the right sequence of dates:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; for date in sorted(data):
...     print date, data[date]
...
2017-01-02 00:00:00 33
2017-01-16 00:00:00 0.1
2017-02-02 00:00:00 2
</code></pre>
<!-- end verbatim block -->
The time is automatically part of a <code>datetime</code> object and set to
<code>00:00:00</code> when not specified.

<p>
While <code>OrderedDict</code> provides a simpler and shorter solution
to keeping keys (here dates) in the right order in a dictionary,
using <code>datetime</code> objects for dates has many advantages: dates can be
formatted and written out in various ways, counting days between two dates is
easy (see the section ref{sec:diffeq:irates}),
calculating the corresponding week number and name of the weekday
is supported, to mention some functionality.

<h2>Example: File data in dictionaries <a name="sec:files:dict:density"></a></h2>

<h3>Problem  <a name="___sec9"></a></h3>

The file <code>files/densities.dat</code> contains a table of densities of
various substances measured in \( \hbox{g}/\hbox{cm}^3 \):

<p>
<!-- begin verbatim block  dat-->
<pre><code>air         0.0012
gasoline    0.67
ice         0.9
pure water  1.0
seawater    1.025
human body  1.03
limestone   2.6
granite     2.7
iron        7.8
silver      10.5
mercury     13.6
gold        18.9
platinium   21.4
Earth mean  5.52
Earth core  13
Moon        3.3
Sun mean    1.4
Sun core    160
proton      2.3E+14
</code></pre>
<!-- end verbatim block -->

<p>
In a program we want to access these density data.
A dictionary
with the name of the substance as key and the corresponding density
as value seems well suited for storing the data.

<h3>Solution  <a name="___sec10"></a></h3>

We can read the <code>densities.dat</code> file line by line, split each line
into words, use a float conversion of the last word as density value,
and the remaining one or two words as key in the dictionary.

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def read_densities(filename):
    infile = open(filename, 'r')
    densities = {}
    for line in infile:
        words = line.split()
        density = float(words[-1])

        if len(words[:-1]) == 2:
            substance = words[0] + ' ' + words[1]
        else:
            substance = words[0]

        densities[substance] = density
    infile.close()
    return densities

densities = read_densities('densities.dat')
</code></pre>
<!-- end verbatim block -->
This code is found in the file
<a href="http://tinyurl.com/pwyasaa/files/density.py" target="_self"><tt>density.py</tt></a>. With
string operations
from the section <a href="#sec:files:stringop">Common operations on strings</a> we can avoid the special treatment
of one or two words in the name of the substance and achieve simpler and
more general code, see <a href="#sec:files:ex17">Exercise 3: Use string operations to improve a program</a>.

<h2>Example: File data in nested dictionaries <a name="sec:files:dictdict"></a></h2>

<!-- keep this example, it has a lot of nice details - then add a section -->
<!-- on Microsoft_table_monthly.csv -->

<h3>Problem  <a name="___sec12"></a></h3>

We are given a data file with measurements of some properties
with given names (here <code>A</code>, <code>B</code>, <code>C</code> ...).
Each property is measured a given number of times.
The data are organized as a table where the rows contain
the measurements and the columns represent the measured properties:

<p>
<!-- begin verbatim block  dat-->
<pre><code>       A        B       C      D
1     11.7    0.035    2017    99.1
2      9.2    0.037    2019   101.2
3     12.2     no       no    105.2
4     10.1    0.031     no    102.1
5      9.1    0.033    2009   103.3
6      8.7    0.036    2015   101.9
</code></pre>
<!-- end verbatim block -->

<p>
The word <code>no</code> stands for no data, i.e., we lack a measurement.
We want to read this table into a dictionary <code>data</code> so that
we can look up measurement no. <code>i</code> of (say) property <code>C</code>
as <code>data['C'][i]</code>.
For each property <code>p</code>, we want to compute the mean of all measurements
and store this as <code>data[p]['mean']</code>.

<h3>Algorithm  <a name="___sec13"></a></h3>

The algorithm for creating the <code>data</code> dictionary goes as follows:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>examine the first line: split it into words and
initialize a dictionary with the property names
as keys and empty dictionaries {} as values

for each of the remaining lines in the file:
    split the line into words
    for each word after the first:
        if the word is not `no`:
            transform the word to a real number and store
            the number in the relevant dictionary
</code></pre>
<!-- end verbatim block -->
<!-- #eldif ALG == "list" -->

<ul>
 <li> examine the first line: split it into words and
   initialize a dictionary with the property names
   as keys and empty dictionaries {} as values</li>
 <li> for each of the remaining lines in the file</li>

<ul>
    <li> split the line into words</li>
    <li> for each word after the first</li>

<ul>
       <li> if the word is not <code>no</code>:</li>

<ul>
           <li> transform the word to a real number and store
             the number in the relevant dictionary</li>
</ul>

</ul>

</ul>

</ul>

<h3>Implementation  <a name="___sec14"></a></h3>

A new aspect needed in the solution is <em>nested dictionaries</em>, that is,
dictionaries of dictionaries. The latter topic is first explained, via an
example:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; d = {'key1': {'key1': 2, 'key2': 3}, 'key2': 7}
</code></pre>
<!-- end verbatim block -->
Observe here that the value of
<code>d['key1']</code> is a dictionary, which we can index with its
keys <code>key1</code> and <code>key2</code>:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; d['key1']            # this is a dictionary
{'key2': 3, 'key1': 2}
&gt;&gt;&gt; type(d['key1'])      # proof
&lt;type 'dict'&gt;
&gt;&gt;&gt; d['key1']['key1']    # index a nested dictionary
2
&gt;&gt;&gt; d['key1']['key2']
3
</code></pre>
<!-- end verbatim block -->
In other words, repeated indexing works for nested dictionaries as for
nested lists.
The repeated indexing does not apply to <code>d['key2']</code>
since that value is just an integer:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; d['key2']['key1']
  ...
TypeError: unsubscriptable object
&gt;&gt;&gt; type(d['key2'])
&lt;type 'int'&gt;
</code></pre>
<!-- end verbatim block -->

<p>
<!-- is it not better to translate the algorithm step by step -->
<!-- instead of presenting the final solution? -->

<p>
When we have understood the concept of
nested dictionaries, we are in a position
to present a complete code that solves our problem
of loading the tabular data in the file <code>table.dat</code> into a nested
dictionary <code>data</code> and computing mean values.
First, we list the program, stored in the file
<a href="http://tinyurl.com/pwyasaa/files/table2dict.py" target="_self"><tt>table2dict.py</tt></a>,
and display the program's output. Thereafter, we dissect the code
in detail.

<p>
<!-- begin verbatim block  pycod-->
<pre><code>infile = open('table.dat', 'r')
lines = infile.readlines()
infile.close()
data = {}   #  data[property][measurement_no] = propertyvalue
first_line = lines[0]
properties = first_line.split()
for p in properties:
    data[p] = {}

for line in lines[1:]:
    words = line.split()
    i = int(words[0])       # measurement number
    values = words[1:]      # values of properties
    for p, v in zip(properties, values):
        if v != 'no':
            data[p][i] = float(v)

# Compute mean values
for p in data:
    values = data[p].values()
    data[p]['mean'] = sum(values)/len(values)

for p in sorted(data):
    print 'Mean value of property %s = %g' % (p, data[p]['mean'])
</code></pre>
<!-- end verbatim block -->
The corresponding output from this program becomes

<p>
<!-- begin verbatim block  ccq-->
<pre><code>Mean value of property A = 10.1667
Mean value of property B = 0.0344
Mean value of property C = 2015
Mean value of property D = 102.133
</code></pre>
<!-- end verbatim block -->
To view the nested <code>data</code> dictionary, we may insert

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import scitools.pprint2; scitools.pprint2.pprint(data)
</code></pre>
<!-- end verbatim block -->
which produces something like

<p>
<!-- begin verbatim block  ccq-->
<pre><code>{'A': {1: 11.7, 2: 9.2, 3: 12.2, 4: 10.1, 5: 9.1, 6: 8.7,
       'mean': 10.1667},
 'B': {1: 0.035, 2: 0.037, 4: 0.031, 5: 0.033, 6: 0.036,
       'mean': 0.0344},
 'C': {1: 2017, 2: 2019, 5: 2009, 6: 2015, 'mean': 2015},
 'D': {1: 99.1,
       2: 101.2,
       3: 105.2,
       4: 102.1,
       5: 103.3,
       6: 101.9,
       'mean': 102.133}}
</code></pre>
<!-- end verbatim block -->

<h3>Dissection  <a name="___sec15"></a></h3>

To understand a computer program, you need to
understand what the result of every statement is.
Let us work through the code, almost line by line, and see what it does.

<p>
First, we load all the lines of the file into a list of strings
called <code>lines</code>.
The <code>first_line</code> variable refers to the string

<p>
<!-- begin verbatim block  pycod-->
<pre><code>'       A        B       C      D'
</code></pre>
<!-- end verbatim block -->
We split this line into a list of words, called <code>properties</code>,
which then contains

<p>
<!-- begin verbatim block  pycod-->
<pre><code>['A', 'B', 'C', 'D']
</code></pre>
<!-- end verbatim block -->
With each of these property names we associate a dictionary with
the measurement number as key and the property value as value,
but first we must create these &quot;inner&quot; dictionaries as empty
before we can add the measurements:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>for p in properties:
    data[p] = {}
</code></pre>
<!-- end verbatim block -->
The first pass in the <code>for</code> loop picks out the string

<p>
<!-- begin verbatim block  pycod-->
<pre><code>'1     11.7    0.035    2017    99.1'
</code></pre>
<!-- end verbatim block -->
as the <code>line</code> variable. We split this line into words,
the first word (<code>words[0]</code>) is the measurement number, while the
rest <code>words[1:]</code> is a list of property values, here named <code>values</code>.
To pair up the right properties and values, we loop over
the <code>properties</code> and <code>values</code> lists simultaneously:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>    for p, v in zip(properties, values):
        if v != 'no':
            data[p][i] = float(v)
</code></pre>
<!-- end verbatim block -->
Recall that some values may be missing and we drop to record
that value (we could, alternatively, set the value to <code>None</code>).
Because the <code>values</code> list contains strings (words) read from
the file, we need to explicitly transform each string to a <code>float</code> number
before we can compute with the values.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 1:  Illustration of the nested dictionary created in the <code>table2dict.py</code> program. <a name="sec:files:fig2"></a> </p></center>
<p><img src="fig-files/lumpy_table2dict2.png" align="bottom" width=400></p>
</center>

<p>
After the <code>for line in lines[1:]</code> loop, we have a dictionary <code>data</code> of
dictionaries where all the property values are stored for each
measurement number and property name.  Figure <a href="#sec:files:fig2">1</a>
shows a graphical representation of the <code>data</code> dictionary.

<p>
It remains to compute the average values. For each property name <code>p</code>,
i.e., key in the <code>data</code> dictionary, we can extract the recorded values
as the list <code>data[p].values()</code> and simply send this list to Python's
<code>sum</code> function and divide by the number of measured values for this
property, i.e., the length of the list:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>for p in data:
    values = data[p].values()
    data[p]['mean'] = sum(values)/len(values)
</code></pre>
<!-- end verbatim block -->
Alternatively, we can write an explicit loop to compute the average:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>for p in data:
    sum_values = 0
    for value in data[p]:
        sum_values += value
    data[p]['mean'] = sum_values/len(data[p])
</code></pre>
<!-- end verbatim block -->

<p>
When we want to look up a measurement no. <code>n</code> of property <code>B</code>, we
must recall that this particular measurement may be missing so we
must do a test if <code>n</code> is key in the dictionary <code>data[p]</code>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>if n in data['B']:
    value = data['B'][n]

# alternative:
value = data['B'][n] if n in data['B'] else None
</code></pre>
<!-- end verbatim block -->

<h2>Example: Reading and plotting data recorded at specific dates <a name="sec:files:stockprices"></a></h2>

<h3>Problem  <a name="___sec17"></a></h3>

We want to compare the evolution of the stock prices
of some giant companies in the computer industry: Microsoft, Apple,
and Google. Relevant data files for stock prices can be downloaded from
<a href="http://finance.yahoo.com" target="_self"><tt>http://finance.yahoo.com</tt></a>.
Fill in the company's name and click on <em>Search Finance</em>
in the top bar of this page and choose <em>Historical Prices</em> in the left
pane.
On the resulting web page one can specify start and end dates
for the historical prices of the stock. The default values were
used in this example. Ticking off <em>Monthly</em> values
and clicking <em>Get Prices</em> result in a table of stock prices for
each month since the stock was introduced.
The table can be downloaded as a spreadsheet file in CSV format,
typically looking like

<p>
<!-- begin verbatim block  dsni-->
<pre><code>Date,Open,High,Low,Close,Volume,Adj Close
2014-02-03,502.61,551.19,499.30,545.99,12244400,545.99
2014-01-02,555.68,560.20,493.55,500.60,15698500,497.62
2013-12-02,558.00,575.14,538.80,561.02,12382100,557.68
2013-11-01,524.02,558.33,512.38,556.07,9898700,552.76
2013-10-01,478.45,539.25,478.28,522.70,12598400,516.57
...
1984-11-01,25.00,26.50,21.87,24.75,5935500,2.71
1984-10-01,25.00,27.37,22.50,24.87,5654600,2.73
1984-09-07,26.50,29.00,24.62,25.12,5328800,2.76
</code></pre>
<!-- end verbatim block -->
The file format is simple: columns are separated by comma, the first
line contains column headings, and the data lines have the date in the
first column and various measures of stock prices in the next
columns. Reading about the meaning of the various data on the Yahoo!
web pages reveals that our interest concerns the final column (as
these prices are adjusted for splits and dividends). Three relevant
data files can be found in the folder <a href="http://tinyurl.com/pwyasaa/files" target="_self"><tt>src/files</tt></a> with the names <code>stockprices_X.csv</code>, where <code>X</code> is
<code>Microsoft</code>, <code>Sun</code>, or <code>Google</code>.

<p>
The task is visually illustrate the historical, relative stock market
value of these companies. For this purpose
it is natural to scale the prices of a company's stock to start at
a unit value when the most recent company entered the market.
Since the date of entry varies, the oldest data point can be skipped
such that all data points correspond to the first trade day every
month.

<h3>Solution  <a name="___sec18"></a></h3>

There are two major parts of this problem: reading the file and
plotting the data. The reading part is quite straightforward, while
the plotting part needs some special considerations since the
\( x \) values in the plot are dates and not real numbers.
In the forthcoming text we solve the individual subproblems one by one,
showing the relevant Python snippets. The complete program is found in the
file <a href="http://tinyurl.com/pwyasaa/files/stockprices.py" target="_self"><tt>stockprices.py</tt></a>.

<p>
We start with the reading part. Since the reading will be repeated for
several companies, we create a function for extracting the relevant
data for a specific company. These data cover the dates in column 1
and the stock prices in the last column. Since we want to plot
prices versus dates, it will be convenient to turn the dates into
<code>date</code> objects. In more detail the algorithms has the following
points:

<ol>
<li> open the file</li>
<li> create two empty lists, dates and prices, for collecting the data</li>
<li> read the first line (of no interest)</li>
<li> for each line in the rest of the file:</li>

<ol>
  <li> split the line wrt. comma into words</li>
  <li> append the first word to the dates list</li>
  <li> append the last word to the prices list</li>
</ol>

<li> reverse the lists (oldest date first)</li>
<li> convert date strings to datetime objects</li>
<li> convert prices list to float array for computations</li>
<li> return dates and prices, except for the first (oldest) data point</li>
</ol>

There are a couple of additional points to consider. First,
the words on a line are strings, and at least the prices (last word)
should be converted to a float. Second, the recipe for converting
dates like '2008-02-04' to <code>date</code> (or <code>datetime</code>) objects goes as

<p>
<!-- begin verbatim block  pycod-->
<pre><code>from datetime import datetime
datefmt = '%Y-%m-%d'  # date format YYYY-MM-DD used in datetime
strdate = '2008-02-04'
datetime_object = datetime.strptime(strdate, datefmt)
date_object = datetime_object.date()
</code></pre>
<!-- end verbatim block -->
The nice thing with <code>date</code> and <code>datetime</code> object is that we
can computed with them and in particular used them in
plotting with Matplotlib.

<p>
We can now translate the algorithm to Python code:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>from datetime import datetime

def read_file(filename):
    infile = open(filename, 'r')
    infile.readline()  # read column headings
    dates = [];  prices = []
    for line in infile:
        words = line.split(',')
        dates.append(words[0])
        prices.append(float(words[-1]))
    infile.close()
    dates.reverse()
    prices.reverse()
    # Convert dates on the form 'YYYY-MM-DD' to date objects
    datefmt = '%Y-%m-%d'
    dates = [datetime.strptime(_date, datefmt).date()
             for _date in dates]
    prices = np.array(prices)
    return dates[1:], prices[1:]
</code></pre>
<!-- end verbatim block -->

<p>
Although we work with three companies in this example, it is easy
and almost always a good idea to generalize the program to an
arbitrary number of companies. All we assume is that their
stock prices are in files with names of the form <code>stockprices_X.csv</code>,
where <code>X</code> is the company name.
With aid of the function call <code>glob.glob('stockprices_*.csv')</code>
we get a list of all such files. By looping over this list, extracting
the company name, and calling <code>read_file</code>, we can store the
dates and corresponding prices in dictionaries <code>dates</code> and <code>prices</code>,
indexed by the company name:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>dates = {};  prices = {}
import glob, numpy as np
filenames = glob.glob('stockprices_*.csv')
companies = []
for filename in filenames:
    company = filename[12:-4]
    d, p = read_file(filename)
    dates[company] = d
    prices[company] = p
</code></pre>
<!-- end verbatim block -->

<p>
The next step is to normalize the prices such that they coincide
on a certain date. We pick this date as the first month we have
data for the youngest company. In lists of <code>date</code> or <code>datetime</code>
objects, we can use Python's <code>max</code> and <code>min</code> function to extract
the newest and oldest date.

<p>
<!-- begin verbatim block  pycod-->
<pre><code>first_months = [dates[company][0] for company in dates]
normalize_date = max(first_months)
for company in dates:
    index = dates[company].index(normalize_date)
    prices[company] /= prices[company][index]

# Plot log of price versus years

import matplotlib.pyplot as plt
from matplotlib.dates import YearLocator, MonthLocator, DateFormatter

fig, ax = plt.subplots()
legends = []
for company in prices:
    ax.plot_date(dates[company], np.log(prices[company]),
                 '-', label=company)
    legends.append(company)
ax.legend(legends, loc='upper left')
ax.set_ylabel('logarithm of normalized value')

# Format the ticks
years    = YearLocator(5)   # major ticks every 5 years
months   = MonthLocator(6)  # minor ticks every 6 months
yearsfmt = DateFormatter('%Y')
ax.xaxis.set_major_locator(years)
ax.xaxis.set_major_formatter(yearsfmt)
ax.xaxis.set_minor_locator(months)
ax.autoscale_view()
fig.autofmt_xdate()

plt.savefig('tmp.pdf'); plt.savefig('tmp.png')
plt.show()
</code></pre>
<!-- end verbatim block -->

<p>
The normalized prices varies a lot, so to see the development over 30
years better, we decide to take the logarithm of the prices. The
plotting procedure is somewhat involved so the reader should take the
coming code more as a recipe than as a sequence of statement to really
understand:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import matplotlib.pyplot as plt
from matplotlib.dates import YearLocator, MonthLocator, DateFormatter

fig, ax = plt.subplots()
legends = []
for company in prices:
    ax.plot_date(dates[company], np.log(prices[company]),
                 '-', label=company)
    legends.append(company)
ax.legend(legends, loc='upper left')
ax.set_ylabel('logarithm of normalized value')

# Format the ticks
years    = YearLocator(5)   # major ticks every 5 years
months   = MonthLocator(6)  # minor ticks every 6 months
yearsfmt = DateFormatter('%Y')
ax.xaxis.set_major_locator(years)
ax.xaxis.set_major_formatter(yearsfmt)
ax.xaxis.set_minor_locator(months)
ax.autoscale_view()
fig.autofmt_xdate()

plt.savefig('tmp.pdf'); plt.savefig('tmp.png')
</code></pre>
<!-- end verbatim block -->
Figure <a href="#sec:files:fig:stockprices1">2</a> shows the resulting plot.
We observe that the normalized prices coincide when Google
entered the market, here at Sep 1, 2004. Note that there is a log scale
on the vertical axis. You may want to plot the real normalized prices
to get a stronger impression of the significant recent rise in value,
especially for Apple.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 2:  The evolution of stock prices for three companies. <a name="sec:files:fig:stockprices1"></a> </p></center>
<p><img src="fig-files/stockprices1.png" align="bottom" width=400></p>
</center>

<h1>Strings <a name="sec:files:str"></a></h1>

Many programs need to manipulate text. For example, when we read the
contents of a file into a string or list of strings (lines),
we may want to change parts of the
text in the string(s) - and maybe write out the modified text to a new file.
So far in this document we have converted parts of the text to numbers
and computed with the numbers. Now it is time to learn how to
manipulate the text strings themselves.

<h2>Common operations on strings <a name="sec:files:stringop"></a></h2>

Python has a rich set of operations on string objects.
<!-- Suppose <code>s</code> is the string <code>Berlin: 18.4 C at 4 pm</code>. -->
Some of the most common operations are listed below.

<h3>Substring specification  <a name="___sec21"></a></h3>

The expression <code>s[i:j]</code> extracts the
substring starting with character number <code>i</code>
and ending with character number <code>j-1</code> (similarly to lists, <code>0</code> is the
index of the first character):

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; s = 'Berlin: 18.4 C at 4 pm'
&gt;&gt;&gt; s[8:]     # from index 8 to the end of the string
'18.4 C at 4 pm'
&gt;&gt;&gt; s[8:12]   # index 8, 9, 10 and 11 (not 12!)
'18.4'
</code></pre>
<!-- end verbatim block -->
A negative upper index
counts, as usual, from the right such that <code>s[-1]</code> is the last
element, <code>s[-2]</code> is the next last element, and so on.

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; s[8:-1]
'18.4 C at 4 p'
&gt;&gt;&gt; s[8:-8]
'18.4 C'
</code></pre>
<!-- end verbatim block -->

<h3>Searching for substrings  <a name="___sec22"></a></h3>

The call
<code>s.find(s1)</code> returns
the index where
the substring <code>s1</code> first appears in <code>s</code>. If the substring is
not found, -1 is returned.

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; s.find('Berlin')  # where does 'Berlin' start?
0
&gt;&gt;&gt; s.find('pm')
20
&gt;&gt;&gt; s.find('Oslo')    # not found
-1
</code></pre>
<!-- end verbatim block -->
Sometimes the aim is to just check if a string is contained in
another string, and then we can use the syntax:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; 'Berlin' in s:
True
&gt;&gt;&gt; 'Oslo' in s:
False
</code></pre>
<!-- end verbatim block -->
Here is a typical use of the latter construction in an <code>if</code> test:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; if 'C' in s:
...     print 'C found'
... else:
...     print 'no C'
...
C found
</code></pre>
<!-- end verbatim block -->
Two other convenient methods
for checking if a string starts with or ends with a specified string
are <code>startswith</code> and <code>endswith</code>:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; s.startswith('Berlin')
True
&gt;&gt;&gt; s.endswith('am')
False
</code></pre>
<!-- end verbatim block -->

<h3>Substitution  <a name="___sec23"></a></h3>

The call
<code>s.replace(s1, s2)</code> replaces substring
<code>s1</code> by
<code>s2</code> everywhere in <code>s</code>:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; s.replace(' ', '_')
'Berlin:_18.4_C__at_4_pm'
&gt;&gt;&gt; s.replace('Berlin', 'Bonn')
'Bonn: 18.4 C at 4 pm'
</code></pre>
<!-- end verbatim block -->
A variant of the last example, where several string operations are
put together, consists of replacing the text before the first colon:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; s.replace(s[:s.find(':')], 'Bonn')
'Bonn: 18.4 C at 4 pm'
</code></pre>
<!-- end verbatim block -->
Take a break at this point and convince yourself that you understand how we
specify the substring to be replaced!

<h3>String splitting  <a name="___sec24"></a></h3>

The call <code>s.split()</code> splits the string <code>s</code> into words separated by
whitespace (space, tabulator, or newline):

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; s.split()
['Berlin:', '18.4', 'C', 'at', '4', 'pm']
</code></pre>
<!-- end verbatim block -->
Splitting a string <code>s</code> into words separated by a text <code>t</code> can be
done by <code>s.split(t)</code>. For example, we may split with respect to colon:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; s.split(':')
['Berlin', ' 18.4 C at 4 pm']
</code></pre>
<!-- end verbatim block -->
We know that <code>s</code> contains a city name, a colon, a temperature,
and then <code>C</code>:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; s = 'Berlin: 18.4 C at 4 pm'
</code></pre>
<!-- end verbatim block -->
With <code>s.splitlines()</code>, a multi-line string is split into
lines (very useful when a file has been read into a string and we want
a list of lines):

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; t = '1st line\n2nd line\n3rd line'
&gt;&gt;&gt; print t
1st line
2nd line
3rd line
&gt;&gt;&gt; t.splitlines()
['1st line', '2nd line', '3rd line']
</code></pre>
<!-- end verbatim block -->

<h3>Upper and lower case  <a name="___sec25"></a></h3>

<code>s.lower()</code> transforms all characters to their lower case
equivalents, and <code>s.upper()</code> performs a similar transformation to
upper case letters:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; s.lower()
'berlin: 18.4 c at 4 pm'
&gt;&gt;&gt; s.upper()
'BERLIN: 18.4 C AT 4 PM'
</code></pre>
<!-- end verbatim block -->

<h3>Strings are constant  <a name="___sec26"></a></h3>

A string cannot be changed, i.e., any change always results in a new string.
Replacement of a character is not possible:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; s[18] = 5
...
TypeError: 'str' object does not support item assignment
</code></pre>
<!-- end verbatim block -->
If we want to replace <code>s[18]</code>, a new string must
be constructed, for example by keeping the substrings on
either side of <code>s[18]</code> and inserting a <code>'5'</code> in between:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; s[:18] + '5' + s[19:]
'Berlin: 18.4 C at 5 pm'
</code></pre>
<!-- end verbatim block -->

<h3>Strings with digits only  <a name="___sec27"></a></h3>

One can easily test whether a string contains digits only or not:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; '214'.isdigit()
True
&gt;&gt;&gt; '  214 '.isdigit()
False
&gt;&gt;&gt; '2.14'.isdigit()
False
</code></pre>
<!-- end verbatim block -->

<h3>Whitespace  <a name="___sec28"></a></h3>

We can also check if a string contains spaces only by calling the
<code>isspace</code> method.
More precisely, <code>isspace</code> tests for <em>whitespace</em>, which means the
space character, newline, or the TAB character:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; '    '.isspace()   # blanks
True
&gt;&gt;&gt; '  \n'.isspace()   # newline
True
&gt;&gt;&gt; '  \t '.isspace()  # TAB
True
&gt;&gt;&gt; ''.isspace()       # empty string
False
</code></pre>
<!-- end verbatim block -->
The <code>isspace</code> is handy for testing for blank lines in files.
An alternative is to strip first and then test for an empty string:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; line = '   \n'
&gt;&gt;&gt; line.strip() == ''
True
</code></pre>
<!-- end verbatim block -->

<p>
Stripping off leading and/or trailing spaces in a string is sometimes useful:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; s = '   text with leading/trailing space   \n'
&gt;&gt;&gt; s.strip()
'text with leading/trailing space'
&gt;&gt;&gt; s.lstrip()   # left strip
'text with leading/trailing space   \n'
&gt;&gt;&gt; s.rstrip()   # right strip
'   text with leading/trailing space'
</code></pre>
<!-- end verbatim block -->

<p>
<a name="sec:files:join"></a>

<h3>Joining strings  <a name="___sec29"></a></h3>

The opposite of the <code>split</code> method is <code>join</code>, which joins elements
in a list of strings with a specified delimiter in between.
That is,
the following two types of statements are inverse operations:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>t = delimiter.join(words)
words = t.split(delimiter)
</code></pre>
<!-- end verbatim block -->
An example on using <code>join</code> may be

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; strings = ['Newton', 'Secant', 'Bisection']
&gt;&gt;&gt; t = ', '.join(strings)
&gt;&gt;&gt; t
'Newton, Secant, Bisection'
</code></pre>
<!-- end verbatim block -->

<p>
As an illustration of the usefulness of <code>split</code> and <code>join</code>,
we want to remove the first two words on a line.
This task can be done by
first splitting the line into words and then joining the words of interest:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; line = 'This is a line of words separated by space'
&gt;&gt;&gt; words = line.split()
&gt;&gt;&gt; line2 = ' '.join(words[2:])
&gt;&gt;&gt; line2
'a line of words separated by space'
</code></pre>
<!-- end verbatim block -->

<p>
There are many more methods in string objects. All methods are described
in the
<a href="http://docs.python.org/2/library/stdtypes.html#string-methods" target="_self">String Methods</a> section of the Python Standard Library online document.

<h2>Example: Reading pairs of numbers <a name="sec:files:pairs"></a></h2>

<h3>Problem  <a name="___sec31"></a></h3>

Suppose we have a file consisting of pairs of real numbers, i.e.,
text of the form \( (a,b) \), where \( a \) and \( b \) are real numbers.
This notation for a pair of numbers is often used for points in the
plane, vectors in the plane, and complex
numbers. A sample file may look as follows:

<p>
<!-- begin verbatim block  dat-->
<pre><code>(1.3,0)    (-1,2)    (3,-1.5)
(0,1)      (1,0)     (1,1)
(0,-0.01)  (10.5,-1) (2.5,-2.5)
</code></pre>
<!-- end verbatim block -->

<p>
The file can be found as <code>read_pairs1.dat</code>.  Our task is to read this
text into a nested list <code>pairs</code> such that <code>pairs[i]</code> holds the pair
with index <code>i</code>, and this pair is a tuple of two <code>float</code> objects.  We
assume that there are no blanks inside the parentheses of a pair of
numbers (we rely on a split operation, which would otherwise not work).

<h3>Solution  <a name="___sec32"></a></h3>

To solve this programming problem, we can read in the file line by
line; for each line: split the line into words (i.e., split with
respect to whitespace); for each word: strip off the parentheses,
split with respect to comma, and convert the resulting two words to
floats.  Our brief algorithm can be almost directly translated to
Python code:

<p>
<!-- begin verbatim block  pycod-->
<pre><code># Load the file into list of lines
with open('read_pairs1.dat', 'r') as infile:
    lines = infile.readlines()

# Analyze the contents of each line
pairs = []   # list of (n1, n2) pairs of numbers
for line in lines:
    words = line.split()
    for word in words:
        word = word[1:-1]  # strip off parenthesis
        n1, n2 = word.split(',')
        n1 = float(n1);  n2 = float(n2)
        pair = (n1, n2)
        pairs.append(pair)  # add 2-tuple to last row
</code></pre>
<!-- end verbatim block -->
This code is available in the file
<a href="http://tinyurl.com/pwyasaa/files/read_pairs1.py" target="_self"><tt>read_pairs1.py</tt></a>.
The <code>width</code> statement is the modern Python way of reading files,
see the section ref{sec:files:reading:other},
with the advantage that we do not need to think about closing the file.
Figure <a href="#sec:files:fig1">3</a> shows a snapshot of the state of the
variables in the program after having treated the first line.
You should explain each line in the program to yourself, and
compare your understanding with the figure.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 3:  Illustration of the variables in the <code>read_pairs.py</code> program after the first pass in the loop over words in the first line of the data file. <a name="sec:files:fig1"></a> </p></center>
<p><img src="fig-files/lumpy_read_pairs.png" align="bottom" width=400></p>
</center>

<p>
The output from the program becomes

<p>
<!-- begin verbatim block  ccq-->
<pre><code>[(1.3, 0.0),
 (-1.0, 2.0),
 (3.0, -1.5),
 (0.0, 1.0),
 (1.0, 0.0),
 (1.0, 1.0),
 (0.0, -0.01),
 (10.5, -1.0),
 (2.5, -2.5)]
</code></pre>
<!-- end verbatim block -->

<p>
We remark that our solution to this programming problem relies heavily
on the fact that spaces inside the parentheses are not allowed.  If
spaces were allowed, the simple split to obtain the pairs on a line as
words would not work. What can we then do?

<p>
We can first strip off all blanks on a line, and then observe that the
pairs are separated by the text <code>')('</code>.  The first and last pair on a
line will have an extra parenthesis that we need to remove. The rest
of code is similar to the previous code and can be found in
<a href="http://tinyurl.com/pwyasaa/files/read_pairs2.py" target="_self"><tt>read_pairs2.py</tt></a>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>with open('read_pairs2.dat', 'r') as infile:
    lines = infile.readlines()

# Analyze the contents of each line
pairs = []   # list of (n1, n2) pairs of numbers
for line in lines:
    line = line.strip()  # remove whitespace such as newline
    line = line.replace(' ', '')  # remove all blanks
    words = line.split(')(')
    # strip off leading/trailing parenthesis in first/last word:
    words[0] = words[0][1:]      # (-1,3  -&gt;  -1,3
    words[-1] = words[-1][:-1]   # 8.5,9) -&gt;  8.5,9
    for word in words:
        n1, n2 = word.split(',')
        n1 = float(n1);  n2 = float(n2)
        pair = (n1, n2)
        pairs.append(pair)
</code></pre>
<!-- end verbatim block -->

<p>
The program can be tested on the file <code>read_pairs2.dat</code>:

<p>
<!-- begin verbatim block  dat-->
<pre><code>   (1.3 , 0)    (-1 , 2 )    (3, -1.5)
(0 , 1)      ( 1, 0)     ( 1 , 1 )
(0,-0.01)  (10.5,-1) (2.5, -2.5)
</code></pre>
<!-- end verbatim block -->

<p>
A third approach is to notice that if the pairs were separated
by commas,

<p>
<!-- begin verbatim block  ccq-->
<pre><code>(1, 3.0),    (-1, 2),    (3, -1.5)
(0, 1),      (1, 0),     (1, 1)
</code></pre>
<!-- end verbatim block -->
the file text is very close to the Python syntax of a list
of 2-tuples. By adding enclosing brackets, plus a comma at the
end of each line,

<p>
<!-- begin verbatim block  ccq-->
<pre><code>[(1, 3.0),    (-1, 2),    (3, -1.5),
(0, 1),      (1, 0),     (1, 1),]
</code></pre>
<!-- end verbatim block -->
we have a string to which we can apply <code>eval</code> to get the <code>pairs</code> list
directly.  Here is the code doing this (program <a href="http://tinyurl.com/pwyasaa/files/read_pairs3.py" target="_self"><tt>read_pairs3.py</tt></a>):

<p>
<!-- begin verbatim block  pycod-->
<pre><code>with open('read_pairs3.dat', 'r') as infile:
    listtext = '['
    for line in infile:
        # add line, without \n (line[:-1]), with a trailing comma:
        listtext += line[:-1] + ', '
listtext = listtext + ']'
pairs = eval(listtext)
</code></pre>
<!-- end verbatim block -->
In general, it is a good idea to construct file formats that are as close
as possible to valid Python syntax such that one can take advantage
of the <code>eval</code> or <code>exec</code> functions to turn text into &quot;live objects&quot;.

<h2>Example: Reading coordinates  <a name="___sec33"></a></h2>

<h3>Problem  <a name="___sec34"></a></h3>

Suppose we have a file with coordinates \( (x,y,z) \)
in three-dimensional space. The file format looks as follows:

<p>
<!-- begin verbatim block  dat-->
<pre><code>  x=-1.345      y= 0.1112      z= 9.1928
  x=-1.231      y=-0.1251      z= 1001.2
  x= 0.100      y= 1.4344E+6   z=-1.0100
  x= 0.200      y= 0.0012      z=-1.3423E+4
  x= 1.5E+5     y=-0.7666      z= 1027
</code></pre>
<!-- end verbatim block -->

<p>
The goal is to read this file and create a list with <code>(x,y,z)</code>
3-tuples, and thereafter convert the nested list to a two-dimensional
array with which we can compute.

<p>
Note that there is sometimes a space between the <code>=</code> signs and the
following number and sometimes not. Splitting with respect to space and
extracting every second word is therefore not an option.
We shall present three solutions.

<h3>Solution 1: substring extraction  <a name="___sec35"></a></h3>

The file format looks very regular with the <code>x=</code>, <code>y=</code>,
and <code>z=</code> texts starting in the same columns at every line.
By counting characters, we realize that the <code>x=</code> text starts
in column 2, the <code>y=</code> text starts in column 16, while the
<code>z=</code> text starts in column 31. Introducing

<p>
<!-- begin verbatim block  pycod-->
<pre><code>x_start = 2
y_start = 16
z_start = 31
</code></pre>
<!-- end verbatim block -->
the three numbers in a <code>line</code> string are obtained as the substrings

<p>
<!-- begin verbatim block  pycod-->
<pre><code>x = line[x_start+2:y_start]
y = line[y_start+2:z_start]
z = line[z_start+2:]
</code></pre>
<!-- end verbatim block -->
The following code, found in file
<a href="http://tinyurl.com/pwyasaa/files/file2coor_v1.py" target="_self"><tt>file2coor_v1.py</tt></a>,
creates the <code>coor</code> array with shape \( (n,3) \),
where \( n \) is the number of \( (x,y,z) \) coordinates.

<p>
<!-- begin verbatim block  pypro-->
<pre><code>infile = open('xyz.dat', 'r')
coor = []  # list of (x,y,z) tuples
for line in infile:
    x_start = 2
    y_start = 16
    z_start = 31
    x = line[x_start+2:y_start]
    y = line[y_start+2:z_start]
    z = line[z_start+2:]
    print 'debug: x=&quot;%s&quot;, y=&quot;%s&quot;, z=&quot;%s&quot;' % (x,y,z)
    coor.append((float(x), float(y), float(z)))
infile.close()

import numpy as np
coor = np.array(coor)
print coor.shape, coor
</code></pre>
<!-- end verbatim block -->
The <code>print</code> statement inside the loop
is always wise to include when doing string manipulations,
simply
because counting indices for substring limits quickly leads to errors.
Running the program, the output from the loop looks like this

<p>
<!-- begin verbatim block  ccq-->
<pre><code>debug: x=&quot;-1.345   &quot;, y=&quot; 0.1112   &quot;, z=&quot; 9.1928
&quot;
</code></pre>
<!-- end verbatim block -->
for the first line in the file. The double quotes show the exact
extent of the extracted coordinates. Note that the last quote
appears on the next line. This is because <code>line</code> has a newline
at the end (this newline must be there to define the end of the line),
and the substring <code>line[z_start:]</code> contains the newline at the
of <code>line</code>. Writing <code>line[z_start:-1]</code> would leave the
newline out of the \( z \) coordinate. However, this has no effect in
practice since we transform the substrings to <code>float</code>, and an extra
newline or other blanks make no harm.

<p>
The <code>coor</code> object at the end of the program has the value

<p>
<!-- begin verbatim block  ccq-->
<pre><code>[[ -1.34500000e+00   1.11200000e-01   9.19280000e+00]
 [ -1.23100000e+00  -1.25100000e-01   1.00120000e+03]
 [  1.00000000e-01   1.43440000e+06  -1.01000000e+00]
 [  2.00000000e-01   1.20000000e-03  -1.34230000e+04]
 [  1.50000000e+05  -7.66600000e-01   1.02700000e+03]]
</code></pre>
<!-- end verbatim block -->

<h3>Solution 2: string search  <a name="___sec36"></a></h3>

One problem with the solution approach above is that the program
will not work if the file format is subject to a
change in the
column positions of <code>x=</code>, <code>y=</code>, or <code>z=</code>.
Instead of hardcoding numbers for the column positions, we can use
the <code>find</code> method in string objects to locate these column positions:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>x_start = line.find('x=')
y_start = line.find('y=')
z_start = line.find('z=')
</code></pre>
<!-- end verbatim block -->
The rest of the code is similar to the complete program listed above,
and the complete code is stored in the file
<a href="http://tinyurl.com/pwyasaa/files/file2coor_v2.py" target="_self"><tt>file2coor_v2.py</tt></a>.

<h3>Solution 3: string split  <a name="___sec37"></a></h3>

String splitting is a powerful tool, also in the present case.
Let us split with respect to the equal sign. The first line in the file
then gives us the words

<p>
<!-- begin verbatim block  ccq-->
<pre><code>['x', '-1.345   y', ' 0.1112   z', ' 9.1928']
</code></pre>
<!-- end verbatim block -->
We throw away the first word, and strip off the last character in the
next word. The final word can be used as is. The complete program
is found in the file
<a href="http://tinyurl.com/pwyasaa/files/file2coor_v3.py" target="_self"><tt>file2coor_v3.py</tt></a> and looks like

<p>
<!-- begin verbatim block  pypro-->
<pre><code>infile = open('xyz.dat', 'r')
coor = []  # list of (x,y,z) tuples
for line in infile:
    words = line.split('=')
    x = float(words[1][:-1])
    y = float(words[2][:-1])
    z = float(words[3])
    coor.append((x, y, z))
infile.close()

import numpy as np
coor = np.array(coor)
print coor.shape, coor
</code></pre>
<!-- end verbatim block -->

<p>
More sophisticated examples of string operations appear in
the section <a href="#sec:files:url:interpret">Example: Extracting data from HTML</a>.

<h1>Reading data from web pages <a name="sec:files:webtxt"></a></h1>

Python has a module <code>urllib</code> which makes it possible to read data from
a web page as easily as
we can read data from an ordinary file. (In principle this is
true, but in practice
the text in web pages tend to be much more complicated than the text
in the files we have treated so far.)
Before we do this, a few concepts from the Internet world must be touched.

<h2>About web pages <a name="sec:files:HTMLintro"></a></h2>

Web pages are viewed with a web browser. There are many browsers:
Firefox, Internet Explorer, Safari, Opera, and Google Chrome to mention
the most famous.
Any web page you visit is associated with an address, usually something like

<p>
<!-- begin verbatim block  ccq-->
<pre><code>http://www.some.where.net/some/file.html
</code></pre>
<!-- end verbatim block -->
This type of web address is called
a URL (Uniform Resource Locator) or
URI (Uniform Resource Identifier).
(We stick to the term URL in this document because Python's tools for
accessing resources on the Internet have <code>url</code> as part of
module and function names.)
The graphics you see in a web browser, i.e., the web page you see with
your eyes, is produced by a series of commands that specifies
the text on the page, the images, buttons to be pressed, etc.
Roughly speaking, these commands are like statements in computer programs.
The commands are stored in a text file and follow rules in a language,
exactly as you are used to when writing statements in a programming language.

<p>
The common language for defining web pages is HTML.
A web page is then simply a text file with text containing
HTML commands. Instead of a physical file, the web page can also be
the output text from a program. In that case the URL is the name of the
program file.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 4:  Example of what a very simple HTML file looks like in a web browser. <a name="sec:io:webpagefig"></a> </p></center>
<p><img src="fig-files/simple_webpage.png" align="bottom" width=400></p>
</center>

<p>
The web browser interprets the text and the HTML commands, and then
decides how to display the
information visually. Let us demonstrate this for a very simple
web page shown in Figure <a href="#sec:io:webpagefig">4</a>.
This page was produced by the following text with embedded HTML commands:

<p>
<!-- begin verbatim block  htmlpro-->
<pre><code>&lt;html&gt;
&lt;body bgcolor=&quot;orange&quot;&gt;
&lt;h1&gt;A Very Simple HTML Page&lt;/h1&gt; &lt;!-- headline --&gt;
Web pages are written in a language called
&lt;a href=&quot;http://www.w3.org/MarkUp/Guide/&quot;&gt;HTML&lt;/a&gt;.
Ordinary text is written as ordinary text, but when we
need links, headlines, lists,
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;emphasized words&lt;/em&gt;, or
&lt;li&gt; &lt;b&gt;boldface text&lt;/b&gt;, 
&lt;/ul&gt;
we need to embed the text inside HTML tags. We can also
insert GIF or PNG images, taken from other Internet sites, 
if desired.
&lt;hr&gt; &lt;!-- horizontal line --&gt;
&lt;img src=&quot;http://www.simula.no/simula_logo.gif&quot;&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<!-- end verbatim block -->

<p>
A typical HTML command consists of an opening and a closing <em>tag</em>.
For example, emphasized text is specified by enclosing the text
inside <code>em</code> (emphasize) tags:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>&lt;em&gt;emphasized words&lt;/em&gt;
</code></pre>
<!-- end verbatim block -->
The opening tag is enclosed in less than and greater than signs, while
the closing tag has an additional forward slash before the tag name.

<p>
In the HTML file we see an opening and closing <code>html</code> tag around the
whole text in the file. Similarly, there is a pair of <code>body</code> tags,
where the first one also has a parameter <code>bgcolor</code> which can be used
to specify a background color in the web page.  Section headlines are
specified by enclosing the headline text inside <code>h1</code> tags. Subsection
headlines apply <code>h2</code> tags, which results in a smaller font compared
with <code>h1</code> tags.  Comments appear inside <code><!--</code> and <code>--></code>.  Links to
other web pages are written inside <code>a</code> tags, with an argument <code>href</code>
for the link's web address.  Lists apply the <code>ul</code> (unordered list)
tag, while each item is written with just an opening tag <code>li</code> (list
item), but no closing tag is necessary. Images are also specified with
just an opening tag having name <code>img</code>, and the image file is given as
a file name or URL of a file, enclosed in double quotes, as the <code>src</code>
parameter.

<p>
The ultra-quick HTML course in the previous paragraphs gives a glimpse
of how web pages can be constructed.
One can either write the HTML
file by hand in a pure text editor, or one can use programs such as
Dream Weaver to help design the page graphically in a user-friendly
environment, and then the program can automatically
generate the right HTML syntax in files.

<h2>How to access web pages in programs <a name="sec:files:urllib"></a></h2>

Why is it useful to know some HTML and how web pages are constructed?
The reason is that the web is full of information that we can
get access to through programs and use in new contexts. What we can get
access to is not the visual web page you see, but the underlying HTML
file. The information you see on the screen appear in text form in
the HTML file, and by extracting text, we can get hold of the
text's information in a program.

<p>
Given the URL as a string stored in a variable,
there are two ways of accessing the HTML text in a Python program:

<h3>Alternative 1  <a name="___sec41"></a></h3>

Download the HTML file and store it as a local file with a given name,
say <code>webpage.html</code>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import urllib
url = 'http://www.simula.no/research/scientific/cbc'
urllib.urlretrieve(url, filename='webpage.html')
</code></pre>
<!-- end verbatim block -->

<h3>Alternative 2  <a name="___sec42"></a></h3>

Open the HTML file as a file-like object:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>infile = urllib.urlopen(url)
</code></pre>
<!-- end verbatim block -->
This <code>infile</code> object has methods such as <code>read</code>, <code>readline</code>, and
<code>readlines</code>.

<h2>Example: Reading pure text files <a name="sec:files:url:weather"></a></h2>

Some web pages are just pure text files. Extracting the data from such
pages are as easy as reading ordinary text files. Here is an example
of historic weather data from the UK:

<p>
<!-- begin verbatim block  ccq-->
<pre><code>http://www.metoffice.gov.uk/climate/uk/stationdata/
</code></pre>
<!-- end verbatim block -->
We may choose a station, say Oxford, which directs us to the page

<p>
<!-- begin verbatim block  ccq-->
<pre><code>http://www.metoffice.gov.uk/climate/uk/stationdata/oxforddata.txt
</code></pre>
<!-- end verbatim block -->
We can download this data file by

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import urllib
url = \ 
'http://www.metoffice.gov.uk/climate/uk/stationdata/oxforddata.txt'
urllib.urlretrieve(url, filename='Oxford.txt')
</code></pre>
<!-- end verbatim block -->
The files looks as follows:

<p>
<!-- begin verbatim block  dat-->
<pre><code>Oxford
Location: 4509E 2072N, 63 metres amsl
Estimated data is marked with a * after the value.
Missing data (more than 2 days missing in month) is marked by  ---.
Sunshine data taken from an automatic ...
   yyyy  mm   tmax    tmin      af    rain     sun
              degC    degC    days      mm   hours
   1853   1    8.4     2.7       4    62.8     ---
   1853   2    3.2    -1.8      19    29.3     ---
   1853   3    7.7    -0.6      20    25.9     ---
   1853   4   12.6     4.5       0    60.1     ---
   1853   5   16.8     6.1       0    59.5     ---

...

   2010   1    4.7    -1.0      17    56.4    68.2
   2010   2    7.1     1.3       7    79.8    59.3
   2010   3   11.3     3.2       8    47.6   130.2
   2010   4   15.8     4.9       0    25.5   209.5
   2010   5   17.6     7.3       0    28.6   207.4
   2010   6   23.0    11.1       0    34.5   230.5
   2010   7   23.3*   14.1*      0*   24.4*  184.4*  Provisional
   2010   8   21.4    12.0       0   146.2   123.8   Provisional
   2010   9   19.0    10.0       0    48.1   118.6   Provisional
   2010  10   14.6     7.4       2    43.5   128.8   Provisional
</code></pre>
<!-- end verbatim block -->
After the 7 header lines the data consists of 7 or 8 columns of
numbers, the 8th being of no interest.
Some numbers may have <code>*</code> or <code>#</code> appended to them,
but this character must be stripped off before using the number.
The columns contain the year, the month number (1-12), average maximum
temperature, average minimum temperature, total number of days of
air frost (<code>af</code>) during the month,
total rainfall during the month, and the total number
of hours with sun during the month. The temperature averages are taken
over the maximum and minimum temperatures for all days in the month.
Unavailable data are marked by three dashes.

<p>
The data can be conveniently stored in a dictionary with, e.g.,
three main keys: place (name), location (the info on the 2nd),
and data. The latter is a dictionary with two keys: year and month.

<p>
The following program creates the <code>data</code> dictionary:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>infile = open(local_file, 'r')
data = {}
data['place'] = infile.readline().strip()
data['location'] = infile.readline().strip()
# Skip the next 5 lines
for i in range(5):
    infile.readline()

data['data'] ={}
for line in infile:
    columns = line.split()

    year = int(columns[0])
    month = int(columns[1])

    if columns[-1] == 'Provisional':
        del columns[-1]
    for i in range(2, len(columns)):
        if columns[i] == '---':
            columns[i] = None
        elif columns[i][-1] == '*' or columns[i][-1] == '#':
            # Strip off trailing character
            columns[i] = float(columns[i][:-1])
        else:
            columns[i] = float(columns[i])

    tmax, tmin, air_frost, rain, sun = columns[2:]

    if not year in data['data']:
        data['data'][year] = {}
    data['data'][year][month] = {'tmax': tmax,
                                 'tmin': tmin,
                                 'air frost': air_frost,
                                 'sun': sun}
</code></pre>
<!-- end verbatim block -->
The code is available in the file
<a href="http://tinyurl.com/pwyasaa/files/historic_weather.py" target="_self"><tt>historic_weather.py</tt></a>.

<p>
With a few lines of code, we can extract the data we want, say a
two-dimensional array of the number of sun hours in a month (these data
are available from year 1929):

<p>
<!-- begin verbatim block  pycod-->
<pre><code>sun = [[data['data'][y][m]['sun'] for m in range(1,13)] \ 
       for y in range(1929, 2010)]
import numpy as np
sun = np.array(sun)
</code></pre>
<!-- end verbatim block -->
One can now do analysis of the data as exemplified in
the section ref{sec:looplist:summary:ex} and ref{sec:plot:ex33}.

<h2>Example: Extracting data from HTML <a name="sec:files:url:interpret"></a></h2>

Very often, interesting data in a web page appear inside HTML code.
We then need to interpret the text using string operations and store
the data in variables. An example will clarify the principle.

<p>
The web site <code>www.worldclimate.com</code> contains data on temperature and
rainfall in a large number of cities around the world.
For example,

<p>
<!-- begin verbatim block  ccq-->
<pre><code>http://www.worldclimate.com/cgi-bin/data.pl?ref=N38W009+2100+08535W
</code></pre>
<!-- end verbatim block -->
contains a table of the average rainfall for each month of the year
in the town Lisbon, Portugal.
Our task is to download this web page and extract the tabular data
(rainfall per month) in a list.

<p>
Downloading the file is done with <code>urllib</code> as explained in
the sections <a href="#sec:files:urllib">How to access web pages in programs</a> and <a href="#sec:files:url:weather">Example: Reading pure text files</a>.
Before attempting to read and interpret the text in the file, we need
to look at the HTML code to find the interesting parts and determine
how we can extract the data.
The table with the rainfall data appears in the middle of the file.
A sketch of the relevant HTML code goes as follows:

<p>
<!-- begin verbatim block  dat-->
<pre><code>&lt;p&gt;Weather station &lt;strong&gt;LISBOA&lt;/strong&gt; ...
&lt;tr&gt;&lt;th align=right&gt;&lt;th&gt;  Jan&lt;th&gt;  Feb&lt;th&gt; ... &lt;br&gt;
&lt;tr&gt;&lt;td&gt; mm &lt;td align=right&gt; 95.2 &lt;td align=right&gt; 86.7 ...&lt;br&gt;
&lt;tr&gt;&lt;td&gt;inches &lt;td align=right&gt;3.7&lt;td align=right&gt;3.4 ...&lt;br&gt;
</code></pre>
<!-- end verbatim block -->
Our task is to walk through the file line by line and stop for processing
the first and third line above:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>infile = open('Lisbon_rainfall.html', 'r')
rainfall = []
for line in infile:
    if 'Weather station' in line:
        station = line.split('&lt;/strong&gt;')[0].split('&lt;strong&gt;')[0]
    if '&lt;td&gt; mm &lt;td' in line:
        data = line.split('&lt;td align=right&gt;')
</code></pre>
<!-- end verbatim block -->
The resulting <code>data</code> list looks like

<p>
<!-- begin verbatim block  pycod-->
<pre><code>['&lt;tr&gt;&lt;td&gt; mm ', ' 95.2 ', ..., '702.4&lt;br&gt; \n']
</code></pre>
<!-- end verbatim block -->
To process this list further, we strip off the <code><br>...</code> part of
the last element:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>        data[-1] = data[-1].split('&lt;br&gt;')[0]
</code></pre>
<!-- end verbatim block -->
Then we drop the first element and convert the others to <code>float</code>
objects:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>        data = [float(x) for x in data[1:]]
</code></pre>
<!-- end verbatim block -->
Now we have the rainfall data for each month as a list of real
numbers. The complete program appears in the file
<a href="http://tinyurl.com/pwyasaa/files/Lisbon_rainfall.py" target="_self"><tt>Lisbon_rainfall.py</tt></a>.
The recipe provided in this example can be used to interpret many other
types of web pages where HTML code and data are wired together.

<p>
<!-- send SMS to mobile phone -->
<!-- <a href="http://www.gammu.org/wiki/index.php" target="_self"><tt>http://www.gammu.org/wiki/index.php</tt></a>?title=Main_Page -->

<h2>Handling non-English text <a name="sec:files:encoding"></a></h2>

By default, Python only accepts English characters in a program file.
Comments and strings in other languages, containing non-English characters,
requires a special comment line before any non-English characters appears:

<p>
<!-- begin verbatim block  pycod-->
<pre><code># -*- coding: utf-8 -*-
</code></pre>
<!-- end verbatim block -->
This line specifies that the file applies the UTF-8 encoding. Alternative
encodings are UTF-16 and latin-1, depending on what your computer system
supports. UTF-8 is most common nowadays.

<p>
There are two types of strings in Python: plain strings (known as
byte strings) with type <code>str</code>
and unicode strings with type <code>unicode</code>. Plain strings suffice as long
as you are writing English text only. A string is then just a
series of bytes representing integers between 0 and 255.
The first characters corresponding to the numbers 0 to 127 constitute
the ASCII set. These can be printed out:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>for i in range(0, 128):
    print i, chr(i)
</code></pre>
<!-- end verbatim block -->
The keys on an English keyboard can be recognized from <code>i=32</code> to <code>i=126</code>.
The next numbers are used to represent non-English characters.

<p>
Texts with non-English
characters are recommended to be represented by unicode strings.
This is the default string type in Python 3, while in Python
2 we need to explicitly annotate a string as unicode by
a <code>u</code> prefix as in <code>s = u'my text'</code>.

<p>
We shall now explore plain strings and unicode strings and will for
that purpose need a help function for displaying a string in the terminal
window, printing the type of string, dumping the exact content of
the string, and telling us the length of the string in bytes:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def check(s):
    print '%s, %s: %s (%d)' % \ 
          (s, s.__class__.__name__, repr(s), len(s))
</code></pre>
<!-- end verbatim block -->
Let us start with a German character typed with a German keyboard:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; Gauss = 'C. F. Gauß'
&gt;&gt;&gt; check(Gauss)
C. F. Gauß, str: 'C. F. Gau\xc3\x9f' (11)
</code></pre>
<!-- end verbatim block -->
Observe that there are 10 characters in the string, but <code>len(Gauss)</code>
is 11. We can write each character:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; for char in Gauss:
...     print ord(char),
...
67 46 32 70 46 32 71 97 117 195 159
</code></pre>
<!-- end verbatim block -->
The last character in the <code>Gauss</code> object, the special German character,
is represented
by two bytes: 195 and 159. The other characters are in the
range 0-127.

<p>
The <code>Gauss</code> object above is a plain Python 2 (byte) string. We can define
the string as unicode in Python 2:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; Gauss = u'C. F. Gauß'
&gt;&gt;&gt; check(Gauss)
C. F. Gauß, unicode: u'C. F. Gau\xdf' (10)
</code></pre>
<!-- end verbatim block -->
This time the unicode representation is as long as the expected number
of characters, and the special German ß looks like <code>\xdf</code>.
In fact, this character has unicode representation
DF and we can use this code directly
when we define the string, instead of a German keyboard:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; Gauss = u'C. F. Gau\xdf'
&gt;&gt;&gt; check(Gauss)
C. F. Gauß, unicode: u'C. F. Gau\xdf' (10)
</code></pre>
<!-- end verbatim block -->
The string can be defined through the UTF-8 bytecode counterpart to ß,
which is C3 9F:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; Gauss = 'C. F. Gau\xc3\x9f'  # plain string
&gt;&gt;&gt; check(Gauss)
C. F. Gauß, str: 'C. F. Gau\xc3\x9f' (11)
</code></pre>
<!-- end verbatim block -->
Mixing UTF-8 bytecode in unicode strings, as in <code>u'C. F. Gau\xc3\x9f'</code>,
gives and unreadable output.

<p>
We can convert from a unicode representation to UTF-8 bytecode
and back again:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; Gauss = u'C. F. Gau\xdf'
&gt;&gt;&gt; repr(Gauss.encode('utf-8'))  # convert to UTF-8 bytecode
'C. F. Gau\xc3\x9f'
&gt;&gt;&gt; unicode(Gauss.encode('utf-8'), 'utf-8')  # convert back again
u'C. F. Gau\xdf'
</code></pre>
<!-- end verbatim block -->

<p>
Other encodings are UTF-16 and latin-1:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; repr(Gauss.encode('utf-16'))
'\xff\xfeC\x00.\x00 \x00F\x00.\x00 \x00G\x00a\x00u\x00\xdf\x00'
&gt;&gt;&gt; repr(Gauss.encode('latin-1'))
'C. F. Gau\xdf'
</code></pre>
<!-- end verbatim block -->

<p>
Writing the unicode variable <code>Gauss</code> to file, a la <code>f.write(Gauss)</code>,
leads to a <code>UnicodeEncodeError</code> in Python 2, saying that <code>'ascii'
codec can't encode character u'\xdf' in position 9</code>.  The UTF-8
bytecode representation of strings does not pose any problems with
file writing.  The solution for unicode
strings is to use the <code>codecs</code> module and explicitly work with a
file object that converts unicode to UTF-8:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import codecs
with codecs.open('tmp.txt', 'w', 'utf-8') as f:
    f.write(Gauss)
</code></pre>
<!-- end verbatim block -->
This is not necessary with Python 3, so if you use non-English characters,
Python 3 has a clear advantage over Python 2.

<p>
To summarize, non-English character can be input with a non-English
keyboard and stored either as a plain (byte) string or as a unicode
string:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; name = 'Åsmund Ødegård'  # plain string
&gt;&gt;&gt; check(name)
Åsmund Ødegård, str: '\xc3\x85smund \xc3\x98deg\xc3\xa5rd' (17)
&gt;&gt;&gt; name = u'Åsmund Ødegård' # unicode
&gt;&gt;&gt; check(name)
Åsmund Ødegård, unicode: u'\xc5smund \xd8deg\xe5rd' (14)
</code></pre>
<!-- end verbatim block -->
Alternatively, the non-English characters can be specified
with special codes, depending on whether the representation is a
plain UTF-8 string or a unicode string.
Using a <a href="http://www.utf8-chartable.de/" target="_self">table</a> with conversion
between unicode and UTF-8 representation we find that
in UTF-8, Å has the code C3 85, Ø is C3 98, and å is C3 A5:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; name = '\xc3\x85smund \xc3\x98deg\xc3\xa5rd'
&gt;&gt;&gt; check(name)
Åsmund Ødegård, str: '\xc3\x85smund \xc3\x98deg\xc3\xa5rd' (17)
</code></pre>
<!-- end verbatim block -->
In unicode, Å is C5, Ø is D8, å is E5:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; name = u'\xc5smund \xd8deg\xe5rd'
&gt;&gt;&gt; check(name)
Åsmund Ødegård, unicode: u'\xc5smund \xd8deg\xe5rd' (14)
</code></pre>
<!-- end verbatim block -->

<p>
The examples above have been collected in the file <a href="http://tinyurl.com/pwyasaa/files/unicode_utf8.py" target="_self"><tt>unicode_utf8.py</tt></a>.

<h1>Reading and writing spreadsheet files <a name="sec:files:csv"></a></h1>

From school you are probably used to spreadsheet programs such as
Microsoft Excel or LibreOffice. This type of program is used to represent
a table of numbers and text. Each table entry is known as a <em>cell</em>,
and one can easily perform calculations with cells that contain numbers.
The application of spreadsheet programs for mathematical computations
and graphics is steadily growing.

<p>
Also Python may be used to do spreadsheet-type calculations on tabular
data.  The advantage of using Python is that you can easily extend the
calculations far beyond what a spreadsheet program can do. However,
even if you can view Python as a substitute for a spreadsheet program,
it may be beneficial to combine the two. Suppose you have some data in
a spreadsheet. How can you read these data into a Python program,
perform calculations on the data, and thereafter read the data back to
the spreadsheet program? This is exactly what we will explain below
through an example. With this example, you should understand how easy
it is to combine Excel or LibreOffice with your own Python programs.

<h2>CSV files  <a name="___sec47"></a></h2>

The table of data in a spreadsheet can be saved in so-called CSV files,
where CSV stands for <em>comma separated values</em>.
The CSV file format is very simple:
each row in the spreadsheet table is a line in the file, and each cell
in the row is separated by a comma or some other specified
separation character.
CSV files can easily be read into Python programs, and the
table of
cell data can be stored in a nested list
(table, see the section ref{sec:basic:nestedlists}),
which can be processed as we desire.
The modified table of cell data can be written back to a CSV file and read into
the spreadsheet program for further processing.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 5:  A simple spreadsheet in LibreOffice. <a name="sec:io:fig1"></a> </p></center>
<p><img src="fig-files/spreadsheet1.png" align="bottom" width=400></p>
</center>

<p>
Figure <a href="#sec:io:fig1">5</a> shows a simple
spreadsheet in the LibreOffice program. The table contains \( 4\times 4 \)
cells, where the first row contains column headings and the first column contains
row headings. The remaining \( 3\times 3 \) subtable contains numbers that
we may compute with.
Let us save this spreadsheet to a file in the CSV format.
The complete file will typically look as follows:

<p>
<!-- begin verbatim block  txt-->
<pre><code>,&quot;year 1&quot;,&quot;year 2&quot;,&quot;year 3&quot;
&quot;person 1&quot;,651000,651000,651000
&quot;person 2&quot;,1100500,950100,340000
&quot;person 3&quot;,740000,780000,800000
</code></pre>
<!-- end verbatim block -->

<p>
Our primary task is now to load these data into a Python program,
compute the sum of each column, and write the data out again in the
CSV format.

<h2>Reading CSV files  <a name="___sec48"></a></h2>

We start with loading the data into a table, represented as
a nested list, with aid of the
<code>csv</code> module from Python's standard library.
This approach gives us complete control of all
details. Later, we will use more high-level <code>numpy</code> functionality
for accomplishing the same thing with less lines.

<p>
The <code>csv</code> module offers functionality for reading one line at a time
from a CSV file:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>infile = open('budget.csv', 'r')  # CSV file
import csv
table = []
for row in csv.reader(infile):
    table.append(row)
infile.close()
</code></pre>
<!-- end verbatim block -->
The <code>row</code> variable is a list of column values that are
read from the file by the <code>csv</code> module.
The three lines computing <code>table</code> can be condensed to one using
a list comprehension:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>table = [row for row in csv.reader(infile)]
</code></pre>
<!-- end verbatim block -->
We can easily print <code>table</code>,

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import pprint
pprint.pprint(table)
</code></pre>
<!-- end verbatim block -->
to see what the spreadsheet looks like
when it is represented as a nested list in a Python program:

<p>
<!-- begin verbatim block  ccq-->
<pre><code>[['', 'year 1', 'year 2', 'year 3'],
 ['person 1', '651000', '651000', '651000'],
 ['person 2', '1100500', '950100', '340000'],
 ['person 3', '740000', '780000', '800000']]
</code></pre>
<!-- end verbatim block -->
Observe now that all entries are surrounded by quotes, which means that
all entries are string (<code>str</code>) objects. This is a general rule:
the <code>csv</code> module reads all cells into string objects.
To compute with the numbers, we need to transform the string objects
to <code>float</code> objects. The transformation
should not be applied to the first row and first column, since the
cells here hold text.
The transformation from strings to numbers
therefore applies to the indices <code>r</code> and <code>c</code>
in <code>table</code> (<code>table[r][c]</code>), such that the row counter
<code>r</code> goes from 1 to <code>len(table)-1</code>,
and the column counter <code>c</code>
goes from 1 to <code>len(table[0])-1</code> (<code>len(table[0])</code> is
the length of the first row, assuming the lengths of all rows are
equal to the length of the first row).
The relevant Python code for this transformation task becomes

<p>
<!-- begin verbatim block  pycod-->
<pre><code> for r in range(1,len(table)):
    for c in range(1, len(table[0])):
        table[r][c] = float(table[r][c])
</code></pre>
<!-- end verbatim block -->
A <code>pprint.pprint(table)</code> statement after this transformation yields

<p>
<!-- begin verbatim block  ccq-->
<pre><code>[['', 'year 1', 'year 2', 'year 3'],
 ['person 1', 651000.0, 651000.0, 651000.0],
 ['person 2', 1100500.0, 950100.0, 340000.0],
 ['person 3', 740000.0, 780000.0, 800000.0]]
</code></pre>
<!-- end verbatim block -->
The numbers now have a decimal and no quotes, indicating
that the numbers are <code>float</code> objects and hence ready for mathematical
calculations.

<h2>Processing spreadsheet data  <a name="___sec49"></a></h2>

Let us perform a very simple calculation with <code>table</code>,
namely adding a final row
with the sum of the numbers in the columns:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>row = [0.0]*len(table[0])
row[0] = 'sum'
for c in range(1, len(row)):
    s = 0
    for r in range(1, len(table)):
        s += table[r][c]
    row[c] = s
</code></pre>
<!-- end verbatim block -->
As seen, we first create a list <code>row</code> consisting of zeros.
Then we insert a text in the first column, before we invoke a
loop over the numbers in the table and compute the sum of each column.
The <code>table</code> list now represents a spreadsheet with four columns and
five rows:

<p>
<!-- begin verbatim block  ccq-->
<pre><code>[['', 'year 1', 'year 2', 'year 3'],
 ['person 1', 651000.0, 651000.0, 651000.0],
 ['person 2', 1100500.0, 950100.0, 340000.0],
 ['person 3', 740000.0, 780000.0, 800000.0],
 ['sum', 2491500.0, 2381100.0, 1791000.0]]
</code></pre>
<!-- end verbatim block -->

<h2>Writing CSV files  <a name="___sec50"></a></h2>

Our final task is to write the modified <code>table</code> list
back to a CSV file so that the data can be loaded in a spreadsheet program.
The write task is done by the code segment

<p>
<!-- begin verbatim block  pycod-->
<pre><code>outfile = open('budget2.csv', 'w')
writer = csv.writer(outfile)
for row in table:
    writer.writerow(row)
outfile.close()
</code></pre>
<!-- end verbatim block -->
The <code>budget2.csv</code> looks like this:

<p>
<!-- begin verbatim block  txt-->
<pre><code>year 1,year 2,year 3
person 1,651000.0,651000.0,651000.0
person 2,1100500.0,950100.0,340000.0
person 3,740000.0,780000.0,800000.0
sum,2491500.0,2381100.0,1791000.0
</code></pre>
<!-- end verbatim block -->

<p>
The final step is to read <code>budget2.csv</code> into a spreadsheet.
The result is displayed in Figure <a href="#sec:io:fig2">6</a>
(in LibreOffice one must specify in the <em>Open</em> dialog that
the spreadsheet data are separated by commas, i.e., that the file
is in CSV format).

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 6:  A spreadsheet processed in a Python program and loaded back into LibreOffice. <a name="sec:io:fig2"></a> </p></center>
<p><img src="fig-files/spreadsheet2.png" align="bottom" width=400></p>
</center>

<p>
The complete program reading the <code>budget.csv</code> file, processing its
data, and writing the <code>budget2.csv</code> file can be found in
<a href="http://tinyurl.com/pwyasaa/files/rw_csw.py" target="_self"><tt>rw_csv.py</tt></a>.  With this example at
hand, you should be in a good position to combine spreadsheet programs
with your own Python programs.

<h3>Remark  <a name="___sec51"></a></h3>

You may wonder why we used the <code>csv</code> module to read and write CSV
files when such files have comma separated values, which we can
extract by splitting lines with respect to the comma (this technique
is used in the section <a href="#sec:files:stockprices">Example: Reading and plotting data recorded at specific dates</a> to read a CSV file):

<p>
<!-- begin verbatim block  pycod-->
<pre><code>infile = open('budget.csv', 'r')
for line in infile:
    row = line.split(',')
</code></pre>
<!-- end verbatim block -->
This works well for the present <code>budget.csv</code> file, but the technique
breaks down when a text in a cell contains a comma, for instance
<code>"Aug 8, 2007"</code>. The <code>line.split(',')</code> will split this cell text, while
the <code>csv.reader</code> functionality is smart enough to avoid splitting
text cells with a comma.

<h2>Representing number cells with Numerical Python arrays  <a name="___sec52"></a></h2>

Instead of putting the whole spreadsheet into a single nested list,
we can make a Python data structure more tailored to the data at hand.
What we have are two headers (for rows and columns, respectively) and
a subtable of numbers. The headers can be represented as lists of strings,
while the subtable could be a two-dimensional Numerical Python array.
The latter makes it easier to implement various mathematical operations
on the numbers. A dictionary can hold all the three items: two header
lists and one array. The relevant code for reading, processing, and
writing the data is shown below and can be found in the file
<a href="http://tinyurl.com/pwyasaa/files/rw_csv_numpy.py" target="_self"><tt>rw_csv_numpy.py</tt></a>:

<p>
<!-- begin verbatim block  pypro-->
<pre><code>infile = open('budget.csv', 'r')
import csv
table = [row for row in csv.reader(infile)]
infile.close()

# Convert subtable of numbers (string to float)
import numpy
subtable = [[float(c) for c in row[1:]] for row in table[1:]]

data = {'column headings': table[0][1:],
        'row headings': [row[0] for row in table[1:]],
        'array': numpy.array(subtable)}

# Add a new row with sums
data['row headings'].append('sum')
a = data['array']   # short form
data['column sum'] = [sum(a[:,c]) for c in range(a.shape[1])]

outfile = open('budget2.csv', 'w')
writer = csv.writer(outfile)
# Turn data dictionary into a nested list first (for easy writing)
table = a.tolist()   # transform array to nested list
table.append(data['column sum'])
table.insert(0, data['column headings'])
# Extend table with row headings (a new column)
[table[r+1].insert(0, data['row headings'][r])
 for r in range(len(table)-1)]
for row in table:
    writer.writerow(row)
outfile.close()
</code></pre>
<!-- end verbatim block -->
The code makes heavy use of list comprehensions, and the
transformation between a nested list, for file reading and writing,
and the <code>data</code> dictionary, for representing the data in the
Python program, is non-trivial. If you manage to understand every
line in this program, you have digested a lot of topics in
Python programming!

<h2>Using more high-level Numerical Python functionality  <a name="___sec53"></a></h2>

The previous program can be shortened significantly by applying
the <code>genfromtxt</code> function from Numerical Python:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import numpy as np
arr = np.genfromtxt('budget.csv', delimiter=',', dtype=str)

data = {'column headings': arr[0,1:].tolist(),
        'row headings': arr[1:,0].tolist(),
        'array': np.asarray(arr[1:,1:], dtype=np.float)}

data['row headings'].append('sum')
data['column sum'] = np.sum(data['array'], axis=1).tolist()
</code></pre>
<!-- end verbatim block -->
Doing a <code>repr(arr)</code> on the array returned from <code>genfromtxt</code>
results in

<p>
<!-- begin verbatim block  dat-->
<pre><code>array([['', '&quot;year 1&quot;', '&quot;year 2&quot;', '&quot;year 3&quot;'],
       ['&quot;person 1&quot;', '651000', '651000', '651000'],
       ['&quot;person 2&quot;', '1100500', '950100', '340000'],
       ['&quot;person 3&quot;', '740000', '780000', '800000']],
      dtype='|S10')
</code></pre>
<!-- end verbatim block -->
That is, the data in the CSV file are available as an array of
strings.  The code shows how we can easily use slices to extract the
row and column headings, convert the numbers to a floating-point array
for computations, compute the sums, and store various object in the
<code>data</code> dictionary. Then we may write a CSV file as described in the
previous example (see <a href="http://tinyurl.com/pwyasaa/files/rw_csv_numpy2.py" target="_self"><tt>rw_csv_numpy2.py</tt></a>) or we may take a different
approach and extend the <code>arr</code> array with an extra row and fill in the
row heading and the sums (see <a href="http://tinyurl.com/pwyasaa/files/rw_csv_numpy3.py" target="_self"><tt>rw_csv_numpy3.py</tt></a> for the complete code):

<p>
<!-- begin verbatim block  pycod-->
<pre><code>arr = np.genfromtxt('budget.csv', delimiter=',', dtype=str)

# Add row for sum of columns
arr.resize((arr.shape[0]+1, arr.shape[1]))
arr[-1,0] = '&quot;sum&quot;'
subtable = np.asarray(arr[1:-1,1:], dtype=np.float)
sum_row = np.sum(subtable, axis=1)
arr[-1,1:] = np.asarray(sum_row, dtype=str)

# numpy.savetxt writes table with a delimiter between entires
np.savetxt('budget2c.csv', arr, delimiter=',', fmt='%s')
</code></pre>
<!-- end verbatim block -->
Observe how we extract the numbers in <code>subtable</code>, compute with them,
and put the results back into the <code>arr</code> array as strings. The
<code>savetxt</code> function saves a two-dimensional array as a plain table in
a text file, here with
comma as delimiter. The function suffices in this example, none of
the approaches with <code>genfromtxt</code> and <code>savetxt</code> work with
column or row headings containing a comma. Then we need to use the
<code>csv</code> module.

<h1>Examples from analyzing DNA <a name="bioinf:DNAanalysis"></a></h1>

We shall here continue the bioinformatics applications started
in the document <a href="http://tcse6.on.net/funcif" target="_self">Functions and branching</a> <a href="#Langtangen_TCSE6_funcif">[1]</a>. Analysis of DNA sequences is
conveniently done in Python, much with the aid of lists, dictionaries,
<code>numpy</code> arrays, strings, and files. This will be illustrated
through a series of examples.

<h2>Computing frequencies <a name="bioinf:freqm"></a></h2>

Your genetic code is essentially the same from you are born until you
die, and the same in your blood and your brain.  Which genes that are
turned on and off make the difference between the cells. This
regulation of genes is orchestrated by an immensely complex mechanism,
which we have only started to understand. A central part of this
mechanism consists of molecules called transcription factors that
float around in the cell and attach to DNA, and in doing so turn
nearby genes on or off. These molecules bind preferentially to
specific DNA sequences, and this binding preference pattern can be
represented by a table of frequencies of given symbols at each
position of the pattern.  More precisely, each row in the table
corresponds to the bases A, C, G, and T, while column j reflects how
many times the base appears in position j in the DNA sequence.

<p>
For example, if our set of DNA sequences are
TAG, GGT, and GGG, the table becomes

<p>
<table border="1">
<thead>
<tr><th align="center">base</th> <th align="center"> 0  </th> <th align="center"> 1  </th> <th align="center"> 2  </th> </tr>
</thead>
<tbody>
<tr><td align="left">   A       </td> <td align="center">   0       </td> <td align="center">   1       </td> <td align="center">   0       </td> </tr>
<tr><td align="left">   C       </td> <td align="center">   0       </td> <td align="center">   0       </td> <td align="center">   0       </td> </tr>
<tr><td align="left">   G       </td> <td align="center">   2       </td> <td align="center">   2       </td> <td align="center">   2       </td> </tr>
<tr><td align="left">   T       </td> <td align="center">   1       </td> <td align="center">   0       </td> <td align="center">   1       </td> </tr>
</tbody>
</table>
<p>
From this table we can read that base A appears once in index 1 in the
DNA strings, base C does not appear at all, base G appears twice in
all positions, and base T appears once in the beginning and end of the
strings.

<p>
In the following we shall present different data structures to
hold such a table and different ways of computing them.
The table is known as a <em>frequency matrix</em> in bioinformatics
and this is the term used here too.

<h3>Separate frequency lists  <a name="___sec56"></a></h3>

Since we know that there are only four rows in the frequency matrix,
an obvious data structure would be four lists, each holding
a row. A function computing these lists may look like

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def freq_lists(dna_list):
    n = len(dna_list[0])
    A = [0]*n
    T = [0]*n
    G = [0]*n
    C = [0]*n
    for dna in dna_list:
        for index, base in enumerate(dna):
            if base == 'A':
                A[index] += 1
            elif base == 'C':
                C[index] += 1
            elif base == 'G':
                G[index] += 1
            elif base == 'T':
                T[index] += 1
    return A, C, G, T
</code></pre>
<!-- end verbatim block -->

<p>
We need to initialize the lists with the right length and a zero
for each element, since each list element is to be used as a counter.
Creating a list of length <code>n</code> with object <code>x</code> in all positions
is done by <code>[x]*n</code>. Finding the proper length is here carried out by
inspecting the length of the first element in <code>dna_list</code>, the list of
all DNA strings to be counted, assuming
that all elements in this list have the same length.

<p>
In the <code>for</code> loop we apply the <code>enumerate</code> function, which is used
to extract both the element value <em>and</em> the element index when
iterating over a sequence. For example,
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; for index, base in enumerate(['t', 'e', 's', 't']):
...   print index, base
...
0 t
1 e
2 s
3 t
</code></pre>
<!-- end verbatim block -->

<p>
Here is a test,
<!-- begin verbatim block  pycod-->
<pre><code>dna_list = ['GGTAG', 'GGTAC', 'GGTGC']
A, C, G, T = freq_lists(dna_list)
print A
print C
print G
print T
</code></pre>
<!-- end verbatim block -->
with output
<!-- begin verbatim block  dat-->
<pre><code>[0, 0, 0, 2, 0]
[0, 0, 0, 0, 2]
[3, 3, 0, 1, 1]
[0, 0, 3, 0, 0]
</code></pre>
<!-- end verbatim block -->

<h3>Nested list  <a name="___sec57"></a></h3>

The frequency matrix can also be represented as a nested list <code>M</code>
such that <code>M[i][j]</code> is the frequency of base <code>i</code> in position <code>j</code>
in the set of DNA strings. Here <code>i</code> is an integer, where 0 corresponds to A,
1 to T, 2 to G, and 3 to C. The frequency is the number of times
base <code>i</code> appears in position <code>j</code> in a set of DNA strings.
Sometimes this number is divided by the number of DNA strings in
the set so that the frequency is between 0 and 1. Note that all
the DNA strings must have the same length.

<p>
The simplest way to make a nested list is to insert the
<code>A</code>, <code>C</code>, <code>G</code>, and <code>T</code> lists into another list:
<!-- begin verbatim block  pycod-->
<pre><code>&gt;&gt;&gt; frequency_matrix = [A, C, G, T]
&gt;&gt;&gt; frequency_matrix[2][3]
2
&gt;&gt;&gt; G[3]  # same element
2
</code></pre>
<!-- end verbatim block -->

<p>
Alternatively, we can illustrate how to compute this type of nested
list directly:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def freq_list_of_lists_v1(dna_list):
    # Create empty frequency_matrix[i][j] = 0
    # i=0,1,2,3 corresponds to A,T,G,C
    # j=0,...,length of dna_list[0]
    frequency_matrix = [[0 for v in dna_list[0]] for x in 'ACGT']

    for dna in dna_list:
      for index, base in enumerate(dna):
          if base == 'A':
              frequency_matrix[0][index] +=1
          elif base == 'C':
              frequency_matrix[1][index] +=1
          elif base == 'G':
              frequency_matrix[2][index] +=1
          elif base == 'T':
              frequency_matrix[3][index] +=1

    return frequency_matrix
</code></pre>
<!-- end verbatim block -->

<p>
As in the case with individual lists we need to initialize all elements
in the nested list to zero.

<p>
A call and printout,
<!-- begin verbatim block  pycod-->
<pre><code>dna_list = ['GGTAG', 'GGTAC', 'GGTGC']
frequency_matrix = freq_list_of_lists_v1(dna_list)
print frequency_matrix
</code></pre>
<!-- end verbatim block -->
results in
<!-- begin verbatim block  dat-->
<pre><code>[[0, 0, 0, 2, 0], [0, 0, 0, 0, 2], [3, 3, 0, 1, 1], [0, 0, 3, 0, 0]]
</code></pre>
<!-- end verbatim block -->

<h3>Dictionary for more convenient indexing  <a name="___sec58"></a></h3>

The series of <code>if</code> tests in the Python function <code>freq_list_of_lists_v1</code>
are somewhat cumbersome,
especially if we want to extend the code to other bioinformatics problems
where the alphabet is larger. What we want is a mapping from <code>base</code>,
which is a character, to the corresponding index 0, 1, 2, or 3.
A Python dictionary may represent such mappings:
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; base2index = {'A': 0, 'C': 1, 'G': 2, 'T': 3}
&gt;&gt;&gt; base2index['G']
2
</code></pre>
<!-- end verbatim block -->
With the <code>base2index</code> dictionary we do not need the series of
<code>if</code> tests and the alphabet <code>'ATGC'</code> could be much larger
without affecting the length of the code:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def freq_list_of_lists_v2(dna_list):
    frequency_matrix = [[0 for v in dna_list[0]] for x in 'ACGT']
    base2index = {'A': 0, 'C': 1, 'G': 2, 'T': 3}
    for dna in dna_list:
        for index, base in enumerate(dna):
            frequency_matrix[base2index[base]][index] += 1

    return frequency_matrix
</code></pre>
<!-- end verbatim block -->

<h3>Numerical Python array  <a name="___sec59"></a></h3>

As long as each sublist in a list of lists has the same length, a
list of lists can be replaced by a Numerical Python (<code>numpy</code>) array.
Processing of such arrays is often much more efficient than
processing of the nested list data structure.
To initialize a two-dimensional <code>numpy</code> array we need to know its
size, here 4 times <code>len(dna_list[0])</code>. Only the first line in the function
<code>freq_list_of_lists_v2</code> needs to be changed in order to utilize
a <code>numpy</code> array:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import numpy as np

def freq_numpy(dna_list):
    frequency_matrix = np.zeros((4, len(dna_list[0])), dtype=np.int)
    base2index = {'A': 0, 'C': 1, 'G': 2, 'T': 3}
    for dna in dna_list:
        for index, base in enumerate(dna):
            frequency_matrix[base2index[base]][index] += 1

    return frequency_matrix
</code></pre>
<!-- end verbatim block -->

<p>
The resulting <code>frequency_matrix</code> object can be indexed as
<code>[b][i]</code> or <code>[b,i]</code>, with integers <code>b</code> and <code>i</code>. Typically, <code>b</code> will
be something line <code>base2index['C']</code>.

<h3>Dictionary of lists  <a name="___sec60"></a></h3>

Instead of going from a character to an integer index via
<code>base2index</code>, we may prefer to index <code>frequency_matrix</code> by the base name
and the position index directly, like in <code>['C'][14]</code>.
This is the most natural syntax for a user of the
frequency matrix.  The relevant Python data structure is then a
dictionary of lists. That is, <code>frequency_matrix</code> is a dictionary with
keys <code>'A'</code>, <code>'C'</code>, <code>'G'</code>, and <code>'T'</code>. The value for each key is a
list. Let us now also extend the flexibility such that <code>dna_list</code> can
have DNA strings of different lengths. The lists in <code>frequency_list</code>
will have lengths equal to the longest DNA string.  A relevant
function is

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def freq_dict_of_lists_v1(dna_list):
    n = max([len(dna) for dna in dna_list])
    frequency_matrix = {
        'A': [0]*n,
        'C': [0]*n,
        'G': [0]*n,
        'T': [0]*n,
        }
    for dna in dna_list:
        for index, base in enumerate(dna):
            frequency_matrix[base][index] += 1

    return frequency_matrix
</code></pre>
<!-- end verbatim block -->

<p>
Running the test code

<p>
<!-- begin verbatim block  pycod-->
<pre><code>frequency_matrix = freq_dict_of_lists_v1(dna_list)
import pprint   # for nice printout of nested data structures
pprint.pprint(frequency_matrix)
</code></pre>
<!-- end verbatim block -->
results in the output
<!-- begin verbatim block  dat-->
<pre><code>{'A': [0, 0, 0, 2, 0],
 'C': [0, 0, 0, 0, 2],
 'G': [3, 3, 0, 1, 1],
 'T': [0, 0, 3, 0, 0]}
</code></pre>
<!-- end verbatim block -->

<p>
The initialization of <code>frequency_matrix</code> in the above code can
be made more compact by using a dictionary comprehension:
<!-- begin verbatim block  pycod-->
<pre><code>dict = {key: value for key in some_sequence}
</code></pre>
<!-- end verbatim block -->
In our example we set
<!-- begin verbatim block  pycod-->
<pre><code>frequency_matrix = {base: [0]*n for base in 'ACGT'}
</code></pre>
<!-- end verbatim block -->
Adopting this construction in the <code>freq_dict_of_lists_v1</code> function
leads to a slightly more compact version:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def freq_dict_of_lists_v2(dna_list):
    n = max([len(dna) for dna in dna_list])
    frequency_matrix = {base: [0]*n for base in 'ACGT'}
    for dna in dna_list:
        for index, base in enumerate(dna):
            frequency_matrix[base][index] += 1

    return frequency_matrix
</code></pre>
<!-- end verbatim block -->

<p>
As an additional comment on computing the maximum length of the DNA
strings can be made as there are several alternative ways of doing
this.  The classical use of <code>max</code> is to apply it to a list as done
above:
<!-- begin verbatim block  pycod-->
<pre><code>n = max([len(dna) for dna in dna_list])
</code></pre>
<!-- end verbatim block -->
However, for very long lists it is possible to avoid the memory demands
of storing the result of the list comprehension, i.e., the list of
lengths. Instead <code>max</code> can work with the lengths as they are computed:
<!-- begin verbatim block  pycod-->
<pre><code>n = max(len(dna) for dna in dna_list)
</code></pre>
<!-- end verbatim block -->
It is also possible to write
<!-- begin verbatim block  pycod-->
<pre><code>n = max(dna_list, key=len)
</code></pre>
<!-- end verbatim block -->
Here, <code>len</code> is applied to each element in <code>dna_list</code>, and the
maximum of the resulting values is returned.

<h3>Dictionary of dictionaries  <a name="___sec61"></a></h3>

The dictionary of lists data structure can alternatively be replaced
by a dictionary of dictionaries object, often just called a dict of
dicts object. That is, <code>frequency_matrix[base]</code> is a dictionary with
key <code>i</code> and value equal to the added number of occurrences of <code>base</code> in
<code>dna[i]</code> for all <code>dna</code> strings in the list <code>dna_list</code>.  The indexing
<code>frequency_matrix['C'][i]</code> and the values are exactly as in the last
example; the only difference is whether <code>frequency_matrix['C']</code> is a
list or dictionary.

<p>
Our function working with <code>frequency_matrix</code> as a dict of dicts
is written as

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def freq_dict_of_dicts_v1(dna_list):
    n = max([len(dna) for dna in dna_list])
    frequency_matrix = {base: {index: 0 for index in range(n)}
                        for base in 'ACGT'}
    for dna in dna_list:
        for index, base in enumerate(dna):
            frequency_matrix[base][index] += 1

    return frequency_matrix
</code></pre>
<!-- end verbatim block -->

<h3>Using dictionaries with default values  <a name="___sec62"></a></h3>

The manual initialization of each subdictionary to zero,
<!-- begin verbatim block  pycod-->
<pre><code>    frequency_matrix = {base: {index: 0 for index in range(n)}
                        for base in 'ACGT'}
</code></pre>
<!-- end verbatim block -->
can be simplified by using a dictionary with default values for any
key. The construction <code>defaultdict(lambda: obj)</code>
makes a dictionary with <code>obj</code> as default value.
This construction simplifies the previous function a bit:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>from collections import defaultdict

def freq_dict_of_dicts_v2(dna_list):
    n = max([len(dna) for dna in dna_list])
    frequency_matrix = {base: defaultdict(lambda: 0)
                        for base in 'ACGT'}
    for dna in dna_list:
        for index, base in enumerate(dna):
            frequency_matrix[base][index] += 1

    return frequency_matrix
</code></pre>
<!-- end verbatim block -->

<p>
<b>Remark.</b>
Dictionary comprehensions were new in Python 2.7 and 3.1, but can be
simulated in earlier versions by making (key, value) tuples via
list comprehensions. A dictionary comprehension
<!-- begin verbatim block  pycod-->
<pre><code>d = {key: value for key in sequence}
</code></pre>
<!-- end verbatim block -->
is then constructed as
<!-- begin verbatim block  pycod-->
<pre><code>d = dict([(key, value) for key in sequence])
</code></pre>
<!-- end verbatim block -->

<h3>Using arrays and vectorization  <a name="___sec63"></a></h3>

The <code>frequency_matrix</code> dict of lists for can easily be
changed to a dict of <code>numpy</code> arrays: just replace the initialization
<code>[0]*n</code> by <code>np.zeros(n, dtype=np.int)</code>. The indexing remains the same:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def freq_dict_of_arrays_v1(dna_list):
    n = max([len(dna) for dna in dna_list])
    frequency_matrix = {base: np.zeros(n, dtype=np.int)
                        for base in 'ACGT'}
    for dna in dna_list:
        for index, base in enumerate(dna):
            frequency_matrix[base][index] += 1

    return frequency_matrix
</code></pre>
<!-- end verbatim block -->

<p>
Having <code>frequency_matrix[base]</code> as a <code>numpy</code> array instead of a list
does not give any immediate advantage, as the storage and CPU time is
about the same. The loop over the <code>dna</code> string and the associated
indexing is what consumes all the CPU time.  However, the <code>numpy</code>
arrays provide a potential for increasing efficiency through
vectorization, i.e., replacing the element-wise operations on <code>dna</code>
and <code>frequency_matrix[base]</code> by operations on the entire arrays at
once.

<p>
Let us use the interactive Python shell to
explore the possibilities of vectorization.
We first convert the string to a <code>numpy</code> array of characters:
<!-- begin verbatim block  pycod-->
<pre><code>&gt;&gt;&gt; dna = 'ACAT'
&gt;&gt;&gt; dna = np.array(dna, dtype='c')
&gt;&gt;&gt; dna
array(['A', 'C', 'A', 'T'],
      dtype='|S1')
</code></pre>
<!-- end verbatim block -->
For a given base, say A, we can in one vectorized operation find
which locations in <code>dna</code> that contain <code>A</code>:
<!-- begin verbatim block  pycod-->
<pre><code>&gt;&gt;&gt; b = dna == 'A'
&gt;&gt;&gt; b
array([ True, False,  True, False], dtype=bool)
</code></pre>
<!-- end verbatim block -->
By converting <code>b</code> to an integer array <code>i</code> we can
update the frequency counts
for all indices by adding <code>i</code> to <code>frequency_matrix['A']</code>:
<!-- begin verbatim block  pycod-->
<pre><code>&gt;&gt;&gt; i = np.asarray(b, dtype=np.int)
&gt;&gt;&gt; i
array([1, 0, 1, 0])
&gt;&gt;&gt; frequency_matrix['A'] = frequency_matrix['A'] + i
</code></pre>
<!-- end verbatim block -->
This recipe can be repeated for all bases:
<!-- begin verbatim block  pycod-->
<pre><code>    for dna in dna_list:
        dna = np.array(dna, dtype='c')
        for base in 'ACGT':
            b = dna == base
            i = np.asarray(b, dtype=np.int)
            frequency_matrix[base] = frequency_matrix[base] + i
</code></pre>
<!-- end verbatim block -->

<p>
It turns out that we do not need to convert the boolean array <code>b</code>
to an integer array <code>i</code>, because doing arithmetics with <code>b</code> directly
is possible: <code>False</code> is interpreted as 0 and <code>True</code> as 1 in arithmetic
operations.  We can also use
the <code>+=</code> operator to update all elements of <code>frequency_matrix[base]</code>
directly, without first computing the sum of two arrays
<code>frequency_matrix[base] + i</code> and then assigning this result to
<code>frequency_matrix[base]</code>.
Collecting all these ideas in one function yields the code

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def freq_dict_of_arrays_v2(dna_list):
    n = max([len(dna) for dna in dna_list])
    frequency_matrix = {base: np.zeros(n, dtype=np.int)
                        for base in 'ACGT'}
    for dna in dna_list:
        dna = np.array(dna, dtype='c')
        for base in 'ACCT':
            frequency_matrix[base] += dna == base

    return frequency_matrix
</code></pre>
<!-- end verbatim block -->
This vectorized function runs almost 10 times as fast as the
(scalar) counterpart <code>freq_list_of_arrays_v1</code>!

<p>
<!-- memory mapped files? -->

<h2>Analyzing the frequency matrix <a name="bioinf:freq:analysis"></a></h2>

Having built a frequency matrix out of a collection of DNA strings, it
is time to use it for analysis.
The short DNA strings that a frequency matrix is built out of, is
typically a set of substrings of a larger DNA sequence, which shares
some common purpose. An example of this is to have a set of substrings
that serves as a kind of anchors/magnets at which given molecules
attach to DNA and perform biological functions (like turning genes on
or off). With the frequency matrix constructed from a limited set of
known anchor locations (substrings), we can now scan for other similar
substrings that have the potential to perform the same function. The
simplest way to do this is to first determine the most typical
substring according to the frequency matrix, i.e., the substring having
the most frequent nucleotide at each position. This is referred to as
the consensus string of the frequency matrix. We can then look for
occurrences of the consensus substring in a larger DNA sequence, and
consider these occurrences as likely candidates for serving the same
function (e.g., as anchor locations for molecules).

<p>
For instance,
given three substrings ACT, CCA and AGA, the frequency matrix
would be (list of lists, with rows corresponding to A, C, G, and T):
<!-- begin verbatim block  dat-->
<pre><code>[[2, 0, 2]
 [1, 2, 0]
 [0, 1, 0]
 [0, 0, 1]]
</code></pre>
<!-- end verbatim block -->
We see that for position 0,
which corresponds to the left-most column in the table, the symbol A has the
highest frequency (2). The maximum frequencies for the other positions
are seen to be C for position 1, and A for position 2. The consensus
string is therefore ACA.  Note that the consensus string does not need to be
equal to any of the substrings that formed the basis of the frequency
matrix (this is indeed the case for the above example).

<h3>List of lists frequency matrix  <a name="___sec65"></a></h3>

Let <code>frequency_matrix</code> be a list of lists. For each position <code>i</code> we
run through the rows in the frequency matrix and keep track of the
maximum frequency value and the corresponding letter. If two or
more letters have the same frequency value we use a dash to
indicate that this position in the consensus string is undetermined.

<p>
The following function computes the consensus string:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def find_consensus_v1(frequency_matrix):
    base2index = {'A': 0, 'C': 1, 'G': 2, 'T': 3}
    consensus = ''
    dna_length = len(frequency_matrix[0])

    for i in range(dna_length):  # loop over positions in string
        max_freq = -1            # holds the max freq. for this i
        max_freq_base = None     # holds the corresponding base

        for base in 'ATGC':
            if frequency_matrix[base2index[base]][i] &gt; max_freq:
                max_freq = frequency_matrix[base2index[base]][i]
                max_freq_base = base
            elif frequency_matrix[base2index[base]][i] == max_freq:
                max_freq_base = '-' # more than one base as max

        consensus += max_freq_base  # add new base with max freq
    return consensus
</code></pre>
<!-- end verbatim block -->

<p>
Since this code requires <code>frequency_matrix</code> to be a list of lists
we should insert a test and raise an exception if the
type is wrong:
<!-- begin verbatim block  pycod-->
<pre><code>def find_consensus_v1(frequency_matrix):
    if isinstance(frequency_matrix, list) and \ 
       isinstance(frequency_matrix[0], list):
        pass # right type
    else:
        raise TypeError('frequency_matrix must be list of lists')
    ...
</code></pre>
<!-- end verbatim block -->

<h3>Dict of dicts frequency matrix  <a name="___sec66"></a></h3>

How must the <code>find_consensus_v1</code> function be altered if <code>frequency_matrix</code>
is a dict of dicts?

<ol>
 <li> The <code>base2index</code> dict is no longer needed.</li>
 <li> Access of sublist, <code>frequency_matrix[0]</code>, to test for type and
    length of the strings, must be replaced
    by <code>frequency_matrix['A']</code>.</li>
</ol>

The updated function becomes

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def find_consensus_v3(frequency_matrix):
    if isinstance(frequency_matrix, dict) and \ 
       isinstance(frequency_matrix['A'], dict):
        pass # right type
    else:
        raise TypeError('frequency_matrix must be dict of dicts')

    consensus = ''
    dna_length = len(frequency_matrix['A'])

    for i in range(dna_length):  # loop over positions in string
        max_freq = -1            # holds the max freq. for this i
        max_freq_base = None     # holds the corresponding base

        for base in 'ACGT':
            if frequency_matrix[base][i] &gt; max_freq:
                max_freq = frequency_matrix[base][i]
                max_freq_base = base
            elif frequency_matrix[base][i] == max_freq:
                max_freq_base = '-' # more than one base as max

        consensus += max_freq_base  # add new base with max freq
    return consensus
</code></pre>
<!-- end verbatim block -->

<p>
Here is a test:
<!-- begin verbatim block  pycod-->
<pre><code>frequency_matrix = freq_dict_of_dicts_v1(dna_list)
pprint.pprint(frequency_matrix)
print find_consensus_v3(frequency_matrix)
</code></pre>
<!-- end verbatim block -->
with output
<!-- begin verbatim block  dat-->
<pre><code>{'A': {0: 0, 1: 0, 2: 0, 3: 2, 4: 0},
 'C': {0: 0, 1: 0, 2: 0, 3: 0, 4: 2},
 'G': {0: 3, 1: 3, 2: 0, 3: 1, 4: 1},
 'T': {0: 0, 1: 0, 2: 3, 3: 0, 4: 0}}
Consensus string: GGTAC
</code></pre>
<!-- end verbatim block -->

<p>
Let us try <code>find_consensus_v3</code> with the dict of defaultdicts
as input (<code>freq_dicts_of_dicts_v2</code>). The code runs fine, but
the output string is just <code>G</code>!
The reason is that <code>dna_length</code> is 1, and therefore that the length of
the <code>A</code> dict in <code>frequency_matrix</code> is 1.
Printing out <code>frequency_matrix</code> yields
<!-- begin verbatim block  pycod-->
<pre><code>{'A': defaultdict(X, {3: 2}),
 'C': defaultdict(X, {4: 2}),
 'G': defaultdict(X, {0: 3, 1: 3, 3: 1, 4: 1}),
 'T': defaultdict(X, {2: 3})}
</code></pre>
<!-- end verbatim block -->
where our <code>X</code> is a short form for text like
<!-- begin verbatim block  pycod-->
<pre><code>`&lt;function &lt;lambda&gt; at 0xfaede8&gt;`
</code></pre>
<!-- end verbatim block -->
We see that the length of a defaultdict will only count the nonzero
entries. Hence, to use a defaultdict our function must get the length of the DNA string to
build as an extra argument:
<!-- begin verbatim block  pycod-->
<pre><code>def find_consensus_v4(frequency_matrix, dna_length):
    ...
</code></pre>
<!-- end verbatim block -->

<p>
<a href="#bioinf:exer:freq:fargs">Exercise 16: Allow different types for a function argument</a> suggests to make a unified
<code>find_consensus</code> function which works with all of the different
representations of <code>frequency_matrix</code> that we have used.

<p>
The functions making and using the frequency matrix are found
in the file <a href="http://tinyurl.com/pwyasaa/files/freq.py" target="_self"><tt>freq.py</tt></a>.

<h2>Finding base frequencies <a name="bioinf:basefreq"></a></h2>

DNA consists of four molecules called nucleotides, or bases, and can
be represented as a string of the letters A, C, G, and T. But this
does not mean that all four nucleotides need to be similarly
frequent. Are some nucleotides more frequent than others, say in
yeast, as represented by the first chromosome of yeast? Also, DNA is
really not a single thread, but two threads wound together.  This
wounding is based on an A from one thread binding to a T of the other
thread, and C binding to G (that is, A will only bind with T, not with
C or G).  Could this fact force groups of the four symbol frequencies
to be equal?  The answer is that the A-T and G-C binding does not in principle
force certain frequencies to be equal, but in practice they usually
become so because of evolutionary factors related to this pairing.

<p>
Our first programming task now is to compute the frequencies of the
bases A, C, G, and T. That is, the number of times each base occurs in
the DNA string, divided by the length of the string.  For example, if
the DNA string is ACGGAAA, the length is 7, A appears 4 times with
frequency 4/7, C appears once with frequency 1/7, G appears twice with
frequency 2/7, and T does not appear so the frequency is 0.

<p>
From a coding perspective we may create a function for counting how
many times A, C, G, and T appears in the string and then another
function for computing the frequencies. In both cases we want
dictionaries such that we can index with the character and get the
count or the frequency out.
Counting is done by

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def get_base_counts(dna):
    counts = {'A': 0, 'T': 0, 'G': 0, 'C': 0}
    for base in dna:
        counts[base] += 1
    return counts
</code></pre>
<!-- end verbatim block -->
This function can then be used to compute the base frequencies:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def get_base_frequencies_v1(dna):
    counts = get_base_counts(dna)
    return {base: count*1.0/len(dna)
            for base, count in counts.items()}
</code></pre>
<!-- end verbatim block -->
Since we learned at the end of the document <a href="http://tcse6.on.net/funcif" target="_self">Functions and branching</a> <a href="#Langtangen_TCSE6_funcif">[1]</a> that
<code>dna.count(base)</code> was much faster than the various manual
implementations of counting, we can write a faster and simpler
function for computing all the base frequencies:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def get_base_frequencies_v2(dna):
        return {base: dna.count(base)/float(len(dna))
                for base in 'ATGC'}
</code></pre>
<!-- end verbatim block -->
A little test,

<p>
<!-- begin verbatim block  pycod-->
<pre><code>dna = 'ACCAGAGT'
frequencies = get_base_frequencies_v2(dna)

def format_frequencies(frequencies):
    return ', '.join(['%s: %.2f' % (base, frequencies[base])
                      for base in frequencies])

print &quot;Base frequencies of sequence '%s':\n%s&quot; % \ 
      (dna, format_frequencies(frequencies))
</code></pre>
<!-- end verbatim block -->
gives the result
<!-- begin verbatim block  dat-->
<pre><code>Base frequencies of sequence 'ACCAGAGT':
A: 0.38, C: 0.25, T: 0.12, G: 0.25
</code></pre>
<!-- end verbatim block -->
The <code>format_frequencies</code> function was made for nice printout of
the frequencies with 2 decimals. The one-line code is an effective
combination of a dictionary, list comprehension, and the
<code>join</code> functionality. The latter is used to get a comma correctly
inserted between the items in the result. Lazy programmers would
probably just do a <code>print frequencies</code> and live with the
curly braces in the output and (in general) 16 disturbing decimals.

<p>
We can try the frequency computation on real data. The file
<!-- begin verbatim block -->
<pre><code>http://hplgit.github.com/bioinf-py/data/yeast_chr1.txt
</code></pre>
<!-- end verbatim block -->
contains the DNA for yeast. We can download this file from
the Internet by
<!-- begin verbatim block  pycod-->
<pre><code>urllib.urlretrieve(url, filename=name_of_local_file)
</code></pre>
<!-- end verbatim block -->
where <code>url</code> is the Internet address of the file and <code>name_of_local_file</code>
is a string containing the name of the file on the computer where the
file is downloaded.
To avoid repeated downloads when the program is run multiple times,
we insert a test on whether the local file exists or not. The
call <code>os.path.isfile(f)</code> returns <code>True</code> if a file with name <code>f</code> exists
in the current working folder.

<p>
The appropriate download code then becomes

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import urllib, os
urlbase = 'http://hplgit.github.com/bioinf-py/data/'
yeast_file = 'yeast_chr1.txt'
if not os.path.isfile(yeast_file):
    url = urlbase + yeast_file
    urllib.urlretrieve(url, filename=yeast_file)
</code></pre>
<!-- end verbatim block -->
A copy of the file on the Internet is now in the current working folder
under the name <code>yeast_chr1.txt</code>.
(See the section <a href="#sec:files:urllib">How to access web pages in programs</a> for
more information about \emp{urllib} and downloading files from
the Internet.)

<p>
The <code>yeast_chr1.txt</code> files contains the DNA string split over many lines.
We therefore need to read the lines in this file, strip each line to
remove the trailing newline, and join all the stripped lines to
recover the DNA string:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def read_dnafile_v1(filename):
    lines = open(filename, 'r').readlines()
    # Remove newlines in each line (line.strip()) and join
    dna = ''.join([line.strip() for line in lines])
    return dna
</code></pre>
<!-- end verbatim block -->

<p>
As usual, an alternative programming solution can be devised:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def read_dnafile_v2(filename):
    dna = ''
    for line in open(filename, 'r'):
        dna += line.strip()
    return dna

dna = read_dnafile_v2(yeast_file)
yeast_freq = get_base_frequencies_v2(dna)
print &quot;Base frequencies of yeast DNA (length %d):\n%s&quot; % \ 
      (len(dna), format_frequencies(yeast_freq))
</code></pre>
<!-- end verbatim block -->
The output becomes
<!-- begin verbatim block  dat-->
<pre><code>Base frequencies of yeast DNA (length 230208):
A: 0.30, C: 0.19, T: 0.30, G: 0.20
</code></pre>
<!-- end verbatim block -->

<p>
The varying frequency of different nucleotides in DNA is referred to
as nucleotide bias. The nucleotide bias varies between organisms, and
have a range of biological implications. For many organisms the
nucleotide bias has been highly optimized through evolution and
reflects characteristics of the organisms and their environments, for
instance the typical temperature the organism is adapted to.

<p>
<!-- This shows that A and T appears in the yeast DNA with 50 percent higher -->
<!-- probability than C and G. -->

<p>
The functions computing base frequencies are available
in the file <a href="http://tinyurl.com/pwyasaa/files/basefreq.py" target="_self"><tt>basefreq.py</tt></a>.

<h2>Translating genes into proteins <a name="bioinf:gene2protein"></a></h2>

An important usage of DNA is for cells to store information on their
arsenal of proteins. Briefly, a gene is, in essence, a region of the
DNA, consisting of several coding parts (called exons), interspersed
by non-coding parts (called introns).  The coding parts are
concatenated to form a string called mRNA, where also occurrences of
the letter T in the coding parts are substituted by a U. A triplet of
mRNA letters code for a specific amino acid, which are the building
blocks of proteins. Consecutive triplets of letters in mRNA define a
specific sequence of amino acids, which amounts to a certain protein.

<p>
Here is an example of using the mapping from DNA to proteins to create
the Lactase protein (LPH), using the DNA sequence of the Lactase gene
(LCT) as underlying code. An important functional property of LPH is
in digesting Lactose, which is found most notably in milk. Lack of the
functionality of LPH leads to digestive problems referred to as
lactose intolerance. Most mammals and humans lose their expression of
LCT and therefore their ability to digest milk when they stop
receiving breast milk.

<p>
The file
<!-- begin verbatim block -->
<pre><code>http://hplgit.github.com/bioinf-py/doc/src/data/genetic_code.tsv
</code></pre>
<!-- end verbatim block -->
contains a mapping of genetic codes to amino acids.
The file format looks like
<!-- begin verbatim block  dat-->
<pre><code>UUU     F       Phe     Phenylalanine
UUC     F       Phe     Phenylalanine
UUA     L       Leu     Leucine
UUG     L       Leu     Leucine
CUU     L       Leu     Leucine
CUC     L       Leu     Leucine
CUA     L       Leu     Leucine
CUG     L       Leu     Leucine
AUU     I       Ile     Isoleucine
AUC     I       Ile     Isoleucine
AUA     I       Ile     Isoleucine
AUG     M       Met     Methionine (Start)
</code></pre>
<!-- end verbatim block -->
The first column is the genetic code (triplet in mRNA),
while the other columns represent
various ways of expressing the corresponding amino acid:
a 1-letter symbol, a 3-letter name, and the full name.

<p>
Downloading the <code>genetic_code.tsv</code> file can be done by
this robust function:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def download(urlbase, filename):
    if not os.path.isfile(filename):
        url = urlbase + filename
        try:
            urllib.urlretrieve(url, filename=filename)
        except IOError as e:
            raise IOError('No Internet connection')
        # Check if downloaded file is an HTML file, which
        # is what github.com returns if the URL is not existing
        f = open(filename, 'r')
        if 'DOCTYPE html' in f.readline():
            raise IOError('URL %s does not exist' % url)
</code></pre>
<!-- end verbatim block -->

<p>
We want to make a dictionary of this file that maps the code (first
column) on to the 1-letter name (second column):

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def read_genetic_code_v1(filename):
    infile = open(filename, 'r')
    genetic_code = {}
    for line in infile:
        columns = line.split()
        genetic_code[columns[0]] = columns[1]
    return genetic_code
</code></pre>
<!-- end verbatim block -->

<p>
Downloading the file, reading it, and making the dictionary are done
by

<p>
<!-- begin verbatim block  pycod-->
<pre><code>urlbase = 'http://hplgit.github.com/bioinf-py/data/'
genetic_code_file = 'genetic_code.tsv'
download(urlbase, genetic_code_file)
code = read_genetic_code_v1(genetic_code_file)
</code></pre>
<!-- end verbatim block -->

<p>
Not surprisingly, the <code>read_genetic_code_v1</code> can be made much shorter
by collecting the first two columns as list of 2-lists and then
converting the 2-lists to key-value pairs in a dictionary:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def read_genetic_code_v2(filename):
    return dict([line.split()[0:2] for line in open(filename, 'r')])
</code></pre>
<!-- end verbatim block -->

<p>
Creating a mapping of the code onto all the three variants of the amino
acid name is
also of interest. For example, we would like to make look ups like
<code>['CUU']['3-letter']</code> or <code>['CUU']['amino acid']</code>. This requires
a dictionary of dictionaries:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def read_genetic_code_v3(filename):
    genetic_code = {}
    for line in open(filename, 'r'):
        columns = line.split()
        genetic_code[columns[0]] = {}
        genetic_code[columns[0]]['1-letter']   = columns[1]
        genetic_code[columns[0]]['3-letter']   = columns[2]
        genetic_code[columns[0]]['amino acid'] = columns[3]
    return genetic_code
</code></pre>
<!-- end verbatim block -->
An alternative way of writing the last function is

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def read_genetic_code_v4(filename):
    genetic_code = {}
    for line in open(filename, 'r'):
        c = line.split()
        genetic_code[c[0]] = {
            '1-letter': c[1], '3-letter': c[2], 'amino acid': c[3]}
    return genetic_code
</code></pre>
<!-- end verbatim block -->

<p>
To form mRNA, we need to grab the exon regions (the coding parts) of
the lactase gene.  These regions are substrings of the lactase gene
DNA string, corresponding to the start and end positions of the exon
regions.  Then we must replace T by U, and combine all the substrings
to build the mRNA string.

<p>
Two straightforward subtasks are to load the lactase gene and its exon
positions into variables.  The file <code>lactase_gene.txt</code>, at the same
Internet location as the other files, stores the lactase gene. The file
has the same format as <code>yeast_chr1.txt</code>. Using the <code>download</code> function
and the previously shown <code>read_dnafile_v1</code>, we can easily load the
data in the file into the string <code>lactase_gene</code>.

<p>
The exon regions are described in a file <code>lactase_exon.tsv</code>, also
found at the same Internet site as the other files. The file is easily
transferred to your computer by calling <code>download</code>.  The file format
is very simple in that each line holds the start and end positions of
an exon region:
<!-- begin verbatim block  dat-->
<pre><code>0       651
3990    4070
7504    7588
13177   13280
15082   15161
</code></pre>
<!-- end verbatim block -->
We want to have this information available in a list of (start, end)
tuples. The following function does the job:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def read_exon_regions_v1(filename):
    positions = []
    infile = open(filename, 'r')
    for line in infile:
        start, end = line.split()
        start, end = int(start), int(end)
        positions.append((start, end))
    infile.close()
    return positions
</code></pre>
<!-- end verbatim block -->
Readers favoring compact code will appreciate this alternative version
of the function:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def read_exon_regions_v2(filename):
    return [tuple(int(x) for x in line.split())
            for line in open(filename, 'r')]

lactase_exon_regions = read_exon_regions_v2(lactase_exon_file)
</code></pre>
<!-- end verbatim block -->

<p>
For simplicity's sake, we shall consider mRNA as the concatenation of exons,
although in reality, additional base pairs are added to each end.
Having the lactase gene as a string and the exon regions as a list of
(start, end) tuples, it is straightforward to extract the regions
as substrings, replace T by U, and add all the substrings together:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def create_mRNA(gene, exon_regions):
    mrna = ''
    for start, end in exon_regions:
        mrna += gene[start:end].replace('T','U')
    return mrna

mrna = create_mRNA(lactase_gene, lactase_exon_regions)
</code></pre>
<!-- end verbatim block -->

<p>
We would like to store the mRNA string in a file, using the same
format as <code>lactase_gene.txt</code> and <code>yeast_chr1.txt</code>, i.e.,
the string is split on multiple lines with, e.g., 70 characters per line.
An appropriate function doing this is

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def tofile_with_line_sep_v1(text, filename, chars_per_line=70):
    outfile = open(filename, 'w')
    for i in xrange(0, len(text), chars_per_line):
        start = i
        end = start + chars_per_line
        outfile.write(text[start:end] + '\n')
    outfile.close()
</code></pre>
<!-- end verbatim block -->

<p>
It might be convenient to have a separate folder for files that we create.
Python has good support for testing if a folder exists, and if not,
make a folder:
<!-- begin verbatim block  pycod-->
<pre><code>output_folder = 'output'
if not os.path.isdir(output_folder):
    os.mkdir(output_folder)
filename = os.path.join(output_folder, 'lactase_mrna.txt')
tofile_with_line_sep_v1(mrna, filename)
</code></pre>
<!-- end verbatim block -->
Python's term for folder is directory, which explains why <code>isdir</code> is
the function name for testing on a folder existence. Observe
especially that the combination of a folder and a filename is done via
<code>os.path.join</code> rather than just inserting a forward slash, or backward
slash on Windows: <code>os.path.join</code> will insert the right slash, forward
or backward, depending on the current operating system.

<p>
Occasionally, the output folder is nested, say
<!-- begin verbatim block  pycod-->
<pre><code>output_folder = os.path.join('output', 'lactase')
</code></pre>
<!-- end verbatim block -->
In that case, <code>os.mkdir(output_folder)</code> may fail because the
intermediate folder <code>output</code> is missing. Making a folder and also all
missing intermediate folders is done by <code>os.makedirs</code>.  We can write a
more general file writing function that takes a folder name and file
name as input and writes the file.  Let us also add some flexibility
in the file format: one can either write a fixed number of characters
per line, or have the string on just one long line. The latter version
is specified through <code>chars_per_line='inf'</code> (for infinite number of
characters per line).  The flexible file writing function then becomes

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def tofile_with_line_sep_v2(text, foldername, filename,
                            chars_per_line=70):
    if not os.path.isdir(foldername):
        os.makedirs(foldername)
    filename = os.path.join(foldername, filename)
    outfile = open(filename, 'w')

    if chars_per_line == 'inf':
        outfile.write(text)
    else:
        for i in xrange(0, len(text), chars_per_line):
            start = i
            end = start + chars_per_line
            outfile.write(text[start:end] + '\n')
    outfile.close()
</code></pre>
<!-- end verbatim block -->

<p>
To create the protein, we replace the triplets of the mRNA strings
by the corresponding 1-letter name as specified in the
<code>genetic_code.tsv</code> file.

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def create_protein(mrna, genetic_code):
    protein = ''
    for i in xrange(len(mrna)/3):
        start = i * 3
        end = start + 3
        protein += genetic_code[mrna[start:end]]
    return protein

genetic_code = read_genetic_code_v1('genetic_code.tsv')
protein = create_protein(mrna, genetic_code)
tofile_with_line_sep_v2(protein, 'output',
</code></pre>
<!-- end verbatim block -->

<p>
Unfortunately, this first try to simulate the translation process is
incorrect. The problem is that the translation always begins with the
amino acid Methionine, code AUG, and ends when one of the stop codons
is met. We must thus check for the correct start and stop criteria.
A fix is

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def create_protein_fixed(mrna, genetic_code):
    protein_fixed = ''
    trans_start_pos = mrna.find('AUG')
    for i in range(len(mrna[trans_start_pos:])/3):
        start = trans_start_pos + i*3
        end = start + 3
        amino = genetic_code[mrna[start:end]]
        if amino == 'X':
            break
        protein_fixed += amino
    return protein_fixed

protein = create_protein_fixed(mrna, genetic_code)
tofile_with_line_sep_v2(protein, 'output',
                        'lactase_protein_fixed.txt', 70)

print '10 last amino acids of the correct lactase protein: ', \ 
      protein[-10:]
print 'Lenght of the correct protein: ', len(protein)
</code></pre>
<!-- end verbatim block -->
The output, needed below for comparison, becomes
<!-- begin verbatim block  dat-->
<pre><code>10 last amino acids of the correct lactase protein:  QQELSPVSSF
Lenght of the correct protein:  1927
</code></pre>
<!-- end verbatim block -->

<h2>Some humans can drink milk, while others cannot <a name="bioinf:lactase:milk"></a></h2>

One type of lactose intolerance is called <em>Congenital lactase deficiency</em>.
This is a rare genetic disorder that causes lactose intolerance from birth,
and is particularly common in Finland. The disease is caused by a mutation of
the base in position 30049 (0-based) of the lactase gene, a mutation from T to
A. Our goal is to check what happens to the protein if this base is mutated.
This is a simple task using the previously developed tools:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def congential_lactase_deficiency(
    lactase_gene,
    genetic_code,
    lactase_exon_regions,
    output_folder=os.curdir,
    mrna_file=None,
    protein_file=None):

    pos = 30049
    mutated_gene = lactase_gene[:pos] + 'A' + lactase_gene[pos+1:]
    mutated_mrna = create_mRNA(mutated_gene, lactase_exon_regions)

    if mrna_file is not None:
        tofile_with_line_sep_v2(
            mutated_mrna, output_folder, mrna_file)

    mutated_protein = create_protein_fixed(
        mutated_mrna, genetic_code)

    if protein_file:
        tofile_with_line_sep_v2(
            mutated_protein, output_folder, protein_file)
    return mutated_protein

mutated_protein = congential_lactase_deficiency(
    lactase_gene, genetic_code, lactase_exon_regions,
    output_folder='output',
    mrna_file='mutated_lactase_mrna.txt',
    protein_file='mutated_lactase_protein.txt')

print '10 last amino acids of the mutated lactase protein:', \ 
      mutated_protein[-10:]
print 'Lenght of the mutated lactase protein:', \ 
      len(mutated_protein)
</code></pre>
<!-- end verbatim block -->

<p>
The output, to be compared with the non-mutated gene above, is now
<!-- begin verbatim block  dat-->
<pre><code>10 last amino acids of the mutated lactase protein: GFIWSAASAA
Lenght of the mutated lactase protein: 1389
</code></pre>
<!-- end verbatim block -->
As we can see, the translation stops prematurely, creating a much smaller
protein, which will not have the required characteristics of the lactase
protein.

<p>
A couple of mutations in a region for LCT located in front of LCT (actually in
the introns of another gene) is the reason for the common lactose intolerance.
That is, the one that sets in for adults only. These mutations control the
expression of the LCT gene, i.e., whether that the gene is turned on or off.
Interestingly, different mutations have evolved in different regions of the
world, e.g., Africa and Northern Europe. This is an example of convergent
evolution: the acquisition of the same biological trait in unrelated
lineages. The prevalence of lactose intolerance varies widely, from around 5%
in northern Europe, to close to 100% in south-east Asia.

<p>
The functions analyzing the lactase gene are found
in the file <a href="http://tinyurl.com/pwyasaa/files/genes2proteins.py" target="_self"><tt>genes2proteins.py</tt></a>.

<h1>Summary  <a name="___sec70"></a></h1>

<h2>Chapter topics  <a name="___sec71"></a></h2>

<h3>Dictionaries  <a name="___sec72"></a></h3>

Array or list-like objects with text or other (fixed-valued) Python
objects as indices are called dictionaries. They are very useful for
storing general collections of objects in a single data structure.
The table below displays some of the most important dictionary
operations.

<p>
<table border="1">
<thead>
<tr><th align="center">                               Construction                              </th> <th align="center">                                 Meaning                                 </th> </tr>
</thead>
<tbody>
<tr><td align="left">   <code>a = {}</code>                                                          </td> <td align="left">   initialize an empty dictionary                                               </td> </tr>
<tr><td align="left">   <code>a = {'point': [0,0.1], 'value': 7}</code>                              </td> <td align="left">   initialize a dictionary                                                      </td> </tr>
<tr><td align="left">   <code>a = dict(point=[2,7], value=3)</code>                                  </td> <td align="left">   initialize a dictionary w/string keys                                        </td> </tr>
<tr><td align="left">   <code>a.update(b)</code>                                                     </td> <td align="left">   add/update key-value pairs from <code>b</code> in <code>a</code>             </td> </tr>
<tr><td align="left">   <code>a.update(key1=value1, key2=value2)</code>                              </td> <td align="left">   add/update key-value pairs in <code>a</code>                                 </td> </tr>
<tr><td align="left">   <code>a['hide'] = True</code>                                                </td> <td align="left">   add new key-value pair to <code>a</code>                                     </td> </tr>
<tr><td align="left">   <code>a['point']</code>                                                      </td> <td align="left">   get value corresponding to key <code>point</code>                            </td> </tr>
<tr><td align="left">   <code>for key in a:</code>                                                   </td> <td align="left">   loop over keys in unknown order                                              </td> </tr>
<tr><td align="left">   <code>for key in sorted(a):</code>                                           </td> <td align="left">   loop over keys in alphabetic order                                           </td> </tr>
<tr><td align="left">   <code>'value' in a</code>                                                    </td> <td align="left">   <code>True</code> if string <code>value</code> is a key in <code>a</code>    </td> </tr>
<tr><td align="left">   <code>del a['point']</code>                                                  </td> <td align="left">   delete a key-value pair from <code>a</code>                                  </td> </tr>
<tr><td align="left">   <code>list(a.keys())</code>                                                  </td> <td align="left">   list of keys                                                                 </td> </tr>
<tr><td align="left">   <code>list(a.values())</code>                                                </td> <td align="left">   list of values                                                               </td> </tr>
<tr><td align="left">   <code>len(a)</code>                                                          </td> <td align="left">   number of key-value pairs in <code>a</code>                                  </td> </tr>
<tr><td align="left">   <code>isinstance(a, dict)</code>                                             </td> <td align="left">   is <code>True</code> if <code>a</code> is a dictionary                       </td> </tr>
</tbody>
</table>

<h3>Strings  <a name="___sec73"></a></h3>

Some of the most useful functionalities in a string object <code>s</code> are
listed below.

<p>
<b>Split</b> the string into substrings separated by <code>delimiter</code>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>words = s.split(delimiter)
</code></pre>
<!-- end verbatim block -->
<b>Join</b> elements in a list of strings:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>newstring = delimiter.join(words[i:j])
</code></pre>
<!-- end verbatim block -->
Extract a <b>substring</b>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>substring = s[2:n-4]
</code></pre>
<!-- end verbatim block -->
<b>Replace</b> a substring <code>substr</code> by new a string <code>replacement</code>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>s_new = s.replace(substr, replacement)
</code></pre>
<!-- end verbatim block -->
Check if a substring <b>is contained</b> within another string:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>if 'some text' in s:
    ...
</code></pre>
<!-- end verbatim block -->
<b>Find</b> the index where some text starts:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>index = s.find(text)
if index == -1:
    print 'Could not find &quot;%s&quot; in &quot;%s&quot; (text, s)
else:
    substring = s[index:]  # strip off chars before text
</code></pre>
<!-- end verbatim block -->
<b>Extend</b> a string:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>s += another_string     # append at the end
s = another_string + s  # append at the beginning
</code></pre>
<!-- end verbatim block -->
Check if a string contains <b>whitespace only</b>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>if s.isspace():
   ...
</code></pre>
<!-- end verbatim block -->
Note: you cannot change the characters in a string like you can change
elements in a list (a string is in this sense like a tuple). You have to
make a new string:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; filename = 'myfile1.txt'
&gt;&gt;&gt; filename[6] = '2'
Traceback (most recent call last):
  ...
TypeError: 'str' object does not support item assignment
&gt;&gt;&gt; filename.replace('1', '2')
'myfile2.txt'
&gt;&gt;&gt; filename[:6] + '2' + filename[7:]   # 'myfile' + '2' + '.txt'
'myfile2.txt'
</code></pre>
<!-- end verbatim block -->

<h3>Downloading Internet files  <a name="___sec74"></a></h3>

Internet files can be downloaded if we know their URL:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import urllib
url = 'http://www.some.where.net/path/thing.html'
urllib.urlretrieve(url, filename='thing.html')
</code></pre>
<!-- end verbatim block -->
The downloaded information is put in the local file <code>thing.html</code>
in the current working folder.
Alternatively, we can open the URL as a file object:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>webpage = urllib.urlopen(url)
</code></pre>
<!-- end verbatim block -->
HTML files are often messy to interpret by string operations.

<h3>Terminology  <a name="___sec75"></a></h3>

The important computer science topics in this document are

<ul>
  <li> dictionaries</li>
  <li> strings and string operations</li>
  <li> CSV files</li>
  <li> HTML files</li>
</ul>

<h2>Example: A file database <a name="sec:files:sumex"></a></h2>

<!-- names: www.funnyname.com/anonymous.html -->
<!-- Ola Nordmann -->
<!-- Chan Siu Ming -->
<!-- Ivan Horvat -->
<!-- Jan Met De Pet -->
<!-- Fred Nurk -->
<!-- Joe Bloggs -->
<!-- I. U. Ajn -->
<!-- Matti Meikalainen (ala skal ha a med todler) -->
<!-- Jean Dupont -->
<!-- Otto Normalverbraucher -->
<!-- Erika Mustermann -->
<!-- Hans Meier -->
<!-- Israel Israeli -->
<!-- Jona Jonsdottir (med akksent over hver o) -->
<!-- Si Polan -->
<!-- Mario Rossi -->
<!-- Nanashi No Gombe -->
<!-- Jonas Jonaitis -->
<!-- Jan Kowalski -->
<!-- Vasya Pupkin -->
<!-- Jovan Petrovic -->
<!-- Juan del Pueblo -->
<!-- Juan dela Cruz -->
<!-- Sipho Nkosi -->
<!-- Nguoi La -->

<h3>Problem  <a name="___sec77"></a></h3>

We have a file containing information about the courses that students have
taken.
The file format consists of blocks with student data, where each
block starts with the student's name (<code>Name:</code>), followed by
the courses that the student has taken. Each course line starts with the
name of the course, then comes the semester when the exam was taken,
then the size of the course in terms of credit points,
and finally the grade is listed (letters <code>A</code> to <code>F</code>).
Here is an example of a file with three student entries:

<p>
<!-- begin verbatim block  dat-->
<pre><code>Name: John Doe
Astronomy                         2003 fall 10 A
Introductory Physics              2003 fall 10 C
Calculus I                        2003 fall 10 A
Calculus II                       2004 spring 10 B
Linear Algebra                    2004 spring 10 C
Quantum Mechanics I               2004 fall 10 A
Quantum Mechanics II              2005 spring 10 A
Numerical Linear Algebra          2004 fall 5 E
Numerical Methods                 2004 spring 20 C

Name: Jan Modaal
Calculus I                        2005 fall 10 A
Calculus II                       2006 spring 10 A
Introductory C++ Programming      2005 fall 15 D
Introductory Python Programming   2006 spring 5 A
Astronomy                         2005 fall 10 A
Basic Philosophy                  2005 fall 10 F

Name: Kari Nordmann
Introductory Python Programming   2006 spring 5 A
Astronomy                         2005 fall 10 D
</code></pre>
<!-- end verbatim block -->

<p>
Our problem consists of reading this file into a dictionary <code>data</code>
with the
student name as key and a list of courses as value.
Each element in the list of courses is a dictionary holding the
course name, the semester, the credit points, and the grade.
A value in the <code>data</code> dictionary may look as

<p>
<!-- begin verbatim block  pycod-->
<pre><code>'Kari Nordmann': [{'credit': 5,
                   'grade': 'A',
                   'semester': '2006 spring',
                   'title': 'Introductory Python Programming'},
                  {'credit': 10,
                   'grade': 'D',
                   'semester': '2005 fall',
                   'title': 'Astronomy'}],
</code></pre>
<!-- end verbatim block -->
Having the <code>data</code> dictionary, the next task is to print out the
average grade of each student.

<h3>Solution  <a name="___sec78"></a></h3>

We divide the problem into two major tasks: loading the file data into
the <code>data</code> dictionary, and computing the average grades.
These two tasks are naturally placed in two functions.

<p>
We need to have a strategy for reading the file and interpreting the
contents. It will be natural to read the file line by line, and for
each line check if this is a line containing a new student's name,
a course information line, or a blank line.
In the latter case we jump to the next pass in the loop. When a
new student name is encountered, we initialize a new entry in the
<code>data</code> dictionary to an empty list. In the case of a line about
a course, we must interpret the contents on that line, which we
postpone a bit.

<p>
We can now sketch the algorithm described above in terms of some
unfinished Python code, just to get the overview:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def load(studentfile):
    infile = open(studentfile, 'r')
    data = {}
    for line in infile:
        i = line.find('Name:')
        if i != -1:
            # line contains 'Name:', extract the name.
            ...
        elif line.isspace():     # Blank line?
            continue             # Yes, go to next loop iteration.
        else:
            # This must be a course line, interpret the line.
            ...
    infile.close()
    return data
</code></pre>
<!-- end verbatim block -->

<p>
If we find <code>'Name:'</code> as a substring in <code>line</code>, we must extract
the name. This can be done by the substring
<code>line[i+5:]</code>. Alternatively, we can split the line with respect to
colon and strip off the first word:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>words = line.split(':')
name = ' '.join(words[1:])
</code></pre>
<!-- end verbatim block -->
We have chosen the former strategy of extracting the name as a substring
in the final program.

<p>
Each course line is naturally split into words for extracting
information:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>words = line.split()
</code></pre>
<!-- end verbatim block -->
The name of the course consists of a number of words, but we do not know
how many.
Nevertheless, we know that the final words contain the semester, the credit
points, and the grade. We can hence count from the right and extract
information, and when we are finished with the semester information,
the rest of the <code>words</code> list holds the words in the name of the course.
The code goes as follows:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>grade = words[-1]
credit = int(words[-2])
semester = ' '.join(words[-4:-2])
course_name = ' '.join(words[:-4])
data[name].append({'title':    course_name,
                   'semester': semester,
                   'credit':   credit,
                   'grade':    grade})
</code></pre>
<!-- end verbatim block -->
This code is a good example of the usefulness of split and join
operations when extracting information from a text.

<p>
Now to the second task of computing the average grade. Since the grades
are letters we cannot compute with them. A natural way to proceed is to
convert the letters to numbers, compute the average number, and then
convert that number back to a letter.
Conversion between letters and numbers is easily represented by a dictionary:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>grade2number = {'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1, 'F': 0}
</code></pre>
<!-- end verbatim block -->
To convert from numbers to grades, we construct the inverse dictionary:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>number2grade = {}
for grade in grade2number:
    number2grade[grade2number[grade]] = grade
</code></pre>
<!-- end verbatim block -->
In the computation of the average grade we should use a weighted
sum such that larger courses count more than smaller courses.
The weighted mean value of a set of numbers \( r_i \) with weights \( w_i \),
\( i=0,\ldots,n-1 \), is given by

$$
\begin{equation*} {\sum_{i=0}^{n-1} w_ir_i\over\sum_{i=0}^{n-1} w_i}\tp\end{equation*}
$$

This weighted mean value must then be rounded to the nearest integer,
which can be used as key in <code>number2grade</code> to find the corresponding
grade expressed as a letter.
The weight \( w_i \) is naturally taken as the number of credit points
in the course with grade \( r_i \).
The whole process is performed by the following function:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def average_grade(data, name):
    sum = 0; weights = 0
    for course in data[name]:
        weight = course['credit']
        grade  = course['grade']
        sum += grade2number[grade]*weight
        weights += weight
    avg = sum/float(weights)
    return number2grade[round(avg)]
</code></pre>
<!-- end verbatim block -->
The complete code is found in the file
<a href="http://tinyurl.com/pwyasaa/files/student.py" target="_self"><tt>students.py</tt></a>.
Running this program gives the following output of the average grades:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>John Doe: B
Kari Nordmann: C
Jan Modaal: C
</code></pre>
<!-- end verbatim block -->

<p>
One feature of the <code>students.py</code> code is that the output of the names
are sorted after the last name. How can we accomplish that?
A straight <code>for name in data</code> loop will visit the keys in an unknown
(random) order. To visit the keys in alphabetic order, we must
use

<p>
<!-- begin verbatim block  pycod-->
<pre><code>for name in sorted(data):
</code></pre>
<!-- end verbatim block -->
This default sort will sort with respect to the first character in
the <code>name</code> strings. We want a sort according to the last part of
the name. A tailored sort function can then be written (see
ref{sec:basic:ex28} for an introduction to tailored
sort functions). In this function we
extract the last word in the names and compare them:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def sort_names(name1, name2):
    last_name1 = name1.split()[-1]
    last_name2 = name2.split()[-1]
    if last_name1 &lt; last_name2:
        return -1
    elif last_name1 &gt; last_name2:
        return 1
    else:
        return 0
</code></pre>
<!-- end verbatim block -->
We can now pass on <code>sort_names</code> to the <code>sorted</code> function to
get a sequence that is sorted with respect to the last word in the students'
names:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>for name in sorted(data, sort_names):
    print '%s: %s' % (name, average_grade(data, name))
</code></pre>
<!-- end verbatim block -->

<h1>Exercises <a name="sec:files:exercises"></a></h1>

<!-- --- begin exercise --- -->

<h2>Exercise 1: Make a dictionary from a table <a name="sec:files:ex2b:basic"></a></h2>

The file <a href="http://tinyurl.com/pwyasaa/files/constants.txt" target="_self"><tt>src/files/constants.txt</tt></a> contains a table of the values and
the dimensions of some fundamental constants from physics.  We want to
load this table into a dictionary <code>constants</code>, where the keys are the
names of the constants. For example, <code>constants['gravitational
constant']</code> holds the value of the gravitational constant
(\( 6.67259\cdot 10^{-11} \)) in Newton's law of gravitation.  Make a
function that reads and interprets the text in the file, and
finally returns the dictionary.
Filename: <code>fundamental_constants.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 2: Explore syntax differences: lists vs. dicts <a name="sec:files:ex2"></a></h2>

Consider this code:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>t1 = {}
t1[0] = -5
t1[1] = 10.5
</code></pre>
<!-- end verbatim block -->
Explain why the lines above work fine while the ones below do not:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>t2 = []
t2[0] = -5
t2[1] = 10.5
</code></pre>
<!-- end verbatim block -->
What must be done in the last code snippet to make it work properly?
Filename: <code>list_vs_dict.py</code>.

<p>
<!-- best for teaching, not students -->

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 3: Use string operations to improve a program <a name="sec:files:ex17"></a></h2>

Consider the program <code>density.py</code> from the section <a href="#sec:files:dict:density">Example: File data in dictionaries</a>.  One problem we face when implementing
this program is that the name of the substance can contain one or two
words, and maybe more words in a more comprehensive table.  The
purpose of this exercise is to use string operations to shorten the
code and make it more general.

<p>
<b>a)</b>
Make a Python function that lets <code>substance</code> consist of all the
words but the last,
using the <code>join</code> method in string objects to combine the words.

<p>
<b>b)</b>
Observe that all the densities start in the same column.
Write an alternative function that makes use of
substring indexing to divide <code>line</code> into two parts.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Remember to strip the first part such that, e.g.,
the density of ice is obtained as <code>densities['ice']</code> and not
<code>densities['ice         ']</code>.

<p>
<!-- --- end hint in exercise --- -->

<p>
<b>c)</b>
Make a test function that calls the two other functions and
tests that they produce the same result.

<p>
Filename: <code>density_improved.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 4: Interpret output from a program <a name="sec:files:ex13"></a></h2>

The program <a href="http://tinyurl.com/pwyasaa/funcif/lnsum.py" target="_self"><tt>src/funcif/lnsum.py</tt></a>
produces, among other things, this output:

<p>
<!-- begin verbatim block  ccq-->
<pre><code>epsilon: 1e-04, exact error: 8.18e-04, n=55
epsilon: 1e-06, exact error: 9.02e-06, n=97
epsilon: 1e-08, exact error: 8.70e-08, n=142
epsilon: 1e-10, exact error: 9.20e-10, n=187
epsilon: 1e-12, exact error: 9.31e-12, n=233
</code></pre>
<!-- end verbatim block -->
Redirect the output to a file (by <code>python lnsum.py > file</code>).
Write a Python program that reads the file and extracts
the numbers corresponding to <code>epsilon</code>, <code>exact error</code>,
and <code>n</code>. Store the numbers in three arrays and plot
<code>epsilon</code> and the <code>exact error</code> versus <code>n</code>.
Use a logarithmic scale on the \( y \) axis.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
The function <code>semilogy</code> is
an alternative to <code>plot</code> and gives logarithmic scale on \( y \) axis.

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>read_error.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 5: Make a dictionary <a name="sec:files:ex2b"></a></h2>

Based on the stars data in ref{sec:basic:ex28},
make a dictionary where the keys contain the names of the stars
and the values correspond to the luminosity.
Filename: <code>stars_data_dict1.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 6: Make a nested dictionary <a name="sec:files:ex2c"></a></h2>

Store the data about stars from ref{sec:basic:ex28}
in a nested dictionary such that we can look up the
distance, the apparent brightness, and the luminosity of a star with
name <code>N</code> by

<p>
<!-- begin verbatim block  pycod-->
<pre><code>stars[N]['distance']
stars[N]['apparent brightness']
stars[N]['luminosity']
</code></pre>
<!-- end verbatim block -->
Filename: <code>stars_data_dict2.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 7: Make a nested dictionary from a file <a name="sec:files:ex2d:nested"></a></h2>

The file <a href="http://tinyurl.com/pwyasaa/files/human_evolution.txt" target="_self"><tt>src/files/human_evolution.txt</tt></a> holds information about
various human species and their height, weight, and brain volume.
Make a program that reads this file and stores the tabular data in
a nested dictionary <code>humans</code>. The keys in <code>humans</code> correspond
to the specie name (e.g., <code>homo erectus</code>), and the values are
dictionaries with keys for <code>height</code>, <code>weight</code>, <code>brain volume</code>,
and <code>when</code> (the latter for when the specie lived).
For example, <code>humans['homo neanderthalensis']['mass']</code> should
equal <code>'55-70'</code>. Let the program write out the <code>humans</code>
dictionary in a nice tabular form similar to that in the file.
Filename: <code>humans.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 8: Make a nested dictionary from a file <a name="sec:files:ex2d:nested2"></a></h2>

The viscosity \( \mu \) of gases depends on the temperature.
For some gases the following formula is relevant:

$$ \mu (T) = \mu_0\frac{T_0-C}{T+C}\left(\frac{T}{T_0}\right)^{1.5},$$

where the values of the constants \( C \), \( T_0 \), and \( \mu_0 \) are
found in the file
<a href="http://tinyurl.com/pwyasaa/files/viscosity_of_gases.txt" target="_self"><tt>src/files/viscosity_of_gases.dat</tt></a>. The temperature is measured in Kelvin.

<p>
<b>a)</b>
Load the file into a nested dictionary <code>mu_data</code> such that we can
look up \( C \), \( T_0 \), and \( \mu_0 \) for a gas with name <code>name</code> by
<code>mu_data[name][X]</code>, where <code>X</code> is <code>'C'</code> for \( C \),
<code>'T_0'</code> for \( T_0 \), and <code>'mu_0'</code> for \( \mu_0 \).

<p>
<b>b)</b>
Make a function <code>mu(T, gas, mu_data)</code> for computing \( \mu(T) \) for a
gas with name <code>gas</code> (according to the file) and information about
constants \( C \), \( T_0 \), and \( \mu_0 \) in <code>mu_data</code>.

<p>
<b>c)</b>
Plot \( \mu(T) \) for air, carbon dioxide, and hydrogen with
\( T\in [223, 373] \).

<p>
Filename: <code>viscosity_of_gases.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 9: Compute the area of a triangle <a name="sec:files:ex2d"></a></h2>

The purpose of this exercise is to write
an <code>area</code> function as in ref{sec:basic:ex25},
but now we assume that the vertices of the triangle is stored in
a dictionary and not a list. The keys in the dictionary correspond to
the vertex number (1, 2, or 3) while the values are 2-tuples with the
\( x \) and \( y \) coordinates of the vertex. For example,
in a triangle with vertices \( (0,0) \), \( (1,0) \), and \( (0,2) \) the
<code>vertices</code> argument becomes

<p>
<!-- begin verbatim block  ccq-->
<pre><code>{1: (0,0), 2: (1,0), 3: (0,2)}
</code></pre>
<!-- end verbatim block -->
Filename: <code>area_triangle_dict.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 10: Compare data structures for polynomials <a name="sec:files:ex16"></a></h2>

Write a code snippet that uses both a list and a dictionary to
represent the polynomial \( -\frac{1}{2} + 2x^{100} \).
Print the list and the dictionary, and use them
to evaluate the polynomial for \( x=1.05 \).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
You can apply the <code>poly1</code>
and <code>poly2</code> functions from the section <a href="#sec:files:poly">Example: Polynomials as dictionaries</a>).

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>poly_repr.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 11: Compute the derivative of a polynomial <a name="sec:files:ex3"></a></h2>

A polynomial can be represented by a dictionary as explained
in the section <a href="#sec:files:poly">Example: Polynomials as dictionaries</a>.
Write a function <code>diff</code> for differentiating such a polynomial.
The <code>diff</code> function takes the polynomial as a dictionary argument
and returns the dictionary representation
of the derivative.
Here is an example of
the use of the function <code>diff</code>:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; p = {0: -3, 3: 2, 5: -1}    # -3 + 2*x**3 - x**5
&gt;&gt;&gt; diff(p)                     # should be 6*x**2 - 5*x**4
{2: 6, 4: -5}
</code></pre>
<!-- end verbatim block -->

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Recall the formula for differentiation of polynomials:

$$
\begin{equation}
{d\over dx}\sum_{j=0}^n c_jx^j = \sum_{j=1}^{n} jc_jx^{j-1}\tp
\tag{1}
\end{equation}
$$

This means that the coefficient of the \( x^{j-1} \) term in the derivative
equals \( j \) times the coefficient of \( x^j \) term of the original polynomial.
With <code>p</code> as the polynomial dictionary and <code>dp</code>
as the dictionary representing the derivative, we then have
<code>dp[j-1] = j*p[j]</code> for <code>j</code> running over all keys in <code>p</code>,
except when <code>j</code> equals 0.

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>poly_diff.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 12: Specify functions on the command line <a name="sec:basic:ex10"></a></h2>

Explain what the following two code snippets do and give an example of how
they can be used.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Read about the <code>StringFunction</code> tool
in the document <a href="http://tcse6.on.net/input" target="_self">User input and error handling</a> <a href="#Langtangen_TCSE6_input">[2]</a>
and about a variable number of keyword
arguments in the document <a href="http://tcse6.on.net/varargs" target="_self">Variable number of function arguments in Python</a> <a href="#Langtangen_TCSE6_varargs">[3]</a>.

<p>
<!-- --- end hint in exercise --- -->

<p>
<b>a)</b>
<!-- begin verbatim block  pycod-->
<pre><code>import sys
from scitools.StringFunction import StringFunction
parameters = {}
for prm in sys.argv[4:]:
    key, value = prm.split('=')
    parameters[key] = eval(value)
f = StringFunction(sys.argv[1], independent_variables=sys.argv[2],
                   **parameters)
var = float(sys.argv[3])
print f(var)
</code></pre>
<!-- end verbatim block -->

<p>
<b>b)</b>
<!-- begin verbatim block  pycod-->
<pre><code>import sys
from scitools.StringFunction import StringFunction
f = eval('StringFunction(sys.argv[1], ' + \ 
         'independent_variables=sys.argv[2], %s)' % \ 
         (', '.join(sys.argv[4:])))
var = float(sys.argv[3])
print f(var)
</code></pre>
<!-- end verbatim block -->

<p>
Filename: <code>cml_functions.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 13: Interpret function specifications <a name="sec:basic:ex10b"></a></h2>

To specify arbitrary functions \( f(x_1,x_2,\ldots; p_1, p_2, \ldots) \)
with independent variables \( x_1, x_2, \ldots \) and a set of
parameters \( p_1, p_2, \ldots \),
we allow the following syntax on the command line or in
a file:

<p>
<!-- begin verbatim block  ccq-->
<pre><code>&lt;expression&gt; is function of &lt;list1&gt; with parameter &lt;list2&gt;
</code></pre>
<!-- end verbatim block -->
where <code><expression></code> denotes the function formula,
<code><list1></code> is a comma-separated list of the independent variables,
and <code><list2></code> is a comma-separated list of name=value parameters. The part
<code>with parameters <list2></code> is omitted if there are no parameters.
The names of the independent variables and the parameters can be
chosen freely as long as the names can be used as Python variables.
Here are four different examples of what we can specify on the
command line using this syntax:

<p>
<!-- begin verbatim block  ccq-->
<pre><code>sin(x) is a function of x
sin(a*y) is a function of y with parameter a=2
sin(a*x-phi) is a function of x with parameter a=3, phi=-pi
exp(-a*x)*cos(w*t) is a function of t with parameter a=1,w=pi,x=2
</code></pre>
<!-- end verbatim block -->
Create a Python function that takes such function specifications as input
and returns an appropriate <code>StringFunction</code> object.
This object must be created from the function expression and the list
of independent variables and parameters. For example, the last
function specification above leads to the following <code>StringFunction</code>
creation:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>f = StringFunction('exp(-a*x)*cos(w*t)',
                   independent_variables=['t'],
                   a=1, w=pi, x=2)
</code></pre>
<!-- end verbatim block -->

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Use string operations to extract the various parts of the string.
For example, the expression can be split out by calling
<code>split('is a function of')</code>.
Typically, you need to extract <code><expression></code>, <code><list1></code>,
and <code><list2></code>, and create a string like

<p>
<!-- begin verbatim block  pycod-->
<pre><code>StringFunction(&lt;expression&gt;, independent_variables=[&lt;list1&gt;],
               &lt;list2&gt;)
</code></pre>
<!-- end verbatim block -->
and sending it to <code>eval</code> to create the object.

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>text2func.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 14: Compare average temperatures in cities <a name="sec:files:ex8"></a></h2>

The tarfile <a href="http://tinyurl.com/pwyasaa/misc/city_temp.tar.gz" target="_self"><tt>src/misc/city_temp.tar.gz</tt></a> contains a set of files with
temperature data for a large number of cities around the world. The
files are in text format with four columns, containing the month
number, the date, the year, and the temperature, respectively.
Missing temperature observations are represented by the value \( -99 \).
The mapping between the names of the text files and the names of the
cities are defined in an HTML file <code>citylistWorld.htm</code>.

<p>
<b>a)</b>
Write a function that can read the <code>citylistWorld.htm</code>
file and create a dictionary with mapping between city and filenames.

<p>
<b>b)</b>
Write a function that takes this dictionary and a city name
as input, opens the corresponding text file, and loads the data
into an appropriate data structure (dictionary of arrays and city name
is a suggestion).

<p>
<b>c)</b>
Write a function that can take a number of data
structures and the corresponding city names to create a plot of
the temperatures over a certain time period.

<p>
Filename: <code>temperature_data.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 15: Generate an HTML report with figures <a name="sec:files:ex21"></a></h2>

The goal of this exercise is to let a program write a report in HTML
format containing the solution to ref{sec:plot:ex5e}.  First,
include the program from that exercise, with additional explaining
text if necessary.  Program code can be placed inside <code><pre></code> and
<code></pre></code> tags.  Second, insert three plots of the \( f(x,t) \) function
for three different \( t \) values (find suitable \( t \) values that
illustrate the displacement of the wave packet).  Third, add an
animated GIF file with the movie of \( f(x,t) \).  Insert headlines
(<code><h1></code> tags) wherever appropriate.
Filename: <code>wavepacket_report.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 16: Allow different types for a function argument <a name="bioinf:exer:freq:fargs"></a></h2>

Consider the family of <code>find_consensus_v*</code> functions from
the section <a href="#bioinf:freq:analysis">Analyzing the frequency matrix</a>. The different versions work on
different representations of the frequency matrix. Make a unified
<code>find_consensus</code> function that accepts different data structures
for the <code>frequency_matrix</code>. Test on the type of data structure and
perform the necessary actions.
Filename: <code>find_consensus.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 17: Make a function more robust <a name="bioinf:exer:get_base_counts2"></a></h2>

Consider the function <code>get_base_counts(dna)</code>
from the section <a href="#bioinf:basefreq">Finding base frequencies</a>,
which counts how many times <code>A</code>, <code>C</code>, <code>G</code>, and
<code>T</code> appears in the string <code>dna</code>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def get_base_counts(dna):
    counts = {'A': 0, 'T': 0, 'G': 0, 'C': 0}
    for base in dna:
        counts[base] += 1
    return counts
</code></pre>
<!-- end verbatim block -->
Unfortunately, this function crashes if other letters appear in <code>dna</code>.
Write an enhanced function <code>get_base_counts2</code> which solves this problem.
Test it on a string like <code>'ADLSTTLLD'</code>.
Filename: <code>get_base_counts2.py</code>.

<p>
<!-- Hints: defaultdict or test on if base in counts: ... else counts[base]=1 -->

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 18: Find proportion of bases inside/outside exons <a name="bioinf:exer:Ainsouts:exons"></a></h2>

Consider the lactase gene as described in
the sections <a href="#bioinf:gene2protein">Translating genes into proteins</a> and <a href="#bioinf:lactase:milk">Some humans can drink milk, while others cannot</a>.
What is the proportion of base A inside and outside exons of
the lactase gene?

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Write a function <code>get_exons</code>, which returns
all the substrings of the exon regions concatenated.
Also write a function <code>get_introns</code>, which
returns all the substrings between the exon regions concatenated.
The function <code>get_base_frequencies</code> from the section <a href="#bioinf:basefreq">Finding base frequencies</a>
can then be used to analyze the frequencies of bases A, C, G, and T
in the two strings.

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>prop_A_exons.py</code>.

<p>
<!-- --- end exercise --- -->

<h1>References  <a name="___sec98"></a></h1>

<!-- begin bibliography -->

<ol>
 <li> <a name="Langtangen_TCSE6_funcif"></a> <b>H. P. Langtangen</b>. 
    Functions and branching,
    <a href="http://tcse6.on.net/funcif" target="_self"><tt>http://tcse6.on.net/funcif</tt></a>.</li>
 <li> <a name="Langtangen_TCSE6_input"></a> <b>H. P. Langtangen</b>. 
    User input and error handling,
    <a href="http://tcse6.on.net/input" target="_self"><tt>http://tcse6.on.net/input</tt></a>.</li>
 <li> <a name="Langtangen_TCSE6_varargs"></a> <b>H. P. Langtangen</b>. 
    Variable number of function arguments in Python,
    <a href="http://tcse6.on.net/varargs" target="_self"><tt>http://tcse6.on.net/varargs</tt></a>.</li>
</ol>

<!-- end bibliography -->

<p>
<!-- begin bottom navigation -->
<table style="width: 100%"><tr><td>
</td><td>
</td></tr></table>
<!-- end bottom navigation -->
</p>

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

