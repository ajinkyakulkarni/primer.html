<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="User input and error handling">
<meta name="keywords" content="command-line arguments,option-value pairs (command line),standard input,standard output,standard error,bytes,bits,exceptions,widgets,event loop,modules,test block (in module files),test function,nose tests,pytest tests,search for module files,module folders,refactoring,binomial distribution,Bernoulli trials,Poisson distribution,Poisson process">

<title>User input and error handling</title>


<link href="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
code { padding: 0px; background-color: inherit; }
pre {
  border: 0pt solid #93a1a1;
  box-shadow: none;
}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [(' Asking questions and reading answers ',
               1,
               'sec:input:rawinput',
               'sec:input:rawinput'),
              (' Reading keyboard input ',
               2,
               'sec:input:rawinput2',
               'sec:input:rawinput2'),
              (' Reading from the command line ',
               1,
               'sec:input:sysargv',
               'sec:input:sysargv'),
              (' Providing input on the command line ',
               2,
               'sec:input:cml',
               'sec:input:cml'),
              (' A variable number of command-line arguments ',
               2,
               None,
               '___sec4'),
              (' More on command-line arguments ', 2, None, '___sec5'),
              (' Turning user text into live objects ', 1, None, '___sec6'),
              (' The magic eval function ',
               2,
               'sec:input:eval',
               'sec:input:eval'),
              (' Applying eval to strings ', 3, None, '___sec8'),
              (' Applying eval to user input ', 3, None, '___sec9'),
              (' The magic exec function ',
               2,
               'sec:input:exec',
               'sec:input:exec'),
              (' Turning string expressions into functions ',
               2,
               'sec:input:StringFunction',
               'sec:input:StringFunction'),
              (' Option-value pairs on the command line ',
               1,
               'sec:input:argparse',
               'sec:input:argparse'),
              (' Basic usage of the argparse module ', 2, None, '___sec13'),
              (' Mathematical expressions as values ', 2, None, '___sec14'),
              (' Reading data from file ',
               1,
               'sec:files:reading',
               'sec:files:reading'),
              (' Reading a file line by line ', 2, None, '___sec16'),
              (' Alternative ways of reading a file ',
               2,
               'sec:files:reading:other',
               'sec:files:reading:other'),
              (' The modern with statement ', 3, None, '___sec18'),
              (' The old while construction ', 3, None, '___sec19'),
              (' Reading a file into a string ', 3, None, '___sec20'),
              (' Reading a mixture of text and numbers ',
               2,
               'sec:files:textnum',
               'sec:files:textnum'),
              (' Is it more to file reading? ', 3, None, '___sec22'),
              (' Writing data to file ',
               1,
               'sec:files:writing',
               'sec:files:writing'),
              (' Example: Writing a table to file ', 2, None, '___sec24'),
              (' Problem ', 3, None, '___sec25'),
              (' Solution ', 3, None, '___sec26'),
              (' Standard input and output as file objects ',
               2,
               None,
               '___sec27'),
              (' Redirecting standard input, output, and error ',
               3,
               None,
               '___sec28'),
              (' Note ', 3, None, '___sec29'),
              (' What is a file, really? ',
               2,
               'sec:files:really',
               'sec:files:really'),
              (' Pure text files ', 3, None, '___sec31'),
              (' Word processor files ', 3, None, '___sec32'),
              (' Image files ', 3, None, '___sec33'),
              (' Music files ', 3, None, '___sec34'),
              (' PDF files ', 3, None, '___sec35'),
              (' Remarks ', 3, None, '___sec36'),
              (' Handling errors ',
               1,
               'sec:input:except',
               'sec:input:except'),
              (' Exception handling ',
               2,
               'sec:input:except:handling',
               'sec:input:except:handling'),
              (' Testing for a specific exception ', 3, None, '___sec39'),
              (' Examples on exception types ', 3, None, '___sec40'),
              (' Digression ', 3, None, '___sec41'),
              (' Raising exceptions ', 2, None, '___sec42'),
              (' Example ', 3, None, '___sec43'),
              (' A glimpse of graphical user interfaces ',
               1,
               'sec:input:GUI',
               'sec:input:GUI'),
              (' Making modules ',
               1,
               'sec:input:modules',
               'sec:input:modules'),
              (' Example: Interest on bank deposits ', 2, None, '___sec46'),
              (' Collecting functions in a module file ',
               2,
               'sec:input:module:create',
               'sec:input:module:create'),
              (' Test block ',
               2,
               'sec:input:module:testblock',
               'sec:input:module:testblock'),
              (' Example on a test block in a minimalistic module ',
               3,
               None,
               '___sec49'),
              (' A test block in the `interest` module ',
               3,
               None,
               '___sec50'),
              (' Verification of the module code ',
               2,
               'sec:input:modules:testfunc',
               'sec:input:modules:testfunc'),
              (' Getting input data ',
               2,
               'sec:input:modules:inputdata',
               'sec:input:modules:inputdata'),
              (' Doc strings in modules ', 2, None, '___sec53'),
              (' Using modules ',
               2,
               'sec:input:modules:usage',
               'sec:input:modules:usage'),
              (' What gets imported by various import statements? ',
               3,
               None,
               '___sec55'),
              (' How to make Python find a module file ',
               3,
               None,
               '___sec56'),
              (' How to make Python run the module file ',
               3,
               None,
               '___sec57'),
              (' Distributing modules ',
               2,
               'sec:input:modules:setuppy',
               'sec:input:modules:setuppy'),
              (' Making software available on the Internet ',
               2,
               None,
               '___sec59'),
              (' Summary ', 1, 'sec:input:summary', 'sec:input:summary'),
              (' Chapter topics ',
               2,
               'sec:input:summary:topics',
               'sec:input:summary:topics'),
              (' Question and answer input ', 3, None, '___sec62'),
              (' Getting command-line arguments ', 3, None, '___sec63'),
              (' Using option-value pairs ', 3, None, '___sec64'),
              (' Generating code on the fly ', 3, None, '___sec65'),
              (' Turning string formulas into Python functions ',
               3,
               None,
               '___sec66'),
              (' File operations ', 3, None, '___sec67'),
              (' Handling exceptions ', 3, None, '___sec68'),
              (' Raising exceptions ', 3, None, '___sec69'),
              (' Modules ', 3, None, '___sec70'),
              (' Terminology ', 3, None, '___sec71'),
              (' Example: Bisection root finding ',
               2,
               'sec:input:summarizingex',
               'sec:input:summarizingex'),
              (' Problem ', 3, None, '___sec73'),
              (' Solution ', 3, None, '___sec74'),
              (' Verification ', 3, None, '___sec75'),
              (' Making a function ', 3, None, '___sec76'),
              (' Making a test function ', 3, None, '___sec77'),
              (' Making a module ', 3, None, '___sec78'),
              (' Defining a user interface ', 3, None, '___sec79'),
              (' Using the module ', 3, None, '___sec80'),
              (' Potential problems with the software ', 3, None, '___sec81'),
              (' Distributing the bisection module to others ',
               3,
               None,
               '___sec82'),
              (' Exercises ', 1, None, '___sec83'),
              (' Exercise 1: Make an interactive program ',
               2,
               'sec:input:ex24',
               'sec:input:ex24'),
              (' Exercise 2: Read a number from the command line ',
               2,
               'sec:input:ex24b',
               'sec:input:ex24b'),
              (' Exercise 3: Read a number from a file ',
               2,
               'sec:input:ex24bfile',
               'sec:input:ex24bfile'),
              (' Exercise 4: Read and write several numbers from and to file ',
               2,
               'sec:input:ex24bfile2',
               'sec:input:ex24bfile2'),
              (' Exercise 5: Use exceptions to handle wrong input ',
               2,
               'sec:input:ex24c',
               'sec:input:ex24c'),
              (' Exercise 6: Read input from the keyboard ',
               2,
               'sec:input:ex25',
               'sec:input:ex25'),
              (' Exercise 7: Read input from the command line ',
               2,
               'sec:input:ex26',
               'sec:input:ex26'),
              (' Exercise 8: Try MSWord or LibreOffice to write a program ',
               2,
               'sec:files:ex7',
               'sec:files:ex7'),
              (' Exercise 9: Prompt the user for input to a formula ',
               2,
               'sec:input:ex6',
               'sec:input:ex6'),
              (' Exercise 10: Read parameters in a formula from the command line ',
               2,
               'sec:input:ex5',
               'sec:input:ex5'),
              (' Exercise 11: Use exceptions to handle wrong input ',
               2,
               'sec:input:ex8b',
               'sec:input:ex8b'),
              (' Exercise 12: Test validity of input data ',
               2,
               'sec:input:ex7',
               'sec:input:ex7'),
              (' Exercise 13: Raise an exception in case of wrong input ',
               2,
               'sec:input:ex8',
               'sec:input:ex8'),
              (' Exercise 14: Evaluate a formula for data in a file ',
               2,
               'sec:input:ex:ball:file',
               'sec:input:ex:ball:file'),
              (' Exercise 15: Compute the distance it takes to stop a car ',
               2,
               'sec:input:ex21',
               'sec:input:ex21'),
              (' Exercise 16: Look up calendar functionality ',
               2,
               'sec:input:ex48',
               'sec:input:ex48'),
              (' Exercise 17: Use the StringFunction tool ',
               2,
               'sec:input:ex28b',
               'sec:input:ex28b'),
              (' Exercise 18: Why we test for specific exception types ',
               2,
               'sec:input:ex11',
               'sec:input:ex11'),
              (' Exercise 19: Make a complete module ',
               2,
               'sec:input:ex27',
               'sec:input:ex27'),
              (' Exercise 20: Check if mathematical identities hold ',
               2,
               'sec:input:ex2',
               'sec:input:ex2'),
              (' Exercise 21: Compute probabilities with the binomial distribution ',
               2,
               'sec:input:ex15',
               'sec:input:ex15'),
              (' Exercise 22: Compute probabilities with the Poisson distribution ',
               2,
               'sec:input:ex16',
               'sec:input:ex16'),
              (' References ', 1, None, '___sec106')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\tp}{\thinspace .}
$$




    
<a name="part0006"></a>
<p>
<!-- begin top navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._input-solarized005.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._input-solarized007.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end top navigation -->
</p>

<p>
<!-- !split -->
<p style="font-size:80%">This chapter is taken from book <a href="http://www.springer.com/gp/book/9783642549588">A Primer on Scientific Programming with Python</a> by H. P. Langtangen, 4th edition, Springer, 2014.</p>

<h1 id="sec:files:writing">Writing data to file</h1>

<p>
Writing data to file is easy.
There is basically one function to pay attention to: <code>outfile.write(s)</code>,
which writes a string <code>s</code> to
a file handled by the file object <code>outfile</code>. Unlike <code>print</code>,
<code>outfile.write(s)</code>
does not append a newline character to the written string.
It will therefore
often be necessary to add a newline character,

<p>
<!-- begin verbatim block  pycod-->
<pre><code>outfile.write(s + '\n')
</code></pre>
<!-- end verbatim block -->
if the string <code>s</code> is meant to appear on a single line in the file
and <code>s</code> does not already contain a trailing newline character.
File writing is then a matter of constructing strings containing the
text we want to have in the file and for each such string call
<code>outfile.write</code>.

<p>
Writing to a file demands
the file object <code>f</code>
to be opened for writing:

<p>
<!-- begin verbatim block  pycod-->
<pre><code># write to new file, or overwrite file:
outfile = open(filename, 'w')

# append to the end of an existing file:
outfile = open(filename, 'a')
</code></pre>
<!-- end verbatim block -->

<h2 id="___sec24">Example: Writing a table to file </h2>

<h3 id="___sec25">Problem </h3>

<p>
As a worked example of file writing, we shall write out a nested list
with tabular data to file.  A sample list may take look as

<p>
<!-- begin verbatim block  ccq-->
<pre><code>[[ 0.75,        0.29619813, -0.29619813, -0.75      ],
 [ 0.29619813,  0.11697778, -0.11697778, -0.29619813],
 [-0.29619813, -0.11697778,  0.11697778,  0.29619813],
 [-0.75,       -0.29619813,  0.29619813,  0.75      ]]
</code></pre>
<!-- end verbatim block -->

<h3 id="___sec26">Solution </h3>

<p>
We iterate through the rows (first index) in the list, and for each row,
we iterate through the column values (second index)
and write each value to the file.
At the end of each row, we must insert a newline character in the file to get
a linebreak. The code resides in the file <a href="http://tinyurl.com/pwyasaa/input/write1.py" target="_self"><tt>write1.py</tt></a>:

<p>
<!-- begin verbatim block  pypro-->
<pre><code>data = [[ 0.75,        0.29619813, -0.29619813, -0.75      ],
        [ 0.29619813,  0.11697778, -0.11697778, -0.29619813],
        [-0.29619813, -0.11697778,  0.11697778,  0.29619813],
        [-0.75,       -0.29619813,  0.29619813,  0.75      ]]

outfile = open('tmp_table.dat', 'w')
for row in data:
    for column in row:
        outfile.write('%14.8f' % column)
    outfile.write('\n')
outfile.close()
</code></pre>
<!-- end verbatim block -->

<p>
The resulting data file becomes

<p>
<!-- begin verbatim block  dat-->
<pre><code>    0.75000000    0.29619813   -0.29619813   -0.75000000
    0.29619813    0.11697778   -0.11697778   -0.29619813
   -0.29619813   -0.11697778    0.11697778    0.29619813
   -0.75000000   -0.29619813    0.29619813    0.75000000
</code></pre>
<!-- end verbatim block -->

<p>
An extension of this program consists in adding column and row headings:

<p>
<!-- begin verbatim block  dat-->
<pre><code>           column  1     column  2     column  3     column  4
row  1    0.75000000    0.29619813   -0.29619813   -0.75000000
row  2    0.29619813    0.11697778   -0.11697778   -0.29619813
row  3   -0.29619813   -0.11697778    0.11697778    0.29619813
row  4   -0.75000000   -0.29619813    0.29619813    0.75000000
</code></pre>
<!-- end verbatim block -->
To obtain this end result, we need to the add some statements to
the program <code>write1.py</code>. For the column headings we must
know the number of columns, i.e., the length of the rows,
and loop from 1 to this length:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>ncolumns = len(data[0])
outfile.write('          ')
for i in range(1, ncolumns+1):
    outfile.write('%10s    ' % ('column %2d' % i))
outfile.write('\n')
</code></pre>
<!-- end verbatim block -->
Note the use of a nested printf construction: the text we want to
insert is itself a printf string. We could also have written the
text as <code>'column  ' + str(i)</code>, but then the length of the
resulting string would depend on the number of digits in <code>i</code>.
It is recommended to always use printf constructions for
a tabular output format, because this gives automatic padding of
blanks so that the width of the output strings remains the same.
The tuning of the widths is commonly done in a trial-and-error
process.

<p>
To add the row headings, we need a counter over the row numbers:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>row_counter = 1
for row in data:
    outfile.write('row %2d' % row_counter)
    for column in row:
        outfile.write('%14.8f' % column)
    outfile.write('\n')
    row_counter += 1
</code></pre>
<!-- end verbatim block -->
The complete code is found in the file <a href="http://tinyurl.com/pwyasaa/input/write2.py" target="_self"><tt>write2.py</tt></a>.
We could, alternatively, iterate over the indices in the list:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>for i in range(len(data)):
    outfile.write('row %2d' % (i+1))
    for j in range(len(data[i])):
        outfile.write('%14.8f' % data[i][j])
    outfile.write('\n')
</code></pre>
<!-- end verbatim block -->

<h2 id="___sec27">Standard input and output as file objects </h2>

<p>
Reading user input from the keyboard applies the function
<code>raw_input</code>.
The keyboard is a medium that the computer in fact
treats as a file, referred to
as <em>standard input</em>.

<p>
The <code>print</code> command prints text in the terminal window. This medium is
also viewed as a file from the computer's point of view and called
<em>standard output</em>. All general-purpose programming languages allow
reading from standard input and writing to standard output. This
reading and writing can be done with two types of tools, either
file-like objects or special tools like <code>raw_input</code> and <code>print</code> in
Python.  We will here describe the file-line objects: <code>sys.stdin</code> for
standard input and <code>sys.stdout</code> for standard output. These objects
behave as file objects, except that they do not need to be opened or
closed. The statement

<p>
<!-- begin verbatim block  pycod-->
<pre><code>s = raw_input('Give s:')
</code></pre>
<!-- end verbatim block -->
is equivalent to

<p>
<!-- begin verbatim block  pycod-->
<pre><code>print 'Give s: ',
s = sys.stdin.readline()
</code></pre>
<!-- end verbatim block -->
Recall that the trailing comma in the <code>print</code> statement avoids the
newline that <code>print</code> by default adds to the output string.
Similarly,

<p>
<!-- begin verbatim block  pycod-->
<pre><code>s = eval(raw_input('Give s:'))
</code></pre>
<!-- end verbatim block -->
is equivalent to

<p>
<!-- begin verbatim block  pycod-->
<pre><code>print 'Give s: ',
s = eval(sys.stdin.readline())
</code></pre>
<!-- end verbatim block -->
For output to the terminal window, the statement

<p>
<!-- begin verbatim block  pycod-->
<pre><code>print s
</code></pre>
<!-- end verbatim block -->
is equivalent to

<p>
<!-- begin verbatim block  pycod-->
<pre><code>sys.stdout.write(s + '\n')
</code></pre>
<!-- end verbatim block -->

<p>
Why it is handy to have access to standard input and output
as file objects can be illustrated by an example. Suppose you have a
function that reads data from a file object <code>infile</code>
and writes data to a file object <code>outfile</code>.
A sample function may take the form

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def x2f(infile, outfile, f):
    for line in infile:
        x = float(line)
        y = f(x)
        outfile.write('%g\n' % y)
</code></pre>
<!-- end verbatim block -->
This function works with all types of files, including
web pages as
<code>infile</code>.
With <code>sys.stdin</code> as <code>infile</code> and/or <code>sys.stdout</code>
as <code>outfile</code>, the <code>x2f</code> function also works with standard input
and/or standard output. Without <code>sys.stdin</code> and <code>sys.stdout</code>,
we would need different code, employing <code>raw_input</code>
and <code>print</code>,
to deal with standard input and output. Now we can write a single
function that deals with all file media in a unified way.

<p>
There is also something called <em>standard error</em>.
Usually this is the terminal window, just as standard output, but
programs can distinguish between writing ordinary output to standard
output and error messages to standard error, and these output media
can be redirected to, e.g., files such that one can separate
error messages from ordinary output.
In Python, standard error is the file-like object <code>sys.stderr</code>.
A typical application of <code>sys.stderr</code> is to report errors:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>if x &lt; 0:
    sys.stderr.write('Illegal value of x'); sys.exit(1)
</code></pre>
<!-- end verbatim block -->
This message to <code>sys.stderr</code> is an alternative to
<code>print</code> or raising an exception.

<h3 id="___sec28">Redirecting standard input, output, and error </h3>

<p>
Standard output from a program <code>prog</code>
can be redirected to a file
<code>output</code> instead of the screen, by
using the greater than sign:

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; prog &gt; output
</code></pre>
<!-- end verbatim block -->
Here, <code>prog</code> can be any
program, including a Python program run as <code>python myprog.py</code>.
Similarly, output to the medium called <em>standard error</em>
can be redirected by

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; prog &amp;&gt; output
</code></pre>
<!-- end verbatim block -->
For example, error messages are normally written to standard error, which
is exemplified in this little terminal session on a Unix machine:

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; ls bla-bla1 bla-bla2
ls: cannot access bla-bla1: No such file or directory
ls: cannot access bla-bla2: No such file or directory
Terminal&gt; ls bla-bla1 bla-bla2 &amp;&gt; errors
Terminal&gt; cat errors  # print the file errors
ls: cannot access bla-bla1: No such file or directory
ls: cannot access bla-bla2: No such file or directory
</code></pre>
<!-- end verbatim block -->
When the program reads from standard input (the keyboard),
we can equally well redirect
standard input from a file, say with name <code>input</code>, such that
the program reads from this file rather than from the keyboard:

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; prog &lt; input
</code></pre>
<!-- end verbatim block -->
Combinations are also possible:

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; prog &lt; input &gt; output
</code></pre>
<!-- end verbatim block -->

<h3 id="___sec29">Note </h3>

<p>
The redirection of standard output, input, and error
does not work for Python programs executed with the <code>run</code>
command inside IPython, only when executed directly
in the operating system in a terminal window, or with the same
command prefixed with an exclamation mark in IPython.

<p>
Inside a Python program we can also let standard input, output, and
error work with ordinary files instead. Here is the technique:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>sys_stdout_orig = sys.stdout
sys.stdout = open('output', 'w')
sys_stdin_orig = sys.stdin
sys.stdin = open('input', 'r')
</code></pre>
<!-- end verbatim block -->
Now, any <code>print</code> statement will write to the <code>output</code> file, and
any <code>raw_input</code> call will read from the <code>input</code> file.
(Without storing the original <code>sys.stdout</code> and <code>sys.stdin</code>
objects in new variables, these objects would get lost in the redefinition
above and we would never be able to reach the common standard input and
output in the program.)

<h2 id="sec:files:really">What is a file, really?</h2>

<p>
This section is not mandatory for understanding the rest of the document.
Nevertheless, the information here is fundamental for understanding
what files are about.

<p>
A file is simply a sequence of characters. In addition to the sequence
of characters, a file has some data associated with it, typically the
name of the file, its location on the disk, and the file size.  These
data are stored somewhere by the operating system.  Without this extra
information beyond the pure file contents as a sequence of characters,
the operating system cannot find a file with a given name on the disk.

<p>
Each character in the file is represented as a <em>byte</em>, consisting of
eight <em>bits</em>.  Each bit is either 0 or 1.  The zeros and ones in a
byte can be combined in \( 2^8=256 \) ways. This means that there are 256
different types of characters.  Some of these characters can be
recognized from the keyboard, but there are also characters that do
not have a familiar symbol. Such characters looks cryptic
when printed.

<h3 id="___sec31">Pure text files </h3>

<p>
To see that a file is really just a sequence of characters, invoke an
editor for plain text, typically the editor you use to write Python
programs.  Write the four characters <code>ABCD</code> into the editor, do not
press the Return key, and save the text to a file <code>test1.txt</code>. Use
your favorite tool for file and folder overview and move to the folder
containing the <code>test1.txt</code> file.  This tool may be Windows Explorer,
My Computer, or a DOS window on Windows; a terminal window, Konqueror,
or Nautilus on Linux; or a terminal window or Finder on Mac.  If you
choose a terminal window, use the <code>cd</code> (change directory) command to
move to the proper folder and write <code>dir</code> (Windows) or <code>ls -l</code>
(Linux/Mac) to list the files and their sizes. In a graphical program
like Windows Explorer, Konqueror, Nautilus, or Finder, select a view
that shows the <em>size</em> of each file (choose <em>view as details</em> in
Windows Explorer, <em>View as List</em> in Nautilus, the list view icon in
Finder, or you just point at a file icon in Konqueror and watch the
pop-up text).  You will see that the <code>test1.txt</code> file has a size of 4
bytes (if you use <code>ls -l</code>, the size measured in bytes is found in
column 5, right before the date).  The 4 bytes are exactly the 4
characters <code>ABCD</code> in the file. Physically, the file is just a sequence
of 4 bytes on your hard disk.

<p>
Go back to the editor again and add a newline by pressing the Return key.
Save this new version of the file as <code>test2.txt</code>. When you now
check the size of the file it has grown to five bytes. The reason is
that we added a newline character (symbolically known as <em>backslash n</em>:
<code>\n</code>).

<p>
Instead of examining files via editors and folder viewers
we may use Python interactively:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; file1 = open('test1.txt', 'r').read()  # read file into string
&gt;&gt;&gt; file1
'ABCD'
&gt;&gt;&gt; len(file1)        # length of string in bytes/characters
4
&gt;&gt;&gt; file2 = open('test2.txt', 'r').read()
&gt;&gt;&gt; file2
'ABCD\n'
&gt;&gt;&gt; len(file2)
5
</code></pre>
<!-- end verbatim block -->
Python has in fact a function that returns the size of a file
directly:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; size = os.path.getsize('test1.txt')
&gt;&gt;&gt; size
4
</code></pre>
<!-- end verbatim block -->

<h3 id="___sec32">Word processor files </h3>

<p>
Most computer users write text in a word processing program, such as
Microsoft Word or LibreOffice.  Let us investigate what happens with
our four characters <code>ABCD</code> in such a program. Start the word
processor, open a new document, and type in the four characters <code>ABCD</code>
only. Save the document as a <code>.docx</code> file (Microsoft Word) or an <code>.odt</code>
file (LibreOffice). Load this file into an editor for pure text and
look at the contents. You will see that there are numerous strange
characters that you did not write (!). This additional &quot;text&quot;
contains information on what type of document this is, the font you
used, etc. The LibreOffice version of this file has 8858 bytes
and the Microsoft Word version contains over 26 Kb!
However, if you save the file as a pure text file, with extension
<code>.txt</code>, the size is down to 8 bytes in LibreOffice and
five in Microsoft Word.

<p>
Instead of loading the LibreOffice file into an editor we can again
read the file contents into a string in Python and examine this string:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; infile = open('test3.odt', 'r')  # open LibreOffice file
&gt;&gt;&gt; s = infile.read()
&gt;&gt;&gt; len(s)   # file size
8858
&gt;&gt;&gt; s
'PK\x03\x04\x14\x00\x00\x08\x00\x00sKWD^\xc62\x0c\'\x00...
\x00meta.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;office:...
&quot; xmlns:meta=&quot;urn:oasis:names:tc:opendocument:xmlns:meta:1.0&quot;
</code></pre>
<!-- end verbatim block -->
Each backslash followed by <code>x</code> and a number is a code for a
special character not found on the keyboard (recall that there are
256 characters and only a subset is associated with keyboard symbols).
Although we show just a small portion of all the characters in this file
in the above output (otherwise, the output would have occupied several
pages in this document with thousands symbols like <code>\x04</code>...),
we can guarantee that you cannot find the pure sequence of characters
<code>ABCD</code>. However, the computer program that generated the file,
LibreOffice in this example, can easily interpret the meaning of
all the characters in the file
and translate the information into nice, readable text on the screen
where you can recognize the text <code>ABCD</code>.

<p>
Your are now in a position to look into <a href="._input-solarized011.html#sec:files:ex7">Exercise 8: Try MSWord or LibreOffice to write a program</a> to
see what happens if one attempts to use LibreOffice to write Python
programs.

<h3 id="___sec33">Image files </h3>

<p>
A digital image - captured by a digital camera or a mobile phone - is
a file. And since it is a file, the image is just a sequence of
characters. Loading some JPEG file into a pure text editor, reveals
all the strange characters in there. On the first line you will
(normally) find some recognizable text in between the strange
characters.  This text reflects the type of camera used to capture the
image and the date and time when the picture was taken.  The next
lines contain more information about the image.  Thereafter, the file
contains a set of numbers representing the image.  The basic
representation of an image is a set of \( m\times n \) pixels, where each
pixel has a color represented as a combination of 256 values of red,
green, and blue, which can be stored as three bytes (resulting in
\( 256^3 \) color values).  A 6-megapixel camera will then need to store
\( 3\times 6\cdot 10^6 = 18 \) megabytes for one picture.  The JPEG file
contains only a couple of megabytes. The reason is that JPEG is a
<em>compressed</em> file format, produced by applying a smart technique that
can throw away pixel information in the original picture such that the
human eye hardly can detect the inferior quality.

<p>
A video is just a sequence of images, and therefore a video is also a
stream of bytes.  If the change from one video frame (image) to the
next is small, one can use smart methods to compress the image
information in time. Such compression is particularly important for
videos since the file sizes soon get too large for being transferred
over the Internet. A small video file occasionally has bad visual
quality, caused by too much compression.

<h3 id="___sec34">Music files </h3>

<p>
An MP3 file is much like a JPEG file: first, there is some information
about the music (artist, title, album, etc.), and then comes the music
itself as a stream of bytes. A typical MP3 file has a size of
something like five million bytes or five megabytes (5 Mb). The exact
size depends on the complexity of the music, the length of the track,
and the MP3 resolution.  On a 16 Gb MP3 player you can then store
roughly \( 16,000,000,000/5,000,000 = 3200 \) MP3 files. MP3 is, like JPEG,
a compressed format. The complete data of a song on a CD (the WAV
file) contains about ten times as many bytes. As for pictures, the
idea is that one can throw away a lot of bytes in an intelligent way,
such that the human ear hardly detects the difference between a
compressed and uncompressed version of the music file.

<h3 id="___sec35">PDF files </h3>

<p>
Looking at a PDF file in a pure text editor shows that the file
contains some readable text mixed with some unreadable characters. It
is not possible for a human to look at the stream of bytes and deduce
the text in the document (well, from the assumption that there are
always some strange people doing strange things, there might be
somebody out there who, with a lot of training, can interpret the pure
PDF code with the eyes).  A PDF file reader can easily interpret the
contents of the file and display the text in a human-readable form on
the screen.

<h3 id="___sec36">Remarks </h3>

<p>
We have repeated many times that a file is just a stream of bytes.  A
human can interpret (read) the stream of bytes if it makes sense in a
human language - or a computer language (provided the human is a
programmer).  When the series of bytes does not make sense to any
human, a computer program must be used to interpret the sequence of
characters.

<p>
Think of a report. When you write the report as pure text in a text
editor, the resulting file contains just the characters you typed in
from the keyboard. On the other hand, if you applied a word processor
like Microsoft Word or LibreOffice, the report file contains a large
number of extra bytes describing properties of the formatting of the
text.  This stream of extra bytes does not make sense to a human, and
a computer program is required to interpret the file content and
display it in a form that a human can understand. Behind the sequence
of bytes in the file there are strict rules telling what the series of
bytes means.  These rules reflect the <em>file format</em>. When the rules or
file format is publicly documented, a programmer can use this
documentation to make her own program for interpreting the file
contents (however, interpreting such files is much more complicated
than our examples on reading human-readable files in this document). It
happens, though, that secret file formats are used, which require
certain programs from certain companies to interpret the files.

<p>
<!-- It is a political question whether such secret -->
<!-- formats are suitable for storing important reports over periods of time that -->
<!-- are longer than the expected life of software companies. -->

<p>
<p>
<!-- begin bottom navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._input-solarized005.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._input-solarized007.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end bottom navigation -->
</p>

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

