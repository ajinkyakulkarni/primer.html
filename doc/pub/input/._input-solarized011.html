<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="User input and error handling">
<meta name="keywords" content="command-line arguments,option-value pairs (command line),standard input,standard output,standard error,bytes,bits,exceptions,widgets,event loop,modules,test block (in module files),test function,nose tests,pytest tests,unit testing,search for module files,module folders,refactoring,binomial distribution,Bernoulli trials,Poisson distribution,Poisson process">

<title>User input and error handling</title>


<link href="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
code { padding: 0px; background-color: inherit; }
pre {
  border: 0pt solid #93a1a1;
  box-shadow: none;
}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [('Table of contents',
               1,
               'table_of_contents',
               'table_of_contents'),
              ('Asking questions and reading answers',
               1,
               'sec:input:rawinput',
               'sec:input:rawinput'),
              ('Reading keyboard input',
               2,
               'sec:input:rawinput2',
               'sec:input:rawinput2'),
              ('Reading from the command line',
               1,
               'sec:input:sysargv',
               'sec:input:sysargv'),
              ('Providing input on the command line',
               2,
               'sec:input:cml',
               'sec:input:cml'),
              ('A variable number of command-line arguments',
               2,
               None,
               '___sec4'),
              ('More on command-line arguments', 2, None, '___sec5'),
              ('Turning user text into live objects', 1, None, '___sec6'),
              ('The magic eval function',
               2,
               'sec:input:eval',
               'sec:input:eval'),
              ('Applying eval to strings', 3, None, '___sec8'),
              ('Applying eval to user input', 3, None, '___sec9'),
              ('The magic exec function',
               2,
               'sec:input:exec',
               'sec:input:exec'),
              ('Turning string expressions into functions',
               2,
               'sec:input:StringFunction',
               'sec:input:StringFunction'),
              ('Option-value pairs on the command line',
               1,
               'sec:input:argparse',
               'sec:input:argparse'),
              ('Basic usage of the argparse module', 2, None, '___sec13'),
              ('Mathematical expressions as values', 2, None, '___sec14'),
              ('Reading data from file',
               1,
               'sec:files:reading',
               'sec:files:reading'),
              ('Reading a file line by line', 2, None, '___sec16'),
              ('Alternative ways of reading a file',
               2,
               'sec:files:reading:other',
               'sec:files:reading:other'),
              ('The modern with statement', 3, None, '___sec18'),
              ('The old while construction', 3, None, '___sec19'),
              ('Reading a file into a string', 3, None, '___sec20'),
              ('Reading a mixture of text and numbers',
               2,
               'sec:files:textnum',
               'sec:files:textnum'),
              ('Is it more to file reading?', 3, None, '___sec22'),
              ('Writing data to file',
               1,
               'sec:files:writing',
               'sec:files:writing'),
              ('Example: Writing a table to file', 2, None, '___sec24'),
              ('Problem', 3, None, '___sec25'),
              ('Solution', 3, None, '___sec26'),
              ('Standard input and output as file objects',
               2,
               None,
               '___sec27'),
              ('Redirecting standard input, output, and error',
               3,
               None,
               '___sec28'),
              ('Note', 3, None, '___sec29'),
              ('What is a file, really?',
               2,
               'sec:files:really',
               'sec:files:really'),
              ('Pure text files', 3, None, '___sec31'),
              ('Word processor files', 3, None, '___sec32'),
              ('Image files', 3, None, '___sec33'),
              ('Music files', 3, None, '___sec34'),
              ('PDF files', 3, None, '___sec35'),
              ('Remarks', 3, None, '___sec36'),
              ('Handling errors', 1, 'sec:input:except', 'sec:input:except'),
              ('Exception handling',
               2,
               'sec:input:except:handling',
               'sec:input:except:handling'),
              ('Testing for a specific exception', 3, None, '___sec39'),
              ('Examples on exception types', 3, None, '___sec40'),
              ('Digression', 3, None, '___sec41'),
              ('Raising exceptions', 2, None, '___sec42'),
              ('Example', 3, None, '___sec43'),
              ('A glimpse of graphical user interfaces',
               1,
               'sec:input:GUI',
               'sec:input:GUI'),
              ('Making modules', 1, 'sec:input:modules', 'sec:input:modules'),
              ('Example: Interest on bank deposits', 2, None, '___sec46'),
              ('Collecting functions in a module file',
               2,
               'sec:input:module:create',
               'sec:input:module:create'),
              ('Test block',
               2,
               'sec:input:module:testblock',
               'sec:input:module:testblock'),
              ('Example on a test block in a minimalistic module',
               3,
               None,
               '___sec49'),
              ('A test block in the `interest` module', 3, None, '___sec50'),
              ('Verification of the module code',
               2,
               'sec:input:modules:testfunc',
               'sec:input:modules:testfunc'),
              ('Getting input data',
               2,
               'sec:input:modules:inputdata',
               'sec:input:modules:inputdata'),
              ('Doc strings in modules', 2, None, '___sec53'),
              ('Using modules',
               2,
               'sec:input:modules:usage',
               'sec:input:modules:usage'),
              ('What gets imported by various import statements?',
               3,
               None,
               '___sec55'),
              ('How to make Python find a module file', 3, None, '___sec56'),
              ('How to make Python run the module file', 3, None, '___sec57'),
              ('Distributing modules',
               2,
               'sec:input:modules:setuppy',
               'sec:input:modules:setuppy'),
              ('Making software available on the Internet',
               2,
               None,
               '___sec59'),
              ('Making code for Python 2 and 3',
               1,
               'sec:input:py23',
               'sec:input:py23'),
              ('Basic differences between Python 2 and 3',
               2,
               None,
               '___sec61'),
              ('The print statement has changed', 3, None, '___sec62'),
              ('Integer division is not an issue in Python 3',
               3,
               None,
               '___sec63'),
              ('The `raw_input` function is named `input` in Python 3',
               3,
               None,
               '___sec64'),
              ('Turning Python 2 code into Python 3 code',
               2,
               None,
               '___sec65'),
              ('Summary', 1, 'sec:input:summary', 'sec:input:summary'),
              ('Chapter topics',
               2,
               'sec:input:summary:topics',
               'sec:input:summary:topics'),
              ('Question and answer input', 3, None, '___sec68'),
              ('Getting command-line arguments', 3, None, '___sec69'),
              ('Using option-value pairs', 3, None, '___sec70'),
              ('Generating code on the fly', 3, None, '___sec71'),
              ('Turning string formulas into Python functions',
               3,
               None,
               '___sec72'),
              ('File operations', 3, None, '___sec73'),
              ('Handling exceptions', 3, None, '___sec74'),
              ('Raising exceptions', 3, None, '___sec75'),
              ('Modules', 3, None, '___sec76'),
              ('Terminology', 3, None, '___sec77'),
              ('Example: Bisection root finding',
               2,
               'sec:input:summarizingex',
               'sec:input:summarizingex'),
              ('Problem', 3, None, '___sec79'),
              ('Solution', 3, None, '___sec80'),
              ('Verification', 3, None, '___sec81'),
              ('Making a function', 3, None, '___sec82'),
              ('Making a test function', 3, None, '___sec83'),
              ('Making a module', 3, None, '___sec84'),
              ('Defining a user interface', 3, None, '___sec85'),
              ('Using the module', 3, None, '___sec86'),
              ('Potential problems with the software', 3, None, '___sec87'),
              ('Distributing the bisection module to others',
               3,
               None,
               '___sec88'),
              ('Exercises', 1, None, '___sec89'),
              ('Exercise 1: Make an interactive program',
               2,
               'sec:input:ex24',
               'sec:input:ex24'),
              ('Exercise 2: Read a number from the command line',
               2,
               'sec:input:ex24b',
               'sec:input:ex24b'),
              ('Exercise 3: Read a number from a file',
               2,
               'sec:input:ex24bfile',
               'sec:input:ex24bfile'),
              ('Exercise 4: Read and write several numbers from and to file',
               2,
               'sec:input:ex24bfile2',
               'sec:input:ex24bfile2'),
              ('Exercise 5: Use exceptions to handle wrong input',
               2,
               'sec:input:ex24c',
               'sec:input:ex24c'),
              ('Exercise 6: Read input from the keyboard',
               2,
               'sec:input:ex25',
               'sec:input:ex25'),
              ('Exercise 7: Read input from the command line',
               2,
               'sec:input:ex26',
               'sec:input:ex26'),
              ('Exercise 8: Try MSWord or LibreOffice to write a program',
               2,
               'sec:files:ex7',
               'sec:files:ex7'),
              ('Exercise 9: Prompt the user for input to a formula',
               2,
               'sec:input:ex6',
               'sec:input:ex6'),
              ('Exercise 10: Read parameters in a formula from the command line',
               2,
               'sec:input:ex5',
               'sec:input:ex5'),
              ('Exercise 11: Use exceptions to handle wrong input',
               2,
               'sec:input:ex8b',
               'sec:input:ex8b'),
              ('Exercise 12: Test validity of input data',
               2,
               'sec:input:ex7',
               'sec:input:ex7'),
              ('Exercise 13: Raise an exception in case of wrong input',
               2,
               'sec:input:ex8',
               'sec:input:ex8'),
              ('Exercise 14: Evaluate a formula for data in a file',
               2,
               'sec:input:ex:ball:file',
               'sec:input:ex:ball:file'),
              ('Exercise 15: Write a function given its test function',
               2,
               'sec:input:ex:testffirst',
               'sec:input:ex:testffirst'),
              ('Exercise 16: Compute the distance it takes to stop a car',
               2,
               'sec:input:ex21',
               'sec:input:ex21'),
              ('Exercise 17: Look up calendar functionality',
               2,
               'sec:input:ex48',
               'sec:input:ex48'),
              ('Exercise 18: Use the StringFunction tool',
               2,
               'sec:input:ex28b',
               'sec:input:ex28b'),
              ('Exercise 19: Why we test for specific exception types',
               2,
               'sec:input:ex11',
               'sec:input:ex11'),
              ('Exercise 20: Make a complete module',
               2,
               'sec:input:ex27',
               'sec:input:ex27'),
              ('Exercise 21: Organize a previous program as a module',
               2,
               'sec:input:ex17',
               'sec:input:ex17'),
              ('Exercise 22: Read options and values from the command line',
               2,
               'sec:input:ex19',
               'sec:input:ex19'),
              ('Exercise 23: Check if mathematical identities hold',
               2,
               'sec:input:ex2',
               'sec:input:ex2'),
              ('Exercise 24: Compute probabilities with the binomial distribution',
               2,
               'sec:input:ex15',
               'sec:input:ex15'),
              ('Exercise 25: Compute probabilities with the Poisson distribution',
               2,
               'sec:input:ex16',
               'sec:input:ex16'),
              ('References', 1, None, '___sec115')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\tp}{\thinspace .}
$$




    
<a name="part0011"></a>
<p>
<!-- begin top navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._input-solarized010.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._input-solarized012.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end top navigation -->
</p>

<p>
<!-- !split -->
<p style="font-size:80%">This chapter is taken from the book <a href="http://www.springer.com/gp/book/9783662498866">A Primer on Scientific Programming with Python</a> by H. P. Langtangen, 5th edition, Springer, 2016.</p>

<h1 id="sec:input:summary">Summary</h1>

<h2 id="sec:input:summary:topics">Chapter topics</h2>

<h3 id="___sec68">Question and answer input </h3>

<p>
Prompting the user and reading the answer back into a
variable is done by

<p>
<!-- begin verbatim block  pycod-->
<pre><code>var = raw_input('Give value: ')
</code></pre>
<!-- end verbatim block -->
The <code>raw_input</code> function returns a string containing the
characters that the user wrote on the keyboard before pressing the Return
key. It is necessary to convert <code>var</code> to an appropriate object
(<code>int</code> or <code>float</code>, for instance)
if we want to perform mathematical operations with <code>var</code>.
Sometimes

<p>
<!-- begin verbatim block  pycod-->
<pre><code>var = eval(raw_input('Give value: '))
</code></pre>
<!-- end verbatim block -->
is a flexible and easy way of
transforming the string to the right type of object (integer, real number,
list, tuple, and so on).
This last statement will not work, however, for strings unless the text is
surrounded by quotes when written on the keyboard.
A general conversion function that turns any text without quotes
into the right object is <code>scitools.misc.str2obj</code>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>from scitools.misc import str2obj
var = str2obj(raw_input('Give value: '))
</code></pre>
<!-- end verbatim block -->
Typing, for example, <code>3</code> makes <code>var</code> refer to an <code>int</code> object, <code>3.14</code>
results in a <code>float</code> object, <code>[-1,1]</code> results in a <code>list</code>, <code>(1,3,5,7)</code>
in a <code>tuple</code>, and <code>some text</code> in the string (<code>str</code>) object <code>'some
text'</code> (run the program <a href="http://tinyurl.com/pwyasaa/input/str2obj_demo.py" target="_self"><tt>str2obj_demo.py</tt></a> to see this functionality
demonstrated).

<h3 id="___sec69">Getting command-line arguments </h3>

<p>
The <code>sys.argv[1:]</code> list contains all the command-line arguments
given to a program (<code>sys.argv[0]</code> contains the program name).
All elements in <code>sys.argv</code> are strings. A typical usage is

<p>
<!-- begin verbatim block  pycod-->
<pre><code>parameter1 = float(sys.argv[1])
parameter2 = int(sys.argv[2])
parameter3 = sys.argv[3]          # parameter3 can be string
</code></pre>
<!-- end verbatim block -->

<h3 id="___sec70">Using option-value pairs </h3>

<p>
The <code>argparse</code> module is recommended for
interpreting command-line arguments of the form <code>--option value</code>.
A simple recipe with <code>argparse</code> reads

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import argparse
parser = argparse.ArgumentParser()
parser.add_argument('--p1', '--parameter_1', type=float,
                    default=0.0, help='1st parameter')
parser.add_argument('--p2', type=float,
                    default=0.0, help='2nd parameter')

args = parser.parse_args()
p1 = args.p1
p2 = args.p2
</code></pre>
<!-- end verbatim block -->
On the command line we can provide any or all of these options:

<p>
<!-- begin verbatim block  ccq-->
<pre><code>--parameter_1 --p1 --p2
</code></pre>
<!-- end verbatim block -->
where each option must be succeeded by a suitable value.
However, <code>argparse</code> is very flexible can easily handle options
without values or command-line arguments without any
option specifications.

<h3 id="___sec71">Generating code on the fly </h3>

<p>
Calling <code>eval(s)</code> turns a string <code>s</code>, containing a Python
expression, into code as if the contents of the string were written
directly into the program code. The result of the following
<code>eval</code> call is a <code>float</code> object holding the number 21.1:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; x = 20
&gt;&gt;&gt; r = eval('x + 1.1')
&gt;&gt;&gt; r
21.1
&gt;&gt;&gt; type(r)
&lt;type 'float'&gt;
</code></pre>
<!-- end verbatim block -->
The <code>exec</code> function takes a string with arbitrary Python code
as argument and executes the code. For example, writing

<p>
<!-- begin verbatim block  pycod-->
<pre><code>exec(&quot;&quot;&quot;
def f(x):
    return %s
&quot;&quot;&quot; % sys.argv[1])
</code></pre>
<!-- end verbatim block -->
is the same as if we had hardcoded the (for the programmer unknown)
contents of <code>sys.argv[1]</code>
into a function definition in the program.

<h3 id="___sec72">Turning string formulas into Python functions </h3>

<p>
Given a mathematical formula as a string, <code>s</code>, we can turn this
formula into a callable Python function <code>f(x)</code> by

<p>
<!-- begin verbatim block  pycod-->
<pre><code>from scitools.std import StringFunction

f = StringFunction(s)
</code></pre>
<!-- end verbatim block -->
The string formula can contain parameters and an independent variable
with another name than <code>x</code>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>Q_formula = 'amplitude*sin(w*t-phaseshift)'
Q = StringFunction(Q_formula, independent_variable='t',
                   amplitude=1.5, w=pi, phaseshift=0)
values1 = [Q(i*0.1) for t in range(10)]
Q.set_parameters(phaseshift=pi/4, amplitude=1)
values2 = [Q(i*0.1) for t in range(10)]
</code></pre>
<!-- end verbatim block -->
Functions of several independent variables are also supported:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>f = StringFunction('x+y**2+A', independent_variables=('x', 'y'),
                   A=0.2)
x = 1; y = 0.5
print f(x, y)
</code></pre>
<!-- end verbatim block -->

<h3 id="___sec73">File operations </h3>

<p>
Reading from or writing to a file first requires that the file
is opened, either for reading, writing, or appending:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>infile  = open(filename, 'r')   # read
outfile = open(filename, 'w')   # write
outfile = open(filename, 'a')   # append
</code></pre>
<!-- end verbatim block -->
or using <code>with</code>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>with open(filename, 'r') as infile:   # read
with open(filename, 'w') as outfile:  # write
with open(filename, 'a') as outfile:  # append
</code></pre>
<!-- end verbatim block -->
There are four basic reading commands:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>line    = infile.readline()   # read the next line
filestr = infile.read()       # read rest of file into string
lines   = infile.readlines()  # read rest of file into list
for line in infile:           # read rest of file line by line
</code></pre>
<!-- end verbatim block -->
File writing is usually about repeatedly using the command

<p>
<!-- begin verbatim block  pycod-->
<pre><code>outfile.write(s)
</code></pre>
<!-- end verbatim block -->
where <code>s</code> is a string. Contrary to <code>print s</code>,
no newline is added to <code>s</code> in <code>outfile.write(s)</code>.

<p>
After reading or writing is finished, the file must be closed:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>somefile.close()
</code></pre>
<!-- end verbatim block -->
However, closing the file is not necessary if we employ the <code>with</code> statement for
reading or writing files:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>with open(filename, 'w') as outfile:
    for var1, var2 in data:
        outfile.write('%5.2f %g\n' % (var1, var2))
# outfile is closed
</code></pre>
<!-- end verbatim block -->

<h3 id="___sec74">Handling exceptions </h3>

<p>
Testing for potential errors is done with <code>try-except</code> blocks:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>try:
    &lt;statements&gt;
except ExceptionType1:
    &lt;provide a remedy for ExceptionType1 errors&gt;
except ExceptionType2, ExceptionType3, ExceptionType4:
    &lt;provide a remedy for three other types of errors&gt;
except:
    &lt;provide a remedy for any other errors&gt;
...
</code></pre>
<!-- end verbatim block -->
The most common exception types are
<code>NameError</code> for an undefined variable, <code>TypeError</code> for an
illegal value
in an operation, and <code>IndexError</code> for a list index out of bounds.

<h3 id="___sec75">Raising exceptions </h3>

<p>
When some error is encountered in a program, the programmer can
raise an exception:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>if z &lt; 0:
    raise ValueError('z=%s is negative - cannot do log(z)' % z)
r = log(z)
</code></pre>
<!-- end verbatim block -->

<h3 id="___sec76">Modules </h3>

<p>
A module is created by putting a set of functions
in a file. The filename (minus the required extension <code>.py</code>)
is the name of the module.
Other programs can import the module only if it resides in the
same folder or in a folder contained in the <code>sys.path</code>
list (see the section <a href="._input-solarized009.html#sec:input:modules:usage">Using modules</a> for how to
deal with this potential problem).
Optionally, the module file can have a special <code>if</code> construct
at the end, called test block, which tests the module or demonstrates
its usage. The test block does not get executed when the module is
imported in another program, only when the module file is run as
a program.

<h3 id="___sec77">Terminology </h3>

<p>
The important computer science topics and Python tools in this document are

<ul>
 <li> command line</li>
 <li> <code>sys.argv</code></li>
 <li> <code>raw_input</code></li>
 <li> <code>eval</code> and <code>exec</code></li>
 <li> file reading and writing</li>
 <li> handling and raising exceptions</li>
 <li> module</li>
 <li> test block</li>
</ul>

<h2 id="sec:input:summarizingex">Example: Bisection root finding</h2>

<h3 id="___sec79">Problem </h3>

<p>
The summarizing example of this document concerns the implementation
of the Bisection method for solving nonlinear equations of the
form \( f(x)=0 \) with respect to \( x \). For example, the equation

$$
\begin{equation*} x = 1 + \sin x\end{equation*}
$$

can be cast in the form \( f(x)=0 \) if we move all terms to the
left-hand side and define
\( f(x)=x-1-\sin x \). We say that \( x \) is a <em>root</em> of the equation
\( f(x)=0 \) if \( x \) is a solution of this equation. Nonlinear equations
\( f(x)=0 \) can have zero, one, several, or infinitely many roots.

<p>
Numerical methods for computing roots normally lead to approximate
results only, i.e., \( f(x) \) is not made exactly zero, but very close to
zero.  More precisely, an approximate root \( x \) fulfills
\( |f(x)|\leq\epsilon \), where \( \epsilon \) is a small number.  Methods for
finding roots are of an iterative nature: we start with a rough
approximation to a root and perform a repetitive set of steps that aim
to improve the approximation.  Our particular method for computing
roots, the Bisection method, guarantees to find an
approximate root, while other methods, such as the widely used
Newton's
method,
can fail to find roots.

<p>
The idea of the Bisection method is to start with an interval \( [a,b] \)
that contains a root of \( f(x) \). The interval is halved at \( m=(a+b)/2 \),
and if \( f(x) \)
changes sign in the left half interval \( [a,m] \), one continues with that
interval, otherwise one continues with the right half interval \( [m,b] \).
This procedure is repeated, say \( n \) times, and the root is then
guaranteed to be inside an interval of length \( 2^{-n}(b-a) \).
The task is to write a program that implements the Bisection method
and verify the implementation.

<h3 id="___sec80">Solution </h3>

<p>
To implement the Bisection method, we need to translate the description in
the previous paragraph to a precise algorithm that can be almost directly
translated to computer code. Since the halving of the interval is
repeated many times, it is natural to do this inside a loop. We
start with the interval \( [a,b] \), and adjust \( a \) to \( m \) if the root must
be in the right half of the interval, or we adjust \( b \) to \( m \) if the
root must be in the left half. In a language close to computer code
we can express the algorithm precisely as follows:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>for i in range(0, n+1):
    m = (a + b)/2
    if f(a)*f(m) &lt;= 0:
        b = m  # root is in left half
    else:
        a = m  # root is in right half

# f(x) has a root in [a,b]
</code></pre>
<!-- end verbatim block -->

<p>
Figure <a href="#fig:plot:bisection:iter">2</a> displays graphically
the first four steps of
this algorithm for solving the equation \( \cos (\pi x)=0 \), starting
with the interval \( [0, 0.82] \). The graphs are automatically produced
by the program <code>bisection_movie.py</code>, which was run as follows
for this particular example:

<p>
<!-- begin verbatim block  sys-->
<pre><code>bisection_movie.py 'cos(pi*x)' 0 0.82
</code></pre>
<!-- end verbatim block -->
The first command-line argument is the formula for \( f(x) \), the next is
\( a \), and the final is \( b \).

<p>
<center> <!-- figure label: --> <div id="fig:plot:bisection:iter"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 2:  Illustration of the first four iterations of the Bisection algorithm for solving \( \cos (\pi x) =0 \). The vertical lines correspond to the current value of \( a \) and \( b \).  <!-- caption label: fig:plot:bisection:iter --> </p></center>
<p><img src="fig-input/bisection_iter.png" align="bottom" width=400></p>
</center>

<p>
In the algorithm listed above,
we recompute \( f(a) \) in each <code>if</code>-test, but this is
not necessary if \( a \) has not changed since the last \( f(a) \) computations.
It is a good habit in numerical programming to avoid
redundant work.
On modern computers the Bisection algorithm normally runs so fast that
we can afford to do more work than necessary. However, if \( f(x) \) is not
a simple formula, but computed by comprehensive calculations in a
program, the evaluation of \( f \) might take minutes or even hours, and
reducing the number of evaluations in the Bisection algorithm is then
very important. We will therefore introduce extra variables in the
algorithm above to save an \( f(m) \) evaluation in each iteration in the
<code>for</code> loop:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>f_a = f(a)
for i in range(0, n+1):
    m = (a + b)/2
    f_m = f(m)
    if f_a*f_m &lt;= 0:
        b = m   # root is in left half
    else:
        a = m   # root is in right half
        f_a = f_m

# f(x) has a root in [a,b]
</code></pre>
<!-- end verbatim block -->

<p>
To execute the algorithm above, we need to specify \( n \). Say we want
to be sure that the root lies in an interval of maximum extent \( \epsilon \).
After \( n \) iterations the length of our current interval is
\( 2^{-n}(b-a) \), if \( [a,b] \) is the initial interval. The current interval
is sufficiently small if

$$
\begin{equation*} 2^{-n}(b-a) = \epsilon,\end{equation*}
$$

which implies

$$
\begin{equation} n = - {\ln\epsilon -\ln (b-a)\over\ln 2}\tp \tag{6}
\end{equation}
$$

<p>
Instead of calculating this \( n \), we may simply stop the iterations when
the length of the current interval is less than \( \epsilon \). The loop
is then naturally implemented as a <code>while</code> loop testing on
whether \( b-a \leq\epsilon \). To make the algorithm more foolproof,
we also insert a test to ensure that \( f(x) \) really changes sign
in the initial interval. This guarantees a root
in \( [a,b] \). (However, \( f(a)f(b) < 0 \) is not a necessary condition
if there is an even number of roots in the initial interval.)

<p>
Our final version of the Bisection algorithm now becomes

<p>
<!-- begin verbatim block  pycod-->
<pre><code>f_a=f(a)
if f_a*f(b) &gt; 0:
    # error: f does not change sign in [a,b]

i = 0
while b-a &gt; epsilon:
    i = i + 1
    m = (a + b)/2
    f_m = f(m)
    if f_a*f_m &lt;= 0:
        b = m  # root is in left half
    else:
        a = m  # root is in right half
        f_a = f_m

# if x is the real root, |x-m| &lt; epsilon
</code></pre>
<!-- end verbatim block -->
This is the algorithm we aim to implement in a Python program.

<p>
<!-- === A Simple Program === -->

<p>
A direct translation of the previous algorithm to a valid
Python program is a matter of some minor edits:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>eps = 1E-5
a, b = 0, 10

fa = f(a)
if fa*f(b) &gt; 0:
    print 'f(x) does not change sign in [%g,%g].' % (a, b)
    sys.exit(1)

i = 0   # iteration counter
while b-a &gt; eps:
    i += 1
    m = (a + b)/2.0
    fm = f(m)
    if fa*fm &lt;= 0:
        b = m  # root is in left half of [a,b]
    else:
        a = m  # root is in right half of [a,b]
        fa = fm
    print 'Iteration %d: interval=[%g, %g]' % (i, a, b)
    
x = m          # this is the approximate root
print 'The root is', x, 'found in', i, 'iterations'
print 'f(%g)=%g' % (x, f(x))
</code></pre>
<!-- end verbatim block -->
This program is found in the file
<a href="http://tinyurl.com/pwyasaa/input/bisection_v1.py" target="_self"><tt>bisection_v1.py</tt></a>.

<h3 id="___sec81">Verification </h3>

<p>
To verify the implementation in <code>bisection_v1.py</code> we choose a very
simple \( f(x) \) where we know the exact root. One suitable example is a linear
function, \( f(x)=2x-3 \) such that \( x=3/2 \)
is the root of \( f \). As can be seen from the source code above,
we have inserted a <code>print</code> statement inside the
<code>while</code> loop to control that the program really does the right
things.
Running the program yields the output

<p>
<!-- begin verbatim block  ccq-->
<pre><code>Iteration 1: interval=[0, 5]
Iteration 2: interval=[0, 2.5]
Iteration 3: interval=[1.25, 2.5]
Iteration 4: interval=[1.25, 1.875]
...
Iteration 19: interval=[1.5, 1.50002]
Iteration 20: interval=[1.5, 1.50001]
The root is 1.50000572205 found in 20 iterations
f(1.50001)=1.14441e-05
</code></pre>
<!-- end verbatim block -->
It seems that the implementation works. Further checks should include
hand calculations for the first (say) three iterations and comparison
of the results with the program.

<h3 id="___sec82">Making a function </h3>

<p>
The previous implementation of the bisection algorithm is fine for
many purposes. To solve a new problem \( f(x)=0 \) it is just necessary
to change the <code>f(x)</code> function in the program. However, if we
encounter solving \( f(x)=0 \) in another program in another context,
we must put the bisection algorithm into that program in the right
place. This is simple in practice, but it requires some careful work,
and it is easy to make errors. The task of solving \( f(x)=0 \) by
the bisection algorithm is much simpler and safer if we have that
algorithm available as a function in a module. Then we can just
import the function and call it. This requires a minimum of writing
in later programs.

<p>
When you have a &quot;flat&quot; program as shown above, without basic steps
in the program collected in functions, you should always consider
dividing the code into functions. The reason is that parts of the
program will be much easier to reuse in other programs.
You save coding, and that is a good rule! A program with functions
is also easier to understand, because statements are collected into
logical, separate units, which is another good rule! In a mathematical
context, functions are particularly important since they naturally
split the code into general algorithms (like the bisection algorithm)
and a problem-specific part (like a special choice of \( f(x) \)).

<p>
Shuffling statements in a program around to form a new and better
designed version of the program is called <em>refactoring</em>.
We shall now refactor the <code>bisection_v1.py</code> program by putting
the statements in the bisection algorithm in a function
<code>bisection</code>. This function naturally takes \( f(x) \), \( a \), \( b \), and
\( \epsilon \) as parameters and returns the found root, perhaps together
with the number of iterations required:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def bisection(f, a, b, eps):
    fa = f(a)
    if fa*f(b) &gt; 0:
        return None, 0

    i = 0   # iteration counter
    while b-a &gt; eps:
        i += 1
        m = (a + b)/2.0
        fm = f(m)
        if fa*fm &lt;= 0:
            b = m  # root is in left half of [a,b]
        else:
            a = m  # root is in right half of [a,b]
            fa = fm
    return m, i
</code></pre>
<!-- end verbatim block -->
After this function we can have a test program:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def f(x):
    return 2*x - 3   # one root x=1.5

x, iter = bisection(f, a=0, b=10, eps=1E-5)
if x is None:
    print 'f(x) does not change sign in [%g,%g].' % (a, b)
else:
    print 'The root is', x, 'found in', iter, 'iterations'
    print 'f(%g)=%g' % (x, f(x))
</code></pre>
<!-- end verbatim block -->
The complete code is found in file
<a href="http://tinyurl.com/pwyasaa/input/bisection_v2.py" target="_self"><tt>bisection_v2.py</tt></a>.

<h3 id="___sec83">Making a test function </h3>

<p>
Rather than having a main program as above for verifying the
implementation, we should make a test function <code>test_bisection</code> as
described in the section <a href="._input-solarized009.html#sec:input:modules:testfunc">Verification of the module code</a>. To this end, we
move the statements above inside a function, drop the output, but
instead make a boolean variable <code>success</code> that is <code>True</code> if the test
is passed and <code>False</code> otherwise. Then we do <code>assert success, msg</code>,
which will abort the program if the test fails. The <code>msg</code> variable is
a string with more explanation of what went wrong the test fails.
A test function with this structure is easy to integrate
into the widely used testing frameworks nose and pytest, and there are no good
reasons for not adopting this structure.  The code checking that
the root is within a distance \( \epsilon \) to the exact root becomes

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def test_bisection():
    def f(x):
        return 2*x - 3   # one root x=1.5

    eps = 1E-5
    x_expected = 1.5
    x, iter = bisection(f, a=0, b=10, eps=eps)
    success = abs(x - x_expected) &lt; eps  # test within eps tolerance
    assert success, 'found x=%g != 1.5' % x
</code></pre>
<!-- end verbatim block -->

<h3 id="___sec84">Making a module </h3>

<p>
A motivating factor for implementing the bisection algorithm as a function
<code>bisection</code> was that we could import this function in other
programs to solve \( f(x)=0 \) equations. We therefore need to make a module
file <code>bisection.py</code> such that we can do, e.g.,

<p>
<!-- begin verbatim block  pycod-->
<pre><code>from bisection import bisection
x, iter = bisection(lambda x: x**3 + 2*x -1, -10, 10, 1E-5)
</code></pre>
<!-- end verbatim block -->
A module file should not execute a main program, but just
define functions, import modules, and define global variables.
Any execution of a main program must take place in the test
block, otherwise the <code>import</code> statement will start executing
the main program, resulting in very
disturbing statements for another program that
wants to solve a different \( f(x)=0 \) equation.

<p>
The <code>bisection_v2.py</code> file had a main program that was just a
simple test for checking that the <code>bisection</code> algorithm works
for a linear function. We took this main program and wrapped
in a test function <code>test_bisection</code> above. To run the test,
we make the call to this function from the test block:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>if __name__ == '__main__':
    test_bisection()
</code></pre>
<!-- end verbatim block -->
This is all that is demanded to turn the file <code>bisection_v2.py</code>
into a proper module file <code>bisection.py</code>.

<h3 id="___sec85">Defining a user interface </h3>

<p>
It is nice to have our <code>bisection</code> module do more than just test
itself: there should be a user interface such that we can
solve real problems \( f(x)=0 \), where \( f(x) \), \( a \), \( b \), and \( \epsilon \)
are defined on the command line by the user. A dedicated function
can read from the command line and return the data as Python
object. For reading the function \( f(x) \) we can either apply
<code>eval</code> on the command-line argument, or use the more sophisticated
<code>StringFunction</code> tool from the section <a href="._input-solarized003.html#sec:input:StringFunction">Turning string expressions into functions</a>.
With <code>eval</code> we need to import functions from the <code>math</code> module in
case the user have such functions in the expression for \( f(x) \).
With <code>StringFunction</code> this is not necessary.

<p>
A <code>get_input()</code> for getting input from the command line can be
implemented as

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def get_input():
    &quot;&quot;&quot;Get f, a, b, eps from the command line.&quot;&quot;&quot;
    from scitools.std import StringFunction
    try:
        f = StringFunction(sys.argv[1])
        a = float(sys.argv[2])
        b = float(sys.argv[3])
        eps = float(sys.argv[4])
    except IndexError:
        print 'Usage %s: f a b eps' % sys.argv[0]
        sys.exit(1)
    return f, a, b, eps
</code></pre>
<!-- end verbatim block -->
To solve the corresponding \( f(x)=0 \) problem, we simply add a branch
in the <code>if</code> test in the test block:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>if __name__ == '__main__':
    import sys
    if len(sys.argv) &gt;= 2 and sys.argv[1] == 'test':
        test_bisection()
    else:
        f, a, b, eps = get_input()
        x, iter = bisection(f, a, b, eps)
        print 'Found root x=%g in %d iterations' % (x, iter)
</code></pre>
<!-- end verbatim block -->

<p>
<div class="alert alert-block alert-summary alert-text-normal">
<b>Desired properties of a module.</b>
<p>
Our <a href="http://tinyurl.com/pwyasaa/input/bisection.py" target="_self"><tt>bisection.py</tt></a> code is
a complete module file with the following generally desired features
of Python modules:

<ul>
 <li> other programs can import the <code>bisection</code> function,</li>
 <li> the module can test itself (with a pytest/nose-compatible test function),</li>
 <li> the module file can be run as a program with a user interface
   where a general rooting finding problem can be specified in
   terms of a formula for \( f(x) \) along with the parameters \( a \), \( b \),
   and \( \epsilon \).</li>
</ul>
</div>


<h3 id="___sec86">Using the module </h3>

<p>
Suppose you want to solve \( x/(x-1)=\sin x \) using the <code>bisection</code> module.
What do you have to do? First, you must reformulate the equation as
\( f(x)=0 \), i.e., \( x/(x-1)-\sin x = 0 \), or maybe multiply by
\( x-1 \) to get \( f(x)=x-(x-1)\sin x \).

<p>
It is required to identify an interval for the root. By evaluating \( f(x) \)
for some points \( x \) one can be trial and error locate an interval.
A more convenient approach is to plot
the function \( f(x) \) and visually inspect where a root is.
We start <code>ipython --pylab</code> and write
<!-- begin verbatim block  ipy-->
<pre><code>In [1]: x = linspace(-3, 3, 50)  # generate 50 coordinates in [-3,3]

In [2]: y = x - (x-1)*sin(x)

In [3]: plot(x, y)
</code></pre>
<!-- end verbatim block -->
Figure <a href="#fig:plot:bisection:xsinx">3</a> shows \( f(x) \) and we clearly see
that, e.g., \( [-2, 1] \) is an appropriate interval.

<p>
<center> <!-- figure label: --> <div id="fig:plot:bisection:xsinx"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 3:  Plot of \( f(x)=x - \sin (x) \).  <!-- caption label: fig:plot:bisection:xsinx --> </p></center>
<p><img src="fig-input/f_x_xm1sinx.png" align="bottom" width=500></p>
</center>

<p>
The next step is to run the Bisection algorithm.
There are two possibilities:

<ul>
 <li> make a program where you code \( f(x) \) and run the <code>bisection</code> function, or</li>
 <li> run the <code>bisection.py</code> program directly.</li>
</ul>

The latter approach is the simplest:

<p>
<!-- begin verbatim block  sys-->
<pre><code>bisection.py &quot;x - (x-1)*sin(x)&quot; -2 1 1E-5
Found root x=-1.90735e-06 in 19 iterations
</code></pre>
<!-- end verbatim block -->

<p>
The alternative approach is to make a program:

<p>
<!-- begin verbatim block  pypro-->
<pre><code>from bisection import bisection
from math import sin

def f(x):
    return x - (x-1)*sin(x)

x, iter = bisection(f, a=-2, b=1, eps=1E-5)
print x, iter
</code></pre>
<!-- end verbatim block -->

<h3 id="___sec87">Potential problems with the software </h3>

<p>
Let us solve

<ul>
  <li> \( x = \tanh x \) with start interval \( [-10,10] \) and \( \epsilon=10^{-6} \),</li>
  <li> \( x^5 = \tanh (x^5) \) with start interval \( [-10,10] \) and \( \epsilon=10^{-6} \).</li>
</ul>

Both equations have one root \( x=0 \).

<p>
<!-- begin verbatim block  sys-->
<pre><code>bisection.py &quot;x-tanh(x)&quot; -10 10
Found root x=-5.96046e-07 in 25 iterations

bisection.py &quot;x**5-tanh(x**5)&quot; -10 10
Found root x=-0.0266892 in 25 iterations
</code></pre>
<!-- end verbatim block -->
These results look strange. In both cases we halve the start
interval \( [-10,10] \) 25 times, but in the second case we end
up with a much less accurate root although the value of \( \epsilon \)
is the same. A closer inspection of what goes on in the bisection
algorithm reveals that the inaccuracy is caused by rounding
errors. As \( a, b, m\rightarrow 0 \), raising a small number to the
fifth power in the expression for \( f(x) \) yields a much smaller result.
Subtracting a very small number \( \tanh x^5 \) from another
very small number \( x^5 \) may result in a small number with wrong
sign, and the sign of \( f \) is essential in the bisection algorithm.
We encourage the reader to graphically inspect this behavior by
running these two examples with the
<a href="http://tinyurl.com/pwyasaa/input/bisection_plot.py" target="_self"><tt>bisection_plot.py</tt></a> program
using a smaller interval \( [-1,1] \) to better see what is going on.
The command-line arguments for the <code>bisection_plot.py</code> program
are <code>'x-tanh(x)' -1 1</code> and <code>'x**5-tanh(x**5)' -1 1</code>.
The very flat area, in the latter case, where \( f(x)\approx 0 \) for
\( x\in [-1/2, 1/2] \) illustrates
well that it is difficult to locate an exact root.

<h3 id="___sec88">Distributing the bisection module to others </h3>

<p>
The Python standard for installing software is to run a <code>setup.py</code> program,

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; sudo python setup.py install
</code></pre>
<!-- end verbatim block -->
to install the system. The relevant <code>setup.py</code> for the <code>bisection</code>
module arises from substituting the name <code>interest</code> by <code>bisection</code>
in the <code>setup.py</code> file listed in
the section <a href="._input-solarized009.html#sec:input:modules:setuppy">Distributing modules</a>. You can then distribute
<code>bisection.py</code> and <code>setup.py</code> together.

<p>
<p>
<!-- begin bottom navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._input-solarized010.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._input-solarized012.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end bottom navigation -->
</p>

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

