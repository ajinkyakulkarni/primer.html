<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="User input and error handling">
<meta name="keywords" content="command-line arguments,option-value pairs (command line),standard input,standard output,standard error,bytes,bits,exceptions,widgets,event loop,modules,test block (in module files),test function,nose tests,pytest tests,search for module files,module folders,refactoring,binomial distribution,Bernoulli trials,Poisson distribution,Poisson process">

<title>User input and error handling</title>


<link href="https://raw.githubusercontent.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="http://www.peterhaschke.com/assets/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>

</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [(' Asking questions and reading answers ',
               1,
               'sec:input:rawinput',
               'sec:input:rawinput'),
              (' Reading keyboard input ',
               2,
               'sec:input:rawinput2',
               'sec:input:rawinput2'),
              (' Reading from the command line ',
               1,
               'sec:input:sysargv',
               'sec:input:sysargv'),
              (' Providing input on the command line ',
               2,
               'sec:input:cml',
               'sec:input:cml'),
              (' A variable number of command-line arguments ',
               2,
               None,
               '___sec4'),
              (' More on command-line arguments ', 2, None, '___sec5'),
              (' Turning user text into live objects ', 1, None, '___sec6'),
              (' The magic eval function ',
               2,
               'sec:input:eval',
               'sec:input:eval'),
              (' Applying eval to strings ', 3, None, '___sec8'),
              (' Applying eval to user input ', 3, None, '___sec9'),
              (' The magic exec function ',
               2,
               'sec:input:exec',
               'sec:input:exec'),
              (' Turning string expressions into functions ',
               2,
               'sec:input:StringFunction',
               'sec:input:StringFunction'),
              (' Option-value pairs on the command line ',
               1,
               'sec:input:argparse',
               'sec:input:argparse'),
              (' Basic usage of the argparse module ', 2, None, '___sec13'),
              (' Mathematical expressions as values ', 2, None, '___sec14'),
              (' Reading data from file ',
               1,
               'sec:files:reading',
               'sec:files:reading'),
              (' Reading a file line by line ', 2, None, '___sec16'),
              (' Alternative ways of reading a file ',
               2,
               'sec:files:reading:other',
               'sec:files:reading:other'),
              (' The modern with statement ', 3, None, '___sec18'),
              (' The old while construction ', 3, None, '___sec19'),
              (' Reading a file into a string ', 3, None, '___sec20'),
              (' Reading a mixture of text and numbers ',
               2,
               'sec:files:textnum',
               'sec:files:textnum'),
              (' Is it more to file reading? ', 3, None, '___sec22'),
              (' Writing data to file ',
               1,
               'sec:files:writing',
               'sec:files:writing'),
              (' Example: Writing a table to file ', 2, None, '___sec24'),
              (' Problem ', 3, None, '___sec25'),
              (' Solution ', 3, None, '___sec26'),
              (' Standard input and output as file objects ',
               2,
               None,
               '___sec27'),
              (' Redirecting standard input, output, and error ',
               3,
               None,
               '___sec28'),
              (' Note ', 3, None, '___sec29'),
              (' What is a file, really? ',
               2,
               'sec:files:really',
               'sec:files:really'),
              (' Pure text files ', 3, None, '___sec31'),
              (' Word processor files ', 3, None, '___sec32'),
              (' Image files ', 3, None, '___sec33'),
              (' Music files ', 3, None, '___sec34'),
              (' PDF files ', 3, None, '___sec35'),
              (' Remarks ', 3, None, '___sec36'),
              (' Handling errors ',
               1,
               'sec:input:except',
               'sec:input:except'),
              (' Exception handling ',
               2,
               'sec:input:except:handling',
               'sec:input:except:handling'),
              (' Testing for a specific exception ', 3, None, '___sec39'),
              (' Examples on exception types ', 3, None, '___sec40'),
              (' Digression ', 3, None, '___sec41'),
              (' Raising exceptions ', 2, None, '___sec42'),
              (' Example ', 3, None, '___sec43'),
              (' A glimpse of graphical user interfaces ',
               1,
               'sec:input:GUI',
               'sec:input:GUI'),
              (' Making modules ',
               1,
               'sec:input:modules',
               'sec:input:modules'),
              (' Example: Interest on bank deposits ', 2, None, '___sec46'),
              (' Collecting functions in a module file ',
               2,
               'sec:input:module:create',
               'sec:input:module:create'),
              (' Test block ',
               2,
               'sec:input:module:testblock',
               'sec:input:module:testblock'),
              (' Example on a test block in a minimalistic module ',
               3,
               None,
               '___sec49'),
              (' A test block in the `interest` module ',
               3,
               None,
               '___sec50'),
              (' Verification of the module code ',
               2,
               'sec:input:modules:testfunc',
               'sec:input:modules:testfunc'),
              (' Getting input data ',
               2,
               'sec:input:modules:inputdata',
               'sec:input:modules:inputdata'),
              (' Doc strings in modules ', 2, None, '___sec53'),
              (' Using modules ',
               2,
               'sec:input:modules:usage',
               'sec:input:modules:usage'),
              (' What gets imported by various import statements? ',
               3,
               None,
               '___sec55'),
              (' How to make Python find a module file ',
               3,
               None,
               '___sec56'),
              (' How to make Python run the module file ',
               3,
               None,
               '___sec57'),
              (' Distributing modules ',
               2,
               'sec:input:modules:setuppy',
               'sec:input:modules:setuppy'),
              (' Making software available on the Internet ',
               2,
               None,
               '___sec59'),
              (' Summary ', 1, 'sec:input:summary', 'sec:input:summary'),
              (' Chapter topics ',
               2,
               'sec:input:summary:topics',
               'sec:input:summary:topics'),
              (' Question and answer input ', 3, None, '___sec62'),
              (' Getting command-line arguments ', 3, None, '___sec63'),
              (' Using option-value pairs ', 3, None, '___sec64'),
              (' Generating code on the fly ', 3, None, '___sec65'),
              (' Turning string formulas into Python functions ',
               3,
               None,
               '___sec66'),
              (' File operations ', 3, None, '___sec67'),
              (' Handling exceptions ', 3, None, '___sec68'),
              (' Raising exceptions ', 3, None, '___sec69'),
              (' Modules ', 3, None, '___sec70'),
              (' Terminology ', 3, None, '___sec71'),
              (' Example: Bisection root finding ',
               2,
               'sec:input:summarizingex',
               'sec:input:summarizingex'),
              (' Problem ', 3, None, '___sec73'),
              (' Solution ', 3, None, '___sec74'),
              (' Verification ', 3, None, '___sec75'),
              (' Making a function ', 3, None, '___sec76'),
              (' Making a test function ', 3, None, '___sec77'),
              (' Making a module ', 3, None, '___sec78'),
              (' Defining a user interface ', 3, None, '___sec79'),
              (' Using the module ', 3, None, '___sec80'),
              (' Potential problems with the software ', 3, None, '___sec81'),
              (' Distributing the bisection module to others ',
               3,
               None,
               '___sec82'),
              (' Exercises ', 1, None, '___sec83'),
              (' Exercise 1: Make an interactive program ',
               2,
               'sec:input:ex24',
               'sec:input:ex24'),
              (' Exercise 2: Read a number from the command line ',
               2,
               'sec:input:ex24b',
               'sec:input:ex24b'),
              (' Exercise 3: Read a number from a file ',
               2,
               'sec:input:ex24bfile',
               'sec:input:ex24bfile'),
              (' Exercise 4: Read and write several numbers from and to file ',
               2,
               'sec:input:ex24bfile2',
               'sec:input:ex24bfile2'),
              (' Exercise 5: Use exceptions to handle wrong input ',
               2,
               'sec:input:ex24c',
               'sec:input:ex24c'),
              (' Exercise 6: Read input from the keyboard ',
               2,
               'sec:input:ex25',
               'sec:input:ex25'),
              (' Exercise 7: Read input from the command line ',
               2,
               'sec:input:ex26',
               'sec:input:ex26'),
              (' Exercise 8: Try MSWord or LibreOffice to write a program ',
               2,
               'sec:files:ex7',
               'sec:files:ex7'),
              (' Exercise 9: Prompt the user for input to a formula ',
               2,
               'sec:input:ex6',
               'sec:input:ex6'),
              (' Exercise 10: Read parameters in a formula from the command line ',
               2,
               'sec:input:ex5',
               'sec:input:ex5'),
              (' Exercise 11: Use exceptions to handle wrong input ',
               2,
               'sec:input:ex8b',
               'sec:input:ex8b'),
              (' Exercise 12: Test validity of input data ',
               2,
               'sec:input:ex7',
               'sec:input:ex7'),
              (' Exercise 13: Raise an exception in case of wrong input ',
               2,
               'sec:input:ex8',
               'sec:input:ex8'),
              (' Exercise 14: Evaluate a formula for data in a file ',
               2,
               'sec:input:ex:ball:file',
               'sec:input:ex:ball:file'),
              (' Exercise 15: Compute the distance it takes to stop a car ',
               2,
               'sec:input:ex21',
               'sec:input:ex21'),
              (' Exercise 16: Look up calendar functionality ',
               2,
               'sec:input:ex48',
               'sec:input:ex48'),
              (' Exercise 17: Use the StringFunction tool ',
               2,
               'sec:input:ex28b',
               'sec:input:ex28b'),
              (' Exercise 18: Why we test for specific exception types ',
               2,
               'sec:input:ex11',
               'sec:input:ex11'),
              (' Exercise 19: Make a complete module ',
               2,
               'sec:input:ex27',
               'sec:input:ex27'),
              (' Exercise 20: Make a module ',
               2,
               'sec:input:ex17',
               'sec:input:ex17'),
              (' Exercise 21: Read options and values from the command line ',
               2,
               'sec:input:ex19',
               'sec:input:ex19'),
              (' Exercise 22: Check if mathematical identities hold ',
               2,
               'sec:input:ex2',
               'sec:input:ex2'),
              (' Exercise 23: Compute probabilities with the binomial distribution ',
               2,
               'sec:input:ex15',
               'sec:input:ex15'),
              (' Exercise 24: Compute probabilities with the Poisson distribution ',
               2,
               'sec:input:ex16',
               'sec:input:ex16'),
              (' References ', 1, None, '___sec108')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\tp}{\thinspace .}
$$




    
<a name="part0000"></a>
<p>
<!-- begin top navigation -->
<table style="width: 100%"><tr><td>
</td><td>
</td></tr></table>
<!-- end top navigation -->
</p>

<p>
<!-- ------------------- main content ---------------------- -->



<center><h1>User input and error handling</h1></center>  <!-- document title -->

<p>
<!-- author(s): Hans Petter Langtangen -->

<center>
<b>Hans Petter Langtangen</b> [1, 2]
</center>


<p>
<!-- institution(s) -->

<center>[1] <b>Center for Biomedical Computing, Simula Research Laboratory</b></center>
<center>[2] <b>Department of Informatics, University of Oslo</b></center>
<p>
<center><h4>Aug 31, 2014</h4></center> <!-- date -->

<h2>Table of contents</h2>

<a href="#sec:input:rawinput"> Asking questions and reading answers </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:input:rawinput2"> Reading keyboard input </a><br>
<a href="#sec:input:sysargv"> Reading from the command line </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:input:cml"> Providing input on the command line </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec4"> A variable number of command-line arguments </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec5"> More on command-line arguments </a><br>
<a href="#___sec6"> Turning user text into live objects </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:input:eval"> The magic eval function </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec8"> Applying eval to strings </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec9"> Applying eval to user input </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:input:exec"> The magic exec function </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:input:StringFunction"> Turning string expressions into functions </a><br>
<a href="#sec:input:argparse"> Option-value pairs on the command line </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec13"> Basic usage of the argparse module </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec14"> Mathematical expressions as values </a><br>
<a href="#sec:files:reading"> Reading data from file </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec16"> Reading a file line by line </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:reading:other"> Alternative ways of reading a file </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec18"> The modern with statement </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec19"> The old while construction </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec20"> Reading a file into a string </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:textnum"> Reading a mixture of text and numbers </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec22"> Is it more to file reading? </a><br>
<a href="#sec:files:writing"> Writing data to file </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec24"> Example: Writing a table to file </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec25"> Problem </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec26"> Solution </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec27"> Standard input and output as file objects </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec28"> Redirecting standard input, output, and error </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec29"> Note </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:really"> What is a file, really? </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec31"> Pure text files </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec32"> Word processor files </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec33"> Image files </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec34"> Music files </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec35"> PDF files </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec36"> Remarks </a><br>
<a href="#sec:input:except"> Handling errors </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:input:except:handling"> Exception handling </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec39"> Testing for a specific exception </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec40"> Examples on exception types </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec41"> Digression </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec42"> Raising exceptions </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec43"> Example </a><br>
<a href="#sec:input:GUI"> A glimpse of graphical user interfaces </a><br>
<a href="#sec:input:modules"> Making modules </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec46"> Example: Interest on bank deposits </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:input:module:create"> Collecting functions in a module file </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:input:module:testblock"> Test block </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec49"> Example on a test block in a minimalistic module </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec50"> A test block in the <code>interest</code> module </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:input:modules:testfunc"> Verification of the module code </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:input:modules:inputdata"> Getting input data </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec53"> Doc strings in modules </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:input:modules:usage"> Using modules </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec55"> What gets imported by various import statements? </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec56"> How to make Python find a module file </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec57"> How to make Python run the module file </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:input:modules:setuppy"> Distributing modules </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec59"> Making software available on the Internet </a><br>
<a href="#sec:input:summary"> Summary </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:input:summary:topics"> Chapter topics </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec62"> Question and answer input </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec63"> Getting command-line arguments </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec64"> Using option-value pairs </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec65"> Generating code on the fly </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec66"> Turning string formulas into Python functions </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec67"> File operations </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec68"> Handling exceptions </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec69"> Raising exceptions </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec70"> Modules </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec71"> Terminology </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:input:summarizingex"> Example: Bisection root finding </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec73"> Problem </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec74"> Solution </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec75"> Verification </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec76"> Making a function </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec77"> Making a test function </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec78"> Making a module </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec79"> Defining a user interface </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec80"> Using the module </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec81"> Potential problems with the software </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec82"> Distributing the bisection module to others </a><br>
<a href="#___sec83"> Exercises </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:input:ex24"> Exercise 1: Make an interactive program </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:input:ex24b"> Exercise 2: Read a number from the command line </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:input:ex24bfile"> Exercise 3: Read a number from a file </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:input:ex24bfile2"> Exercise 4: Read and write several numbers from and to file </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:input:ex24c"> Exercise 5: Use exceptions to handle wrong input </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:input:ex25"> Exercise 6: Read input from the keyboard </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:input:ex26"> Exercise 7: Read input from the command line </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:ex7"> Exercise 8: Try MSWord or LibreOffice to write a program </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:input:ex6"> Exercise 9: Prompt the user for input to a formula </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:input:ex5"> Exercise 10: Read parameters in a formula from the command line </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:input:ex8b"> Exercise 11: Use exceptions to handle wrong input </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:input:ex7"> Exercise 12: Test validity of input data </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:input:ex8"> Exercise 13: Raise an exception in case of wrong input </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:input:ex:ball:file"> Exercise 14: Evaluate a formula for data in a file </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:input:ex21"> Exercise 15: Compute the distance it takes to stop a car </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:input:ex48"> Exercise 16: Look up calendar functionality </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:input:ex28b"> Exercise 17: Use the StringFunction tool </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:input:ex11"> Exercise 18: Why we test for specific exception types </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:input:ex27"> Exercise 19: Make a complete module </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:input:ex17"> Exercise 20: Make a module </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:input:ex19"> Exercise 21: Read options and values from the command line </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:input:ex2"> Exercise 22: Check if mathematical identities hold </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:input:ex15"> Exercise 23: Compute probabilities with the binomial distribution </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:input:ex16"> Exercise 24: Compute probabilities with the Poisson distribution </a><br>
<a href="#___sec108"> References </a><br>
</p>
<p>
<!-- Externaldocuments: ../formulas/main_formulas, ../looplist/main_looplist, ../funcif/main_funcif, ../plot/main_plot, ../files/main_files, ../class/main_class, ../random/main_random, ../oo/main_oo, ../diffeq/main_diffeq, ../discalc/main_discalc, ../ode1/main_ode1, ../boxspring/main_boxspring, ../ode2/main_ode2, ../debug/main_debug, ../cython/main_cython, ../tech/main_timing, ../tech/main_varargs, ../tech/main_runpy, ../tech/main_ostasks, ../tech/main_accesspy, ../tech/main_nose -->

<p>
<a name="ch:input"></a>

<p>
Consider a program for evaluating the formula \( x = A\sin(w t) \):

<p>
<!-- begin verbatim block  pypro-->
<pre><code>from math import sin
A = 0.1
w = 1
t = 0.6
x = A*sin(w*t)
print x
</code></pre>
<!-- end verbatim block -->
In this program,
<code>A</code>, <code>w</code>, and <code>t</code> are input data in the sense that these parameters
must be known before
the program can perform the calculation of <code>x</code>. The results
produced by the program, here <code>x</code>, constitute the output data.

<p>
Input data can be hardcoded in the program as we do above. That is, we
explicitly set variables to specific values: <code>A=0.1</code>, <code>w=1</code>, <code>t=0.6</code>.
This programming style may be suitable for small programs.  In
general, however, it is considered good practice to let a user of the
program provide input data when the program is running.  There is then
no need to modify the program itself when a new set of input data is
to be explored. This is an important feature, because
a golden rule of programming is that modification of
the source code always represents a danger of introducing new errors
by accident.

<p>
This document starts with describing three different ways of reading
data into a program:

<ol>
<li> let the user answer questions in a dialog
   in the terminal window (the section <a href="#sec:input:rawinput">Asking questions and reading answers</a>),</li>
<li> let the user provide input on the command line (the section <a href="#sec:input:sysargv">Reading from the command line</a>),</li>
<li> let the user provide input data in a file (the section <a href="#sec:files:reading">Reading data from file</a>),</li>
<li> let the user write input data
   in a graphical interface (the section <a href="#sec:input:GUI">A glimpse of graphical user interfaces</a>).</li>
</ol>

Even if your program works perfectly, wrong input data from the user
may cause the program to produce wrong answers or even crash.
Checking that the input data are correct is important, and the section <a href="#sec:input:except">Handling errors</a> tells you how to do this with so-called
exceptions.

<p>
The Python programming environment is organized as a big collection of
modules.  Organizing your own Python software in terms of modules is
therefore a natural and wise thing to do. The section <a href="#sec:input:modules">Making modules</a> tells you how easy it is to make your own
modules.

<p>
<!-- The topics you learn from this document will be key -->
<!-- ingredients in most of the programs you will write hereafter. -->

<p>
All the program examples from the present document are available in
files in the <a href="http://tinyurl.com/pwyasaa/input" target="_self"><tt>src/input</tt></a> folder.

<h1>Asking questions and reading answers <a name="sec:input:rawinput"></a></h1>

One of the simplest ways of getting data into a program is to
ask the user a question, let the user type in
an answer, and then read the text in that answer into a variable
in the program. These tasks are done by calling
a function with name <code>raw_input</code> in Python 2 - the name is just
<code>input</code> in Python 3.

<h2>Reading keyboard input <a name="sec:input:rawinput2"></a></h2>

A simple problem involving
the temperature conversion from Celsius to Fahrenheit constitutes our
main example: \( F=\frac{9}{5}C + 32 \). The associated program with
setting <code>C</code> explicitly in the program reads

<p>
<!-- begin verbatim block  pycod-->
<pre><code>C = 22
F = 9./5*C + 32
print F
</code></pre>
<!-- end verbatim block -->

<p>
We may ask the user a question <code>C=?</code> and wait for the user to
enter a number. The program can then read this number and store it in
a variable <code>C</code>. These actions are performed by the statement

<p>
<!-- begin verbatim block  pycod-->
<pre><code>C = raw_input('C=? ')
</code></pre>
<!-- end verbatim block -->
The <code>raw_input</code> function always returns the user input as
a string object. That is, the variable <code>C</code> above refers to a string object.
If we want to
compute with this <code>C</code>, we must convert the string to a floating-point
number: <code>C = float(C)</code>.
A complete program for reading <code>C</code> and computing the corresponding degrees
in Fahrenheit now becomes

<p>
<!-- begin verbatim block  pypro-->
<pre><code>C = raw_input('C=? ')
C = float(C)
F = (9./5)*C + 32
print F
</code></pre>
<!-- end verbatim block -->

<p>
In general, the <code>raw_input</code> function takes a string as argument,
displays this string in the terminal window, waits until the user
presses the Return key, and then returns a string object containing
the sequence of characters that the user typed in.

<p>
The program above is stored in a file called
<a href="http://tinyurl.com/pwyasaa/input/c2f_qa.py" target="_self"><tt>c2f_qa.py</tt></a> (the <code>qa</code>
part of the name reflects <em>question and answer</em>).  We can run this
program in several ways.  The convention in this document is to
indicate the execution by writing the program name only, but for a
real execution you need to do more: write <code>run</code> before the program
name in an interactive IPython session, or write <code>python</code> before the
program name in a terminal session.  Here is the execution of our
sample program and the resulting dialog with the user:

<p>
<!-- begin verbatim block  sys-->
<pre><code>c2f_qa.py
C=? 21
69.8
</code></pre>
<!-- end verbatim block -->
In this particular example, the <code>raw_input</code> function reads the
characters <code>21</code> from the keyboard and returns the string <code>'21'</code>, which
we refer to by the variable <code>C</code>. Then we create a new <code>float</code> object
by <code>float(C)</code> and let the name <code>C</code> refer to this <code>float</code> object, with
value 21.

<p>
You should now try out <a href="#sec:input:ex24">Exercise 1: Make an interactive program</a>,
<a href="#sec:input:ex25">Exercise 6: Read input from the keyboard</a>, and <a href="#sec:input:ex6">Exercise 9: Prompt the user for input to a formula</a> to make sure you
understand how <code>raw_input</code> behaves.

<h1>Reading from the command line <a name="sec:input:sysargv"></a></h1>

Programs running on Unix computers usually avoid asking the user questions.
Instead, input data are very often
fetched from the <em>command line</em>.
This section explains how we can access information on the command line
in Python programs.

<h2>Providing input on the command line <a name="sec:input:cml"></a></h2>

We look at the Celsius-Fahrenheit conversion program again.  The idea
now is to provide the Celsius input temperature as a <em>command-line
argument</em> right after the program name. This means that we write the
program name, here <a href="http://tinyurl.com/pwyasaa/c2f_cml.py" target="_self"><tt>c2f_cml.py</tt></a> (<code>cml</code>
for <em>command line</em>), followed the Celsius temperature:

<p>
<!-- begin verbatim block  sys-->
<pre><code>c2f_cml.py 21
69.8
</code></pre>
<!-- end verbatim block -->
Inside the program we can fetch the text <code>21</code> as <code>sys.argv[1]</code>. The
<code>sys</code> module has a list <code>argv</code> containing all the command-line
arguments to the program, i.e., all the &quot;words&quot; appearing after the
program name when we run the program.  In the present case there is
only one argument and it is stored in <code>sys.argv[1]</code>.  The first
element in the <code>sys.argv</code> list, <code>sys.argv[0]</code>, is always the name of
the program.

<p>
A command-line argument is treated as a text, so <code>sys.argv[1]</code> refers
to a string object, in this case <code>'21'</code>.  Since we interpret the
command-line argument as a number and want to compute with it, it is
necessary to explicitly convert the string to a <code>float</code> object. In the
program we therefore write

<p>
<!-- begin verbatim block  pypro-->
<pre><code>import sys
C = float(sys.argv[1])
F = 9.0*C/5 + 32
print F
</code></pre>
<!-- end verbatim block -->

<p>
As another example, consider the program

<p>
<!-- begin verbatim block  pypro-->
<pre><code>v0 = 5
g = 9.81
t = 0.6
y = v0*t - 0.5*g*t**2
print y
</code></pre>
<!-- end verbatim block -->
for computing the formula \( y(t)=v_0t - \frac{1}{2}gt^2 \).  Instead of
hardcoding the values of <code>v0</code> and <code>t</code> in the program we can read the
two values from the command line:

<p>
<!-- begin verbatim block  sys-->
<pre><code>ball2_cml.py 0.6 5
1.2342
</code></pre>
<!-- end verbatim block -->
The two command-line arguments are now available as <code>sys.argv[1]</code>
and <code>sys.argv[2]</code>.
The complete <a href="http://tinyurl.com/pwyasaa/input/ball2_cml.py" target="_self"><tt>ball2_cml.py</tt></a>
program thus takes the form

<p>
<!-- begin verbatim block  pypro-->
<pre><code>import sys
t  = float(sys.argv[1])
v0 = float(sys.argv[2])
g = 9.81
y = v0*t - 0.5*g*t**2
print y
</code></pre>
<!-- end verbatim block -->

<h2>A variable number of command-line arguments  <a name="___sec4"></a></h2>

Let us make a program <code>addall.py</code> that adds all its command-line arguments.
That is, we may run something like

<p>
<!-- begin verbatim block  sys-->
<pre><code>addall.py 1 3 5 -9.9
The sum of 1 3 5 -9.9 is -0.9
</code></pre>
<!-- end verbatim block -->
The command-line arguments are stored in the sublist <code>sys.argv[1:]</code>.
Each element is a string so we must perform a conversion to <code>float</code>
before performing the addition. There are many ways to write
this program. Let us start with version 1, <code>addall_v1.py</code>:

<p>
<!-- begin verbatim block  pypro-->
<pre><code>import sys
s = 0
for arg in sys.argv[1:]:
    number = float(arg)
    s += number
print 'The sum of ',
for arg in sys.argv[1:]:
    print arg,
print 'is ', s
</code></pre>
<!-- end verbatim block -->
The output is on one line, but built of several <code>print</code> statements
with a comma at the end to prevent the usual
newline character that <code>print</code> otherwise adds to the text.
The command-line arguments must be converted to numbers in the first
<code>for</code> loop because we need to compute with them, but in the second
loop we only need to print them and then the string representation
is appropriate.

<p>
The program above can be written more compactly if desired:
<a name="sec:input:join"></a>

<p>
<!-- begin verbatim block  pypro-->
<pre><code>import sys
s = sum([float(x) for x in sys.argv[1:]])
print 'The sum of %s is %s' % (' '.join(sys.argv[1:]), s)
</code></pre>
<!-- end verbatim block -->
Here, we convert the list <code>sys.argv[1:]</code> to a list of
<code>float</code> objects and then pass this list to Python's
<code>sum</code> function for adding the numbers.
The construction <code>S.join(L)</code> places all the elements in the list
<code>L</code> after each other with the string <code>S</code> in between. The
result here is a string with all the elements in <code>sys.argv[1:]</code>
and a space in between, which is the text that originally appeared on
the command line.

<h2>More on command-line arguments  <a name="___sec5"></a></h2>

Unix commands make heavy use of command-line arguments.  For example,
when you write <code>ls -s -t</code> to list the files in the current folder, you
run the program <code>ls</code> with two command-line arguments: <code>-s</code> and
<code>-t</code>. The former specifies that <code>ls</code> is to print the file name
together with the size of the file, and the latter sorts the list of
files according to their dates of last modification.  Similarly, <code>cp
-r my new</code> for copying a folder tree <code>my</code> to a new folder tree <code>new</code>
invokes the <code>cp</code> program with three command line arguments: <code>-r</code> (for
recursive copying of files), <code>my</code>, and <code>new</code>. Most programming
languages have support for extracting the command-line arguments given
to a program.

<p>
An important rule is that
<em>command-line arguments are separated by blanks</em>. What if we want to
provide a text containing blanks as command-line argument?
The text containing blanks must then appear inside single or double
quotes. Let us demonstrate this with a program that simply prints
the command-line arguments:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import sys, pprint
pprint.pprint(sys.argv[1:])
</code></pre>
<!-- end verbatim block -->
Say this program is named <code>print_cml.py</code>. The execution

<p>
<!-- begin verbatim block  sys-->
<pre><code>print_cml.py 21 a string with blanks 31.3
['21', 'a', 'string', 'with', 'blanks', '31.3']
</code></pre>
<!-- end verbatim block -->
demonstrates that each word on the command line becomes an element
in <code>sys.argv</code>. Enclosing strings in quotes, as in

<p>
<!-- begin verbatim block  sys-->
<pre><code>print_cml.py 21 &quot;a string with blanks&quot; 31.3
['21', 'a string with blanks', '31.3']
</code></pre>
<!-- end verbatim block -->
shows that the text inside the quotes becomes a single command line
argument.

<h1>Turning user text into live objects  <a name="___sec6"></a></h1>

It is possible to provide text with valid Python code as input to
a program and then turn the text into live objects as if the
text were written directly into the program beforehand.
This is a very powerful tool for letting users specify function formulas,
for instance, as input to a program. The program code itself has no
knowledge about the kind of function the user wants to work with, yet
at run time the user's desired formula enters the computations.

<h2>The magic eval function <a name="sec:input:eval"></a></h2>

The <code>eval</code> functions takes a string as argument and
evaluates this string as a Python <em>expression</em>. The result of an
expression is an object. Consider

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; r = eval('1+2')
&gt;&gt;&gt; r
3
&gt;&gt;&gt; type(r)
&lt;type 'int'&gt;
</code></pre>
<!-- end verbatim block -->
The result of <code>r = eval('1+2')</code> is the same as if we had written
<code>r = 1+2</code> directly:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; r = 1+2
&gt;&gt;&gt; r
3
&gt;&gt;&gt; type(r)
&lt;type 'int'&gt;
</code></pre>
<!-- end verbatim block -->
In general, any valid Python expression stored as text in a string <code>s</code>
can be turned into live Python code by <code>eval(s)</code>.

<p>
Here is an example where the string to be evaluated is <code>'2.5'</code>, which
causes Python to see <code>r = 2.5</code> and make a <code>float</code> object:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; r = eval('2.5')
&gt;&gt;&gt; r
2.5
&gt;&gt;&gt; type(r)
&lt;type 'float'&gt;
</code></pre>
<!-- end verbatim block -->

<p>
Let us proceed with some more examples. We can put the initialization of
a list inside quotes and use <code>eval</code> to make a <code>list</code> object:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; r = eval('[1, 6, 7.5]')
&gt;&gt;&gt; r
[1, 6, 7.5]
&gt;&gt;&gt; type(r)
&lt;type 'list'&gt;
</code></pre>
<!-- end verbatim block -->
Again, the assignment to <code>r</code> is equivalent to writing

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; r = [1, 6, 7.5]
</code></pre>
<!-- end verbatim block -->
We can also make a <code>tuple</code> object by using tuple syntax (standard
parentheses instead of brackets):

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; r = eval('(-1, 1)')
&gt;&gt;&gt; r
(-1, 1)
&gt;&gt;&gt; type(r)
&lt;type 'tuple'&gt;
</code></pre>
<!-- end verbatim block -->
Another example reads

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; from math import sqrt
&gt;&gt;&gt; r = eval('sqrt(2)')
&gt;&gt;&gt; r
1.4142135623730951
&gt;&gt;&gt; type(r)
&lt;type 'float'&gt;
</code></pre>
<!-- end verbatim block -->
At the time we run <code>eval('sqrt(2)')</code>, this is the same as if we had
written

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; r = sqrt(2)
</code></pre>
<!-- end verbatim block -->
directly, and this is valid syntax only  if the <code>sqrt</code> function is defined.
Therefore, the import of <code>sqrt</code> prior to running <code>eval</code> is
important in this example.

<h3>Applying eval to strings  <a name="___sec8"></a></h3>

If we put a string, enclosed in quotes, inside the expression string,
the result is a string object:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt;
&gt;&gt;&gt; r = eval('&quot;math programming&quot;')
&gt;&gt;&gt; r
'math programming'
&gt;&gt;&gt; type(r)
&lt;type 'str'&gt;
</code></pre>
<!-- end verbatim block -->
Note that we must use two types of quotes: first double quotes to mark
<code>math programming</code> as a string object and then another set of quotes,
here single quotes (but we could also have used triple single quotes),
to embed the text <code>"math programming"</code> inside a string.  It does not
matter if we have single or double quotes as inner or outer quotes,
i.e., <code>'"..."'</code> is the same as <code>"'...'"</code>, because <code>'</code> and <code>"</code> are
interchangeable as long as a pair of either type is used consistently.

<p>
Writing just

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; r = eval('math programming')
</code></pre>
<!-- end verbatim block -->
is the same as writing

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; r = math programming
</code></pre>
<!-- end verbatim block -->
which is an invalid expression. Python will in this case think that
<code>math</code> and <code>programming</code> are two (undefined) variables, and setting two
variables next to each other with a space in between is invalid Python
syntax. However,

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; r = 'math programming'
</code></pre>
<!-- end verbatim block -->
is valid syntax, as this is how we initialize a string <code>r</code> in Python.
To repeat,
if we put the valid syntax <code>'math programming'</code> inside a string,

<p>
<!-- begin verbatim block  pycod-->
<pre><code>s = &quot;'math programming'&quot;
</code></pre>
<!-- end verbatim block -->
<code>eval(s)</code> will evaluate the text inside the double quotes as
<code>'math programming'</code>, which yields a string.

<h3>Applying eval to user input  <a name="___sec9"></a></h3>

So, why is the <code>eval</code> function so useful?  When we get input via
<code>raw_input</code> or <code>sys.argv</code>, it is always in the form of a string
object, which often must be converted to another type of object,
usually an <code>int</code> or <code>float</code>.  Sometimes we want to avoid specifying
one particular type. The <code>eval</code> function can then be of help: we feed
the string object from the input to the <code>eval</code> function and let the it
interpret the string and convert it to the right object.

<p>
An example may clarify the point.  Consider a small program where we
read in two values and add them.  The values could be strings, floats,
integers, lists, and so forth, as long as we can apply a <code>+</code> operator
to the values.  Since we do not know if the user supplies a string,
float, integer, or something else, we just convert the input by
<code>eval</code>, which means that the user's syntax will determine the type.
The program goes as follows
(<a href="http://tinyurl.com/pwyasaa/input/add_input.py" target="_self"><tt>add_input.py</tt></a>):

<p>
<!-- begin verbatim block  pypro-->
<pre><code>i1 = eval(raw_input('Give input: '))
i2 = eval(raw_input('Give input: '))
r = i1 + i2
print '%s + %s becomes %s\nwith value %s' % \
      (type(i1), type(i2), type(r), r)
</code></pre>
<!-- end verbatim block -->
Observe that we write out the two supplied values,
together with the types of the values (obtained by <code>eval</code>), and the sum.
Let us run the program with
an integer and a real number as input:

<p>
<!-- begin verbatim block  sys-->
<pre><code>add_input.py
Give input: 4
Give input: 3.1
&lt;type 'int'&gt; + &lt;type 'float'&gt; becomes &lt;type 'float'&gt;
with value 7.1
</code></pre>
<!-- end verbatim block -->
The string <code>'4'</code>, returned by the first call to <code>raw_input</code>,
is interpreted as an <code>int</code> by <code>eval</code>, while <code>'3.1'</code> gives
rise to a <code>float</code> object.

<p>
Supplying two lists also works fine:

<p>
<!-- begin verbatim block  sys-->
<pre><code>add_input.py
Give input: [-1, 3.2]
Give input: [9,-2,0,0]
&lt;type 'list'&gt; + &lt;type 'list'&gt; becomes &lt;type 'list'&gt;
with value [-1, 3.2000000000000002, 9, -2, 0, 0]
</code></pre>
<!-- end verbatim block -->
If we want to use the program to add two strings, the strings must be
enclosed in quotes for <code>eval</code> to recognize the texts as string
objects (without the quotes, <code>eval</code> aborts with an error):

<p>
<!-- begin verbatim block  sys-->
<pre><code>add_input.py
Give input: 'one string'
Give input: &quot; and another string&quot;
&lt;type 'str'&gt; + &lt;type 'str'&gt; becomes &lt;type 'str'&gt;
with value one string and another string
</code></pre>
<!-- end verbatim block -->

<p>
Not all objects are meaningful to add:

<p>
<!-- begin verbatim block  sys-->
<pre><code>add_input.py
Give input: 3.2
Give input: [-1,10]
Traceback (most recent call last):
  File &quot;add_input.py&quot;, line 3, in &lt;module&gt;
    r = i1 + i2
TypeError: unsupported operand type(s) for +: 'float' and 'list'
</code></pre>
<!-- end verbatim block -->

<p>
A similar program adding two arbitrary command-line arguments
reads ((<a href="http://tinyurl.com/pwyasaa/input/add_input.py" target="_self"><tt>add_input.py</tt></a>):

<p>
<!-- begin verbatim block  pypro-->
<pre><code>import sys
i1 = eval(sys.argv[1])
i2 = eval(sys.argv[2])
r = i1 + i2
print '%s + %s becomes %s\nwith value %s' % \
      (type(i1), type(i2), type(r), r)
</code></pre>
<!-- end verbatim block -->

<p>
Another important example on the usefulness of <code>eval</code> is to turn
formulas, given as input, into mathematics in the program.  Consider
the program

<p>
<!-- begin verbatim block  pypro-->
<pre><code>from math import *   # make all math functions available
import sys
formula = sys.argv[1]
x = eval(sys.argv[2])
result = eval(formula)
print '%s for x=%g yields %g' % (formula, x, result)
</code></pre>
<!-- end verbatim block -->
Two command-line arguments are expected: a formula and a number.  Say
the formula given is <code>2*sin(x)+1</code> and the number is 3.14.  This
information is read from the command line as strings.  Doing <code>x =
eval(sys.argv[2])</code> means <code>x = eval('3.14')</code>, which is equivalent to <code>x
= 3.14</code>, and <code>x</code> refers to a <code>float</code> object.  The <code>eval(formula)</code>
expression means <code>eval('2*sin(x)+1')</code>, and the corresponding statement
<code>result = eval(formula</code> is therefore effectively <code>result =
2*sin(x)+1</code>, which requires <code>sin</code> and <code>x</code> to be defined objects. The
result is a <code>float</code> (approximately 1.003).  Providing <code>cos(x)</code> as the
first command-line argument creates a need to have <code>cos</code> defined, so
that is why we import all functions from the <code>math</code> module.
Let us try to run the program:

<p>
<!-- begin verbatim block  sys-->
<pre><code>eval_formula.py &quot;2*sin(x)+1&quot; 3.14
2*sin(x)+1 for x=3.14 yields 1.00319
</code></pre>
<!-- end verbatim block -->

<p>
The very nice thing with using <code>eval</code> in <code>x = eval(sys.argv[2])</code> is that
we can provide mathematical expressions like <code>pi/2</code> or even
<code>tanh(2*pi)</code>, as the latter just effectively results in the
statement <code>x = tanh(2*pi)</code>, and this works fine as long has we have
imported <code>tanh</code> and <code>pi</code>.

<h2>The magic exec function <a name="sec:input:exec"></a></h2>

Having presented <code>eval</code> for turning strings into Python code, we take
the opportunity to also describe the related <code>exec</code> function to
execute a string containing arbitrary Python code, not only an
expression.

<p>
Suppose the user can write a formula as input to the
program, available to us in the form of a string object.
We would then like to turn this formula into a callable Python
function.  For example, writing <code>sin(x)*cos(3*x) + x**2</code> as the formula,
we would make the function

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def f(x):
    return sin(x)*cos(3*x) + x**2
</code></pre>
<!-- end verbatim block -->
This is easy with <code>exec</code>: just construct the right Python syntax
for defining <code>f(x)</code> in a string and apply <code>exec</code> to the string,

<p>
<!-- begin verbatim block  pycod-->
<pre><code>formula = sys.argv[1]
code = &quot;&quot;&quot;
def f(x):
    return %s
&quot;&quot;&quot; % formula
exec(code)
</code></pre>
<!-- end verbatim block -->
As an example,
think of <code>"sin(x)*cos(3*x) + x**2"</code> as the first command-line
argument. Then <code>formula</code> will hold this text, which is inserted into
the <code>code</code> string such that it becomes

<p>
<!-- begin verbatim block  pycod-->
<pre><code>&quot;&quot;&quot;
def f(x):
    return sin(x)*cos(3*x) + x**2
&quot;&quot;&quot;
</code></pre>
<!-- end verbatim block -->
Thereafter, <code>exec(code)</code> executes the code as if we had written
the contents of the <code>code</code> string directly into the program by hand.
With this technique, we can turn any user-given formula into a
Python function!

<p>
Let us now use this technique in a useful application.
Suppose we have made a function for computing
the integral \( \int_a^b f(x)dx \) by the Midpoint rule
with \( n \) intervals:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def midpoint_integration(f, a, b, n=100):
    h = (b - a)/float(n)
    I = 0
    for i in range(n):
        I += f(a + i*h + 0.5*h)
    return h*I
</code></pre>
<!-- end verbatim block -->
We now want to read \( a \), \( b \), and \( n \) from the command line as well
as the formula that makes up the \( f(x) \) function:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>from math import *
import sys
f_formula = sys.argv[1]
a = eval(sys.argv[2])
b = eval(sys.argv[3])
if len(sys.argv) &gt;= 5:
    n = int(sys.argv[4])
else:
    n = 200
</code></pre>
<!-- end verbatim block -->
Note that we import everything from <code>math</code> and use <code>eval</code> when
reading the input for <code>a</code> and <code>b</code> as this will allow the user to
provide values like <code>2*cos(pi/3)</code>.

<p>
The next step is to convert the <code>f_formula</code> for \( f(x) \) into a
Python function <code>g(x)</code>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>code = &quot;&quot;&quot;
def g(x):
    return %s
&quot;&quot;&quot; % f_formula
exec(code)
</code></pre>
<!-- end verbatim block -->
Now we have an ordinary Python function <code>g(x)</code> that we can ask
the integration function to integrate:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>I = midpoint_integration(g, a, b, n)
print 'Integral of %s on [%g, %g] with n=%d: %g' % \ 
      (f_formula, a, b, n, I)
</code></pre>
<!-- end verbatim block -->
The complete code is found in <a href="http://tinyurl.com/pwyasaa/input/integrate.py" target="_self"><tt>integrate.py</tt></a>. A sample run for \( \int_0^{\pi/2} \sin(x)dx \) goes like

<p>
<!-- begin verbatim block  sys-->
<pre><code>integrate.py &quot;sin(x)&quot; 0 pi/2
integral of sin(x) on [0, 1.5708] with n=200: 0.583009
</code></pre>
<!-- end verbatim block -->
(The quotes in <code>"sin(x)"</code> are needed because of the parenthesis will
otherwise be interpreted by the shell.)

<h2>Turning string expressions into functions <a name="sec:input:StringFunction"></a></h2>

The examples in the previous section indicate that it can be handy
to ask the user for a formula and turn that formula into a Python
function.
Since this operation is so useful, we have made a special tool that
hides the technicalities. The tool is named
<code>StringFunction</code> and works as follows:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; from scitools.StringFunction import StringFunction
&gt;&gt;&gt; formula = 'exp(x)*sin(x)'
&gt;&gt;&gt; f = StringFunction(formula)   # turn formula into function f(x)
</code></pre>
<!-- end verbatim block -->
The <code>f</code> object now behaves as an ordinary Python function of <code>x</code>:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; f(0)
0.0
&gt;&gt;&gt; f(pi)
2.8338239229952166e-15
&gt;&gt;&gt; f(log(1))
0.0
</code></pre>
<!-- end verbatim block -->
Expressions involving other independent variables than <code>x</code> are also
possible.
Here is an example with the function
\( g(t) = Ae^{-at}\sin (\omega x) \):

<p>
<!-- begin verbatim block  pycod-->
<pre><code>g = StringFunction('A*exp(-a*t)*sin(omega*x)',
                   independent_variable='t',
                   A=1, a=0.1, omega=pi, x=0.5)
</code></pre>
<!-- end verbatim block -->
The first argument is the function formula, as before, but now we need
to specify the name of the independent variable (<code>'x'</code> is default).
The other parameters in the function (\( A \), \( a \), \( \omega \), and \( x \)) must be
specified with values, and we use keyword arguments, consistent with
the names in the function formula, for this purpose. Any of the parameters
<code>A</code>, <code>a</code>, <code>omega</code>, and <code>x</code>
can be changed later by calls like

<p>
<!-- begin verbatim block  pycod-->
<pre><code>g.set_parameters(omega=0.1)
g.set_parameters(omega=0.1, A=5, x=0)
</code></pre>
<!-- end verbatim block -->
Calling <code>g(t)</code> works as if <code>g</code> were a plain Python
function of <code>t</code>, which
also stores all the parameters <code>A</code>, <code>a</code>, <code>omega</code>, and
<code>x</code>, and their values. You can use <code>pydoc</code>
to bring
up more documentation on the possibilities with <code>StringFunction</code>.
Just run

<p>
<!-- begin verbatim block  ccq-->
<pre><code>pydoc scitools.StringFunction.StringFunction
</code></pre>
<!-- end verbatim block -->
A final important point is that <code>StringFunction</code> objects are as
computationally efficient as hand-written Python functions.
(This property is quite remarkable, as a string formula will in most
other programming languages be much slower to evaluate than if the
formula were hardcoded inside a plain function.)

<h1>Option-value pairs on the command line <a name="sec:input:argparse"></a></h1>

The examples on using command-line arguments so far require the user
of the program to type all arguments in their right sequence, just as
when calling a function with positional arguments in the right
order. It would be very convenient to assign command-line arguments in
the same way as we use keyword arguments. That is, arguments are
associated with a name, their sequence can be arbitrary, and only the
arguments where the default value is not appropriate need to be given.
Such type of command-line arguments may have <code>--option value</code> pairs,
where <code>option</code> is some name of the argument.

<p>
As usual, we shall use an example to illustrate how to work with
<code>--option value</code> pairs. Consider the physics formula for the location
\( s(t) \) of an object at time \( t \), given that the object started at \( s=s_0 \) at
\( t=0 \) with a velocity \( v_0 \), and thereafter was subject to a constant
acceleration \( a \):

$$
\begin{equation}
s(t) = s_0 + v_0t + \frac{1}{2}at^2\tp
\tag{1}
\end{equation}
$$

This formula
requires four input variables: \( s_0 \), \( v_0 \), \( a \), and \( t \).
We can make a program <code>location.py</code> that takes four options,
<code>--s0</code>,
<code>--v0</code>,
<code>--a</code>, and
<code>--t</code>, on the command line.
The program is typically run like this:

<p>
<!-- begin verbatim block  sys-->
<pre><code>location.py --t 3 --s0 1 --v0 1 --a 0.5
</code></pre>
<!-- end verbatim block -->
The sequence of <code>--option value</code> pairs is arbitrary. All options have
a default value such that one does not have to specify all options
on the command line.

<p>
All input variables should have sensible default values such that we
can leave out the options for which the default value is suitable.
For example, if \( s_0=0 \), \( v_0=0 \), \( a=1 \), and \( t=1 \) by default, and we
only want to change \( t \), we can run

<p>
<!-- begin verbatim block  sys-->
<pre><code>location.py --t 3
</code></pre>
<!-- end verbatim block -->

<h2>Basic usage of the argparse module  <a name="___sec13"></a></h2>

Python has a flexible and powerful module <code>argparse</code> for reading
(parsing) <code>--option value</code> pairs on the command line.  Using
<code>argparse</code> consists of three steps. First, a parser object must be
created:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import argparse
parser = argparse.ArgumentParser()
</code></pre>
<!-- end verbatim block -->
Second, we need to define the various command-line options,

<p>
<!-- begin verbatim block  pycod-->
<pre><code>parser.add_argument('--v0', '--initial_velocity', type=float,
                    default=0.0, help='initial velocity',
                    metavar='v')
parser.add_argument('--s0', '--initial_position', type=float,
                    default=0.0, help='initial position',
                    metavar='s')
parser.add_argument('--a', '--acceleration', type=float,
                    default=1.0, help='acceleration', metavar='a')
parser.add_argument('--t', '--time', type=float,
                    default=1.0, help='time', metavar='t')
</code></pre>
<!-- end verbatim block -->
The first arguments to <code>parser.add_argument</code> is the set of options
that we want to associate with an input parameter.  Optional arguments
are the type, a default value, a help string, and a name for the value
of the argument (<code>metavar</code>) in a usage string.  The <code>argparse</code> module
will automatically allow an option <code>-h</code> or <code>--help</code> that prints a
usage string for all the registered options.  By default, the type is
<code>str</code>, the default value is <code>None</code>, the help string is empty, and
<code>metavar</code> is the option in upper case without initial dashes.

<p>
Third, we must read the command line arguments and interpret them:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>args = parser.parse_args()
</code></pre>
<!-- end verbatim block -->
Through the <code>args</code> object we can extract the values of the
various registered parameters: <code>args.v0</code>, <code>args.s0</code>, <code>args.a</code>,
and <code>args.t</code>. The name of the parameter is determined by
the first option to <code>parser.add_argument</code>, so writing

<p>
<!-- begin verbatim block  pycod-->
<pre><code>parser.add_argument('--initial_velocity', '--v0', type=float,
                    default=0.0, help='initial velocity')
</code></pre>
<!-- end verbatim block -->
will make the initial velocity value appear as <code>args.initial_velocity</code>.
We can add the <code>dest</code> keyword to explicitly specify the name where
the value is stored:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>parser.add_argument('--initial_velocity', '--v0', dest='V0',
                    type=float, default=0, help='initial velocity')
</code></pre>
<!-- end verbatim block -->
Now, <code>args.V0</code> will retrieve the value of the initial velocity.
In case we do not provide any default value, the value will be <code>None</code>.

<p>
Our example is completed either by evaluating <code>s</code> as

<p>
<!-- begin verbatim block  pycod-->
<pre><code>s = args.s0 + args.v0*t + 0.5*args.a*args.t**2
</code></pre>
<!-- end verbatim block -->
or by introducing new variables so that the formula aligns better
with the mathematical notation:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>s0 = args.s0; v0 = args.v0; a = args.a; t = args.t
s = s0 + v0*t + 0.5*a*t**2
</code></pre>
<!-- end verbatim block -->

<p>
A complete program for the example above is
found in the file <a href="http://tinyurl.com/pwyasaa/input/location.py" target="_self"><tt>location.py</tt></a>.
Try to run it with the <code>-h</code> option to see
an automatically generated explanation of legal command-line options.

<h2>Mathematical expressions as values  <a name="___sec14"></a></h2>

Values on the command line involving mathematical symbols and
functions, say <code>--v0 'pi/2'</code>, pose a problem with the code example
above.  The <code>argparse</code> module will in that case try to do
<code>float('pi/2')</code> which does not work well since <code>pi</code> is an undefined
name. Changing <code>type=float</code> to <code>type=eval</code> is required to interpret
the expression <code>pi/2</code>, but even <code>eval('pi/2')</code> fails since <code>pi</code> is not
defined inside the <code>argparse</code> module. There are various remedies for
this problem.

<p>
One can write a tailored function for converting a string value given
on the command line to the desired object. For example,

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def evalcmlarg(text):
    return eval(text)

parser.add_argument('--s0', '--initial_position', type=evalcmlarg,
                    default=0.0, help='initial position')
</code></pre>
<!-- end verbatim block -->
The file <a href="http://tinyurl.com/pwyasaa/input/location_v2.py" target="_self"><tt>location_v2.py</tt></a>
demonstrates such explicit type conversion through a user-provided
conversion function.
Note that <code>eval</code> is now taken in the programmer's namespace where
(hopefully) <code>pi</code> or other symbols are imported.

<p>
More sophisticated conversions are possible. Say \( s_0 \) is specified in
terms of a function of some parameter \( p \), like \( s_0=(1-p^2) \).  We
could then use a string for <code>--s0</code> and the <code>StringFunction</code> tool from
the section <a href="#sec:input:StringFunction">Turning string expressions into functions</a> to turn the string into a
function:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def toStringFunction4s0(text):
    from scitools.std import StringFunction
    return StringFunction(text, independent_variable='p')

parser.add_argument('--s0', '--initial_position',
                    type=toStringFunction4s0,
                    default='0.0', help='initial position')
</code></pre>
<!-- end verbatim block -->
Giving a command-line argument <code>--s0 'exp(-1.5) + 10(1-p**2)</code>
results in <code>args.s0</code> being a <code>StringFunction</code> object, which we
must evaluate for a <code>p</code> value:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>s0 = args.s0
p = 0.05
...
s = s0(p) + v0*t + 0.5*a*t**2
</code></pre>
<!-- end verbatim block -->
The file <a href="http://tinyurl.com/pwyasaa/input/location_v3.py" target="_self"><tt>location_v3.py</tt></a>
contains the complete code for this example.

<p>
Another alternative is to perform the correct conversion of values in
our own code <em>after</em> the <code>parser</code> object has read the values.  To this
end, we treat argument types as strings in the <code>parser.add_argument</code>
calls, meaning that we replace <code>type=float</code> by set <code>type=str</code> (which
is also the default choice of <code>type</code>). Recall that this approach requires
specification of default values as strings too, say <code>'0'</code>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>parser.add_argument('--s0', '--initial_position', type=str,
                    default='0', help='initial position')
...
from math import *
args.v0 = eval(args.v0)
# or
v0 = eval(args.v0)

s0 = StringFunction(args.s0, independent_variable='p')
p = 0.5
...
s = s0(p) + v0*t + 0.5*a*t**2
</code></pre>
<!-- end verbatim block -->
Such code is found in the file <a href="http://tinyurl.com/pwyasaa/input/location_v4.py" target="_self"><tt>location_v4.py</tt></a>.  You can try out that program with
the command-line arguments <code>--s0 'pi/2 + sqrt(p)' --v0 pi/4'</code>.

<p>
The final alternative is to write an <code>Action</code> class to handle the
conversion from string to the right type. This is the preferred way to
perform conversions and well described in the <code>argparse</code>
documentation.  We shall exemplify it here, but the technicalities
involved require understanding of classes (see the document
<a href="http://tcse6.on.net/class" target="_self">Introduction to classes in Python</a>
<a href="#Langtangen_TCSE6_class">[1]</a>) and inheritance (see the document
<a href="http://tcse6.on.net/oo" target="_self">Object-oriented programming</a>
<a href="#Langtangen_TCSE6_oo">[2]</a>).  For the conversion from string to any
object via <code>eval</code> we write

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import argparse
from math import *

class ActionEval(argparse.Action):
    def __call__(self, parser, namespace, values,
                 option_string=None):
        setattr(namespace, self.dest, eval(values))
</code></pre>
<!-- end verbatim block -->
The command-line arguments supposed to be run through <code>eval</code> must
then have an <code>action</code> parameter:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>parser.add_argument('--v0', '--initial_velocity',
                    default=0.0, help='initial velocity',
                    action=ActionEval)
</code></pre>
<!-- end verbatim block -->
From string to function via <code>StringFunction</code> for the
<code>--s0</code> argument we write

<p>
<!-- begin verbatim block  pycod-->
<pre><code>from scitools.std import StringFunction

class ActionStringFunction4s0(argparse.Action):
    def __call__(self, parser, namespace, values,
                 option_string=None):
        setattr(namespace, self.dest,
                StringFunction(values, independent_variable='p'))
</code></pre>
<!-- end verbatim block -->
A complete code appears in the file
<a href="http://tinyurl.com/pwyasaa/input/location_v5.py" target="_self"><tt>location_v5.py</tt></a>.

<h1>Reading data from file <a name="sec:files:reading"></a></h1>

Getting input data into a program from the command line, or from questions
and answers in the terminal window, works for small amounts of data.
Otherwise, input data must be available in files. Anyone with some
computer experience is used to save and load data files in programs.
The task now is to understand how Python programs can read and write files.
The basic recipes are quite simple and illustrated through examples.

<p>
Suppose we have
recorded some measurement data in the file
<a href="http://tinyurl.com/pwyasaa/input/data.txt" target="_self"><tt>src/input/data.txt</tt></a>.
The goal of our first example of reading files
is to read the measurement values in <code>data.txt</code>,
find the average value, and print it out in the terminal window.

<p>
Before trying to let a program read a file, we must know the <em>file
format</em>, i.e., what the contents of the file looks like, because the
structure of the text in the file greatly influences the set of
statements needed to read the file.  We therefore start with viewing
the contents of the file <code>data.txt</code>. To this end, load the file into a
text editor or viewer (one can use <code>emacs</code>, <code>vim</code>, <code>more</code>, or <code>less</code>
on Unix and Mac, while on Windows, <code>WordPad</code> is appropriate, or the
<code>type</code> command in a DOS or PowerShell window, and even Word processors
such as LibreOffice or Microsoft Word can also be used on
Windows). What we see is a column with numbers:

<p>
<!-- begin verbatim block  txt-->
<pre><code>21.8
18.1
19
23
26
17.8
</code></pre>
<!-- end verbatim block -->

<p>
Our task is to read this column of numbers into a list in the program
and compute the average of the list items.

<h2>Reading a file line by line  <a name="___sec16"></a></h2>

To read a file, we first
need to <em>open</em> the file. This action creates
a file object, here stored in the variable <code>infile</code>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>infile = open('data.txt', 'r')
</code></pre>
<!-- end verbatim block -->
The second argument to the <code>open</code> function, the string <code>'r'</code>,
tells that we want to open the file for reading. We shall later see
that a file can be opened for writing instead, by providing <code>'w'</code> as the
second argument. After the file is
read, one should close the file object with <code>infile.close()</code>.

<p>
The basic technique for reading the file line by line applies a <code>for</code> loop
like this:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>for line in infile:
    # do something with line
</code></pre>
<!-- end verbatim block -->
The <code>line</code> variable is a string holding the current line in the file.
The <code>for</code> loop over lines in a file has the same syntax as when we go through
a list. Just think of the file object <code>infile</code> as a collection of
elements, here lines in a file, and the <code>for</code> loop visits these
elements in sequence such that the <code>line</code> variable
refers to one line at a time.
If something seemingly goes wrong in such a loop
over lines in a file, it is useful to do a <code>print line</code> inside the loop.

<p>
Instead of reading one line at a time, we can load all lines into
a list of strings (lines) by

<p>
<!-- begin verbatim block  pycod-->
<pre><code>lines = infile.readlines()
</code></pre>
<!-- end verbatim block -->
This statement is equivalent to

<p>
<!-- begin verbatim block  pycod-->
<pre><code>lines = []
for line in infile:
    lines.append(line)
</code></pre>
<!-- end verbatim block -->
or the list comprehension:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>lines = [line for line in infile]
</code></pre>
<!-- end verbatim block -->

<p>
In the present example, we load the file into the list <code>lines</code>.
The next task is to compute the average of the numbers in the file. Trying
a straightforward sum of all numbers on all lines,

<p>
<!-- begin verbatim block  pycod-->
<pre><code>mean = 0
for number in lines:
    mean = mean + number
mean = mean/len(lines)
</code></pre>
<!-- end verbatim block -->
gives an error message:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>TypeError: unsupported operand type(s) for +: 'int' and 'str'
</code></pre>
<!-- end verbatim block -->
The reason is that <code>lines</code> holds each line (<code>number</code>) as a string, not
a <code>float</code> or <code>int</code> that we can add to other numbers.
A fix is to convert each line to a <code>float</code>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>mean = 0
for line in lines:
    number = float(line)
    mean = mean + number
mean = mean/len(lines)
</code></pre>
<!-- end verbatim block -->
This code snippet works fine. The complete code can be found in the
file <a href="http://tinyurl.com/pwyasaa/input/mean1.py" target="_self"><tt>mean1.py</tt></a>.

<p>
Summing up a list of numbers is often done in numerical programs, so
Python has a special function <code>sum</code> for performing this task. However,
<code>sum</code> must in the present case operate on a list of floats, not
strings. We can use a list comprehension to turn all elements in
<code>lines</code> into corresponding <code>float</code> objects:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>mean = sum([float(line) for line in lines])/len(lines)
</code></pre>
<!-- end verbatim block -->
An alternative implementation is to load the lines into a list of
<code>float</code> objects directly. Using this strategy, the complete program
(found in file <a href="http://tinyurl.com/pwyasaa/input/mean2.py" target="_self"><tt>mean2.py</tt></a>) takes the form

<p>
<!-- begin verbatim block  pypro-->
<pre><code>infile = open('data.txt', 'r')
numbers = [float(line) for line in infile.readlines()]
infile.close()
mean = sum(numbers)/len(numbers)
print mean
</code></pre>
<!-- end verbatim block -->

<h2>Alternative ways of reading a file <a name="sec:files:reading:other"></a></h2>

A newcomer to programming might find it confusing to see that one
problem is solved by many alternative sets of statements, but this is
the very nature of programming. A clever programmer will judge several
alternative solutions to a programming task and choose one that is
either particularly compact, easy to understand, and/or easy to extend
later.  We therefore present more examples on how to read the
<code>data.txt</code> file and compute with the data.

<h3>The modern with statement  <a name="___sec18"></a></h3>

Modern Python code applies the <code>with</code> statement to deal with files:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>with open('data.txt', 'r') as infile:
    for line in infile:
        # process line
</code></pre>
<!-- end verbatim block -->
This snippet is equivalent to

<p>
<!-- begin verbatim block  pycod-->
<pre><code>infile = open('data.txt', 'r')
for line in infile:
    # process line
infile.close()
</code></pre>
<!-- end verbatim block -->
Note that there is no need to close the file when using the <code>with</code>
statement. The advantage of the <code>with</code> construction is shorter code
and better handling of errors if something goes wrong with opening or
working with the file. A downside is that the syntax differs from the
very classical open-close pattern that one finds in most other
programming languages. Remembering to close a file is key in
programming, and to train that task, we mostly apply the open-close
construction in this document.

<h3>The old while construction  <a name="___sec19"></a></h3>

The call <code>infile.readline()</code> returns a string containing the text at
the current line.  A new <code>infile.readline()</code> will read the next line.
When <code>infile.readline()</code> returns an empty string, the end of the file
is reached and we must stop further reading.  The following <code>while</code>
loop reads the file line by line using <code>infile.readline()</code>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>while True:
    line = infile.readline()
    if not line:
        break
    # process line
</code></pre>
<!-- end verbatim block -->

<p>
This is perhaps a somewhat strange loop, but it is a well-established
way of reading a file in Python, especially in older code.  The shown
<code>while</code> loop runs forever since the condition is always
<code>True</code>. However, inside the loop we test if <code>line</code> is <code>False</code>, and it
is <code>False</code> when we reach the end of the file, because <code>line</code> then
becomes an empty string, which in Python evaluates to <code>False</code>. When
<code>line</code> is <code>False</code>, the <code>break</code> statement breaks the loop and makes the
program flow jump to the first statement after the <code>while</code> block.

<p>
Computing the average of the numbers in the <code>data.txt</code> file can now be done
in yet another way:

<p>
<!-- begin verbatim block  pypro-->
<pre><code>infile = open('data.txt', 'r')
mean = 0
n = 0
while True:
    line = infile.readline()
    if not line:
        break
    mean += float(line)
    n += 1
mean = mean/float(n)
</code></pre>
<!-- end verbatim block -->

<h3>Reading a file into a string  <a name="___sec20"></a></h3>

The call <code>infile.read()</code> reads the whole file and returns the text
as a string object.
The following interactive session illustrates the use and result
of <code>infile.read()</code>:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; infile = open('data.txt', 'r')
&gt;&gt;&gt; filestr = infile.read()
&gt;&gt;&gt; filestr
'21.8\n18.1\n19\n23\n26\n17.8\n'
&gt;&gt;&gt; print filestr
21.8
18.1
19
23
26
17.8
</code></pre>
<!-- end verbatim block -->
Note the difference between just writing <code>filestr</code> and writing
<code>print filestr</code>. The former dumps the string with newlines as
<em>backslash n</em> characters, while the latter is a <em>pretty print</em>
where the string is written out without quotes and with the newline
characters as visible line shifts.

<p>
Having the numbers inside a string instead of inside a file does
not look like a major step forward. However, string objects have
many useful functions for extracting information. A very useful
feature is <em>split</em>: <code>filestr.split()</code> will split the
string into words (separated by blanks or any other sequence of characters
you have defined). The &quot;words&quot; in this file are the numbers:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; words = filestr.split()
&gt;&gt;&gt; words
['21.8', '18.1', '19', '23', '26', '17.8']
&gt;&gt;&gt; numbers = [float(w) for w in words]
&gt;&gt;&gt; mean = sum(numbers)/len(numbers)
&gt;&gt;&gt; print mean
20.95
</code></pre>
<!-- end verbatim block -->
A more compact program looks as follows
(<a href="http://tinyurl.com/pwyasaa/input/mean3.py" target="_self"><tt>mean3.py</tt></a>):

<p>
<!-- begin verbatim block  pycod-->
<pre><code>infile = open('data.txt', 'r')
numbers = [float(w) for w in infile.read().split()]
mean = sum(numbers)/len(numbers)
</code></pre>
<!-- end verbatim block -->
The next section tells you more about splitting strings.

<h2>Reading a mixture of text and numbers <a name="sec:files:textnum"></a></h2>

The <code>data.txt</code> file has a very simple structure since it contains
numbers only. Many data files contain a mix of text and numbers.
The file <code>rainfall.dat</code> from
<a href="http://www.worldclimate.com/cgi-bin/data.pl?ref=N41E012+2100+1623501G1" target="_self"><tt>www.worldclimate.com</tt></a> provides an example:

<p>
<!-- begin verbatim block  dat-->
<pre><code>Average rainfall (in mm) in Rome: 1188 months between 1782 and 1970
Jan  81.2
Feb  63.2
Mar  70.3
Apr  55.7
May  53.0
Jun  36.4
Jul  17.5
Aug  27.5
Sep  60.9
Oct  117.7
Nov  111.0
Dec  97.9
Year 792.9
</code></pre>
<!-- end verbatim block -->

<p>
How can we read the rainfall data in this file and store the information
in lists suitable for further analysis?
The most straightforward solution is to read the file line by line,
and for each line split the line into words, store the first word
(the month) in one list and the second word (the average rainfall)
in another list. The elements in this latter list needs to be
<code>float</code> objects if we want to compute with them.

<p>
The complete code, wrapped in a function, may look like this
(file <a href="http://tinyurl.com/pwyasaa/input/rainfall1.py" target="_self"><tt>rainfall1.py</tt></a>):

<p>
<!-- begin verbatim block  pypro-->
<pre><code>def extract_data(filename):
    infile = open(filename, 'r')
    infile.readline() # skip the first line
    months = []
    rainfall = []
    for line in infile:
        words = line.split()
        # words[0]: month, words[1]: rainfall
        months.append(words[0])
        rainfall.append(float(words[1]))
    infile.close()
    months = months[:-1]      # Drop the &quot;Year&quot; entry
    annual_avg = rainfall[-1] # Store the annual average
    rainfall = rainfall[:-1]  # Redefine to contain monthly data
    return months, rainfall, annual_avg

months, values, avg = extract_data('rainfall.dat')
print 'The average rainfall for the months:'
for month, value in zip(months, values):
    print month, value
print 'The average rainfall for the year:', avg
</code></pre>
<!-- end verbatim block -->
Note that the first line in the file is just a comment line and of no
interest to us. We therefore read this line by <code>infile.readline()</code>
and do not store the content in any object.
The <code>for</code> loop over the lines in the file will then start from the
next (second) line.

<p>
We store all the data into 13 elements in the <code>months</code> and
<code>rainfall</code> lists. Thereafter, we manipulate these lists a
bit since we want <code>months</code> to contain the name of the 12
months only. The <code>rainfall</code> list should correspond to this
<code>month</code> list. The annual average is taken out of <code>rainfall</code> and
stored in a separate variable.
Recall that the <code>-1</code> index corresponds to the last element of
a list, and the slice <code>:-1</code> picks out all elements from the
start up to, but not including, the last element.

<p>
We could, alternatively, have written a shorter code where
the name of the months and the rainfall numbers are stored in
a nested list:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def extract_data(filename):
    infile = open(filename, 'r')
    infile.readline()  # skip the first line
    data = [line.split() for line in infile]
    annual_avg = data[-1][1]
    data = [(m, float(r)) for m, r in data[:-1]]
    infile.close()
    return data, annual_avg
</code></pre>
<!-- end verbatim block -->
This is more advanced code, but understanding what is going on
is a good test on the understanding of nested lists indexing
and list comprehensions. An executable program is found in
the file <a href="http://tinyurl.com/pwyasaa/input/rainfall2.py" target="_self"><tt>rainfall2.py</tt></a>.

<h3>Is it more to file reading?  <a name="___sec22"></a></h3>

With the example code in this section, you have the very basic tools
for reading files with a simple structure: columns of text or numbers.
Many files used in scientific computations have such a format, but
many files are more complicated too. Then you need the techniques
of string processing.
This is explained in detail in the chapter ref{ch:files}.

<h1>Writing data to file <a name="sec:files:writing"></a></h1>

Writing data to file is easy.
There is basically one function to pay attention to: <code>outfile.write(s)</code>,
which writes a string <code>s</code> to
a file handled by the file object <code>outfile</code>. Unlike <code>print</code>,
<code>outfile.write(s)</code>
does not append a newline character to the written string.
It will therefore
often be necessary to add a newline character,

<p>
<!-- begin verbatim block  pycod-->
<pre><code>outfile.write(s + '\n')
</code></pre>
<!-- end verbatim block -->
if the string <code>s</code> is meant to appear on a single line in the file
and <code>s</code> does not already contain a trailing newline character.
File writing is then a matter of constructing strings containing the
text we want to have in the file and for each such string call
<code>outfile.write</code>.

<p>
Writing to a file demands
the file object <code>f</code>
to be opened for writing:

<p>
<!-- begin verbatim block  pycod-->
<pre><code># write to new file, or overwrite file:
outfile = open(filename, 'w')

# append to the end of an existing file:
outfile = open(filename, 'a')
</code></pre>
<!-- end verbatim block -->

<h2>Example: Writing a table to file  <a name="___sec24"></a></h2>

<h3>Problem  <a name="___sec25"></a></h3>

As a worked example of file writing, we shall write out a nested list
with tabular data to file.  A sample list may take look as

<p>
<!-- begin verbatim block  ccq-->
<pre><code>[[ 0.75,        0.29619813, -0.29619813, -0.75      ],
 [ 0.29619813,  0.11697778, -0.11697778, -0.29619813],
 [-0.29619813, -0.11697778,  0.11697778,  0.29619813],
 [-0.75,       -0.29619813,  0.29619813,  0.75      ]]
</code></pre>
<!-- end verbatim block -->

<h3>Solution  <a name="___sec26"></a></h3>

We iterate through the rows (first index) in the list, and for each row,
we iterate through the column values (second index)
and write each value to the file.
At the end of each row, we must insert a newline character in the file to get
a linebreak. The code resides in the file <a href="http://tinyurl.com/pwyasaa/input/write1.py" target="_self"><tt>write1.py</tt></a>:

<p>
<!-- begin verbatim block  pypro-->
<pre><code>data = [[ 0.75,        0.29619813, -0.29619813, -0.75      ],
        [ 0.29619813,  0.11697778, -0.11697778, -0.29619813],
        [-0.29619813, -0.11697778,  0.11697778,  0.29619813],
        [-0.75,       -0.29619813,  0.29619813,  0.75      ]]

outfile = open('tmp_table.dat', 'w')
for row in data:
    for column in row:
        outfile.write('%14.8f' % column)
    outfile.write('\n')
outfile.close()
</code></pre>
<!-- end verbatim block -->

<p>
The resulting data file becomes

<p>
<!-- begin verbatim block  dat-->
<pre><code>    0.75000000    0.29619813   -0.29619813   -0.75000000
    0.29619813    0.11697778   -0.11697778   -0.29619813
   -0.29619813   -0.11697778    0.11697778    0.29619813
   -0.75000000   -0.29619813    0.29619813    0.75000000
</code></pre>
<!-- end verbatim block -->

<p>
An extension of this program consists in adding column and row headings:

<p>
<!-- begin verbatim block  dat-->
<pre><code>           column  1     column  2     column  3     column  4
row  1    0.75000000    0.29619813   -0.29619813   -0.75000000
row  2    0.29619813    0.11697778   -0.11697778   -0.29619813
row  3   -0.29619813   -0.11697778    0.11697778    0.29619813
row  4   -0.75000000   -0.29619813    0.29619813    0.75000000
</code></pre>
<!-- end verbatim block -->
To obtain this end result, we need to the add some statements to
the program <code>write1.py</code>. For the column headings we must
know the number of columns, i.e., the length of the rows,
and loop from 1 to this length:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>ncolumns = len(data[0])
outfile.write('          ')
for i in range(1, ncolumns+1):
    outfile.write('%10s    ' % ('column %2d' % i))
outfile.write('\n')
</code></pre>
<!-- end verbatim block -->
Note the use of a nested printf construction: the text we want to
insert is itself a printf string. We could also have written the
text as <code>'column  ' + str(i)</code>, but then the length of the
resulting string would depend on the number of digits in <code>i</code>.
It is recommended to always use printf constructions for
a tabular output format, because this gives automatic padding of
blanks so that the width of the output strings remains the same.
The tuning of the widths is commonly done in a trial-and-error
process.

<p>
To add the row headings, we need a counter over the row numbers:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>row_counter = 1
for row in data:
    outfile.write('row %2d' % row_counter)
    for column in row:
        outfile.write('%14.8f' % column)
    outfile.write('\n')
    row_counter += 1
</code></pre>
<!-- end verbatim block -->
The complete code is found in the file <a href="http://tinyurl.com/pwyasaa/input/write2.py" target="_self"><tt>write2.py</tt></a>.
We could, alternatively, iterate over the indices in the list:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>for i in range(len(data)):
    outfile.write('row %2d' % (i+1))
    for j in range(len(data[i])):
        outfile.write('%14.8f' % data[i][j])
    outfile.write('\n')
</code></pre>
<!-- end verbatim block -->

<h2>Standard input and output as file objects  <a name="___sec27"></a></h2>

Reading user input from the keyboard applies the function
<code>raw_input</code> as explained in the section <a href="#sec:input:rawinput">Asking questions and reading answers</a>.
The keyboard is a medium that the computer in fact
treats as a file, referred to
as <em>standard input</em>.

<p>
The <code>print</code> command prints text in the terminal window. This medium is
also viewed as a file from the computer's point of view and called
<em>standard output</em>. All general-purpose programming languages allow
reading from standard input and writing to standard output. This
reading and writing can be done with two types of tools, either
file-like objects or special tools like <code>raw_input</code> and <code>print</code> in
Python.  We will here describe the file-line objects: <code>sys.stdin</code> for
standard input and <code>sys.stdout</code> for standard output. These objects
behave as file objects, except that they do not need to be opened or
closed. The statement

<p>
<!-- begin verbatim block  pycod-->
<pre><code>s = raw_input('Give s:')
</code></pre>
<!-- end verbatim block -->
is equivalent to

<p>
<!-- begin verbatim block  pycod-->
<pre><code>print 'Give s: ',
s = sys.stdin.readline()
</code></pre>
<!-- end verbatim block -->
Recall that the trailing comma in the <code>print</code> statement avoids the
newline that <code>print</code> by default adds to the output string.
Similarly,

<p>
<!-- begin verbatim block  pycod-->
<pre><code>s = eval(raw_input('Give s:'))
</code></pre>
<!-- end verbatim block -->
is equivalent to

<p>
<!-- begin verbatim block  pycod-->
<pre><code>print 'Give s: ',
s = eval(sys.stdin.readline())
</code></pre>
<!-- end verbatim block -->
For output to the terminal window, the statement

<p>
<!-- begin verbatim block  pycod-->
<pre><code>print s
</code></pre>
<!-- end verbatim block -->
is equivalent to

<p>
<!-- begin verbatim block  pycod-->
<pre><code>sys.stdout.write(s + '\n')
</code></pre>
<!-- end verbatim block -->

<p>
Why it is handy to have access to standard input and output
as file objects can be illustrated by an example. Suppose you have a
function that reads data from a file object <code>infile</code>
and writes data to a file object <code>outfile</code>.
A sample function may take the form

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def x2f(infile, outfile, f):
    for line in infile:
        x = float(line)
        y = f(x)
        outfile.write('%g\n' % y)
</code></pre>
<!-- end verbatim block -->
This function works with all types of files, including
web pages as <code>infile</code> (see the section ref{sec:files:webtxt}).
With <code>sys.stdin</code> as <code>infile</code> and/or <code>sys.stdout</code>
as <code>outfile</code>, the <code>x2f</code> function also works with standard input
and/or standard output. Without <code>sys.stdin</code> and <code>sys.stdout</code>,
we would need different code, employing <code>raw_input</code>
and <code>print</code>,
to deal with standard input and output. Now we can write a single
function that deals with all file media in a unified way.

<p>
There is also something called <em>standard error</em>.
Usually this is the terminal window, just as standard output, but
programs can distinguish between writing ordinary output to standard
output and error messages to standard error, and these output media
can be redirected to, e.g., files such that one can separate
error messages from ordinary output.
In Python, standard error is the file-like object <code>sys.stderr</code>.
A typical application of <code>sys.stderr</code> is to report errors:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>if x &lt; 0:
    sys.stderr.write('Illegal value of x'); sys.exit(1)
</code></pre>
<!-- end verbatim block -->
This message to <code>sys.stderr</code> is an alternative to
<code>print</code> or raising an exception.

<h3>Redirecting standard input, output, and error  <a name="___sec28"></a></h3>

Standard output from a program <code>prog</code>
can be redirected to a file
<code>output</code> instead of the screen, by
using the greater than sign:

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; prog &gt; output
</code></pre>
<!-- end verbatim block -->
Here, <code>prog</code> can be any
program, including a Python program run as <code>python myprog.py</code>.
Similarly, output to the medium called <em>standard error</em>
can be redirected by

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; prog &amp;&gt; output
</code></pre>
<!-- end verbatim block -->
For example, error messages are normally written to standard error, which
is exemplified in this little terminal session on a Unix machine:

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; ls bla-bla1 bla-bla2
ls: cannot access bla-bla1: No such file or directory
ls: cannot access bla-bla2: No such file or directory
Terminal&gt; ls bla-bla1 bla-bla2 &amp;&gt; errors
Terminal&gt; cat errors  # print the file errors
ls: cannot access bla-bla1: No such file or directory
ls: cannot access bla-bla2: No such file or directory
</code></pre>
<!-- end verbatim block -->
When the program reads from standard input (the keyboard),
we can equally well redirect
standard input from a file, say with name <code>input</code>, such that
the program reads from this file rather than from the keyboard:

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; prog &lt; input
</code></pre>
<!-- end verbatim block -->
Combinations are also possible:

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; prog &lt; input &gt; output
</code></pre>
<!-- end verbatim block -->

<h3>Note  <a name="___sec29"></a></h3>

The redirection of standard output, input, and error
does not work for Python programs executed with the <code>run</code>
command inside IPython, only when executed directly
in the operating system in a terminal window, or with the same
command prefixed with an exclamation mark in IPython.

<p>
Inside a Python program we can also let standard input, output, and
error work with ordinary files instead. Here is the technique:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>sys_stdout_orig = sys.stdout
sys.stdout = open('output', 'w')
sys_stdin_orig = sys.stdin
sys.stdin = open('input', 'r')
</code></pre>
<!-- end verbatim block -->
Now, any <code>print</code> statement will write to the <code>output</code> file, and
any <code>raw_input</code> call will read from the <code>input</code> file.
(Without storing the original <code>sys.stdout</code> and <code>sys.stdin</code>
objects in new variables, these objects would get lost in the redefinition
above and we would never be able to reach the common standard input and
output in the program.)

<h2>What is a file, really? <a name="sec:files:really"></a></h2>

This section is not mandatory for understanding the rest of the document.
Nevertheless, the information here is fundamental for understanding
what files are about.

<p>
A file is simply a sequence of characters. In addition to the sequence
of characters, a file has some data associated with it, typically the
name of the file, its location on the disk, and the file size.  These
data are stored somewhere by the operating system.  Without this extra
information beyond the pure file contents as a sequence of characters,
the operating system cannot find a file with a given name on the disk.

<p>
Each character in the file is represented as a <em>byte</em>, consisting of
eight <em>bits</em>.  Each bit is either 0 or 1.  The zeros and ones in a
byte can be combined in \( 2^8=256 \) ways. This means that there are 256
different types of characters.  Some of these characters can be
recognized from the keyboard, but there are also characters that do
not have a familiar symbol. Such characters looks cryptic
when printed.

<h3>Pure text files  <a name="___sec31"></a></h3>

To see that a file is really just a sequence of characters, invoke an
editor for plain text, typically the editor you use to write Python
programs.  Write the four characters <code>ABCD</code> into the editor, do not
press the Return key, and save the text to a file <code>test1.txt</code>. Use
your favorite tool for file and folder overview and move to the folder
containing the <code>test1.txt</code> file.  This tool may be Windows Explorer,
My Computer, or a DOS window on Windows; a terminal window, Konqueror,
or Nautilus on Linux; or a terminal window or Finder on Mac.  If you
choose a terminal window, use the <code>cd</code> (change directory) command to
move to the proper folder and write <code>dir</code> (Windows) or <code>ls -l</code>
(Linux/Mac) to list the files and their sizes. In a graphical program
like Windows Explorer, Konqueror, Nautilus, or Finder, select a view
that shows the <em>size</em> of each file (choose <em>view as details</em> in
Windows Explorer, <em>View as List</em> in Nautilus, the list view icon in
Finder, or you just point at a file icon in Konqueror and watch the
pop-up text).  You will see that the <code>test1.txt</code> file has a size of 4
bytes (if you use <code>ls -l</code>, the size measured in bytes is found in
column 5, right before the date).  The 4 bytes are exactly the 4
characters <code>ABCD</code> in the file. Physically, the file is just a sequence
of 4 bytes on your hard disk.

<p>
Go back to the editor again and add a newline by pressing the Return key.
Save this new version of the file as <code>test2.txt</code>. When you now
check the size of the file it has grown to five bytes. The reason is
that we added a newline character (symbolically known as <em>backslash n</em>:
<code>\n</code>).

<p>
Instead of examining files via editors and folder viewers
we may use Python interactively:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; file1 = open('test1.txt', 'r').read()  # read file into string
&gt;&gt;&gt; file1
'ABCD'
&gt;&gt;&gt; len(file1)        # length of string in bytes/characters
4
&gt;&gt;&gt; file2 = open('test2.txt', 'r').read()
&gt;&gt;&gt; file2
'ABCD\n'
&gt;&gt;&gt; len(file2)
5
</code></pre>
<!-- end verbatim block -->
Python has in fact a function that returns the size of a file
directly:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; size = os.path.getsize('test1.txt')
&gt;&gt;&gt; size
4
</code></pre>
<!-- end verbatim block -->

<h3>Word processor files  <a name="___sec32"></a></h3>

Most computer users write text in a word processing program, such as
Microsoft Word or LibreOffice.  Let us investigate what happens with
our four characters <code>ABCD</code> in such a program. Start the word
processor, open a new document, and type in the four characters <code>ABCD</code>
only. Save the document as a <code>.docx</code> file (Microsoft Word) or an <code>.odt</code>
file (LibreOffice). Load this file into an editor for pure text and
look at the contents. You will see that there are numerous strange
characters that you did not write (!). This additional &quot;text&quot;
contains information on what type of document this is, the font you
used, etc. The LibreOffice version of this file has 8858 bytes
and the Microsoft Word version contains over 26 Kb!
However, if you save the file as a pure text file, with extension
<code>.txt</code>, the size is down to 8 bytes in LibreOffice and
five in Microsoft Word.

<p>
Instead of loading the LibreOffice file into an editor we can again
read the file contents into a string in Python and examine this string:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; infile = open('test3.odt', 'r')  # open LibreOffice file
&gt;&gt;&gt; s = infile.read()
&gt;&gt;&gt; len(s)   # file size
8858
&gt;&gt;&gt; s
'PK\x03\x04\x14\x00\x00\x08\x00\x00sKWD^\xc62\x0c\'\x00...
\x00meta.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;office:...
&quot; xmlns:meta=&quot;urn:oasis:names:tc:opendocument:xmlns:meta:1.0&quot;
</code></pre>
<!-- end verbatim block -->
Each backslash followed by <code>x</code> and a number is a code for a
special character not found on the keyboard (recall that there are
256 characters and only a subset is associated with keyboard symbols).
Although we show just a small portion of all the characters in this file
in the above output (otherwise, the output would have occupied several
pages in this document with thousands symbols like <code>\x04</code>...),
we can guarantee that you cannot find the pure sequence of characters
<code>ABCD</code>. However, the computer program that generated the file,
LibreOffice in this example, can easily interpret the meaning of
all the characters in the file
and translate the information into nice, readable text on the screen
where you can recognize the text <code>ABCD</code>.

<p>
Your are now in a position to look into <a href="#sec:files:ex7">Exercise 8: Try MSWord or LibreOffice to write a program</a> to
see what happens if one attempts to use LibreOffice to write Python
programs.

<h3>Image files  <a name="___sec33"></a></h3>

A digital image - captured by a digital camera or a mobile phone - is
a file. And since it is a file, the image is just a sequence of
characters. Loading some JPEG file into a pure text editor, reveals
all the strange characters in there. On the first line you will
(normally) find some recognizable text in between the strange
characters.  This text reflects the type of camera used to capture the
image and the date and time when the picture was taken.  The next
lines contain more information about the image.  Thereafter, the file
contains a set of numbers representing the image.  The basic
representation of an image is a set of \( m\times n \) pixels, where each
pixel has a color represented as a combination of 256 values of red,
green, and blue, which can be stored as three bytes (resulting in
\( 256^3 \) color values).  A 6-megapixel camera will then need to store
\( 3\times 6\cdot 10^6 = 18 \) megabytes for one picture.  The JPEG file
contains only a couple of megabytes. The reason is that JPEG is a
<em>compressed</em> file format, produced by applying a smart technique that
can throw away pixel information in the original picture such that the
human eye hardly can detect the inferior quality.

<p>
A video is just a sequence of images, and therefore a video is also a
stream of bytes.  If the change from one video frame (image) to the
next is small, one can use smart methods to compress the image
information in time. Such compression is particularly important for
videos since the file sizes soon get too large for being transferred
over the Internet. A small video file occasionally has bad visual
quality, caused by too much compression.

<h3>Music files  <a name="___sec34"></a></h3>

An MP3 file is much like a JPEG file: first, there is some information
about the music (artist, title, album, etc.), and then comes the music
itself as a stream of bytes. A typical MP3 file has a size of
something like five million bytes or five megabytes (5 Mb). The exact
size depends on the complexity of the music, the length of the track,
and the MP3 resolution.  On a 16 Gb MP3 player you can then store
roughly \( 16,000,000,000/5,000,000 = 3200 \) MP3 files. MP3 is, like JPEG,
a compressed format. The complete data of a song on a CD (the WAV
file) contains about ten times as many bytes. As for pictures, the
idea is that one can throw away a lot of bytes in an intelligent way,
such that the human ear hardly detects the difference between a
compressed and uncompressed version of the music file.

<h3>PDF files  <a name="___sec35"></a></h3>

Looking at a PDF file in a pure text editor shows that the file
contains some readable text mixed with some unreadable characters. It
is not possible for a human to look at the stream of bytes and deduce
the text in the document (well, from the assumption that there are
always some strange people doing strange things, there might be
somebody out there who, with a lot of training, can interpret the pure
PDF code with the eyes).  A PDF file reader can easily interpret the
contents of the file and display the text in a human-readable form on
the screen.

<h3>Remarks  <a name="___sec36"></a></h3>

We have repeated many times that a file is just a stream of bytes.  A
human can interpret (read) the stream of bytes if it makes sense in a
human language - or a computer language (provided the human is a
programmer).  When the series of bytes does not make sense to any
human, a computer program must be used to interpret the sequence of
characters.

<p>
Think of a report. When you write the report as pure text in a text
editor, the resulting file contains just the characters you typed in
from the keyboard. On the other hand, if you applied a word processor
like Microsoft Word or LibreOffice, the report file contains a large
number of extra bytes describing properties of the formatting of the
text.  This stream of extra bytes does not make sense to a human, and
a computer program is required to interpret the file content and
display it in a form that a human can understand. Behind the sequence
of bytes in the file there are strict rules telling what the series of
bytes means.  These rules reflect the <em>file format</em>. When the rules or
file format is publicly documented, a programmer can use this
documentation to make her own program for interpreting the file
contents (however, interpreting such files is much more complicated
than our examples on reading human-readable files in this document). It
happens, though, that secret file formats are used, which require
certain programs from certain companies to interpret the files.

<p>
<!-- It is a political question whether such secret -->
<!-- formats are suitable for storing important reports over periods of time that -->
<!-- are longer than the expected life of software companies. -->

<h1>Handling errors <a name="sec:input:except"></a></h1>

Suppose we forget to provide a command-line argument to the
<code>c2f_cml.py</code> program from the section <a href="#sec:input:cml">Providing input on the command line</a>:

<p>
<!-- begin verbatim block  sys-->
<pre><code>c2f_cml.py
Traceback (most recent call last):
  File &quot;c2f_cml.py&quot;, line 2, in ?
    C = float(sys.argv[1])
IndexError: list index out of range
</code></pre>
<!-- end verbatim block -->
Python aborts the program and shows an error message containing the
line where the error occurred, the type of the error (<code>IndexError</code>),
and a quick explanation of what the error is.
From this information we deduce that
the index 1 is out of range. Because there are
no command-line arguments in this case, <code>sys.argv</code> has only one
element, namely the program name. The only valid index is then 0.

<p>
For an experienced Python programmer this error message will normally
be clear enough to indicate what is wrong. For others it would be very
helpful if wrong usage could be detected by our program and a
description of correct operation could be printed.  The question is
how to detect the error inside the program.

<p>
The problem in our sample execution is that <code>sys.argv</code> does not
contain two elements (the program name, as always, plus one
command-line argument). We can therefore test on the length of
<code>sys.argv</code> to detect wrong usage: if <code>len(sys.argv)</code> is less than 2,
the user failed to provide information on the <code>C</code> value.  The new
version of the program, <code>c2f_cml_if.py</code>, starts with this <code>if</code> test:

<p>
<!-- begin verbatim block  pypro-->
<pre><code>if len(sys.argv) &lt; 2:
    print 'You failed to provide Celsius degrees as input '\ 
          'on the command line!'
    sys.exit(1)  # abort because of error
F = 9.0*C/5 + 32
print '%gC is %.1fF' % (C, F)
</code></pre>
<!-- end verbatim block -->
We use the <code>sys.exit</code> function to abort the program. Any argument
different from zero signifies that the program was aborted due to
an error, but the precise value of the argument does not matter so
here we simply choose it to be <code>1</code>. If no errors are found,
but we still want to abort the program, <code>sys.exit(0)</code> is used.

<p>
A more modern and flexible way of handling potential errors in a program
is
to <em>try</em> to execute some statements, and if something goes wrong,
the program can detect this and jump to a set of statements that
handle the erroneous situation as desired.
The relevant program construction reads

<p>
<!-- begin verbatim block  pycod-->
<pre><code>try:
    &lt;statements&gt;
except:
    &lt;statements&gt;
</code></pre>
<!-- end verbatim block -->
If something goes wrong when executing the statements in the
<code>try</code> block, Python raises what is known as an <em>exception</em>.
The execution jumps directly to the <code>except</code> block whose
statements can provide a remedy for the error. The next section
explains the <code>try-except</code> construction in more detail
through examples.

<h2>Exception handling <a name="sec:input:except:handling"></a></h2>

To clarify the idea of exception handling,
let us use a <code>try-except</code> block
to handle the potential problem arising when our
Celsius-Fahrenheit conversion program lacks a command-line argument:

<p>
<!-- begin verbatim block  pypro-->
<pre><code>import sys
try:
    C = float(sys.argv[1])
except:
    print 'You failed to provide Celsius degrees as input '\
          'on the command line!'
    sys.exit(1)  # abort
F = 9.0*C/5 + 32
print '%gC is %.1fF' % (C, F)
</code></pre>
<!-- end verbatim block -->
The program is stored in the file
<a href="http://tinyurl.com/pwyasaa/input/c2f_cml_except1.py" target="_self"><tt>c2f_cml_except1.py</tt></a>.  If the
command-line argument is missing, the indexing <code>sys.argv[1]</code>, which
has an invalid index <code>1</code>, <em>raises an exception</em>. This means that the
program jumps directly to the <code>except</code> block, implying that <code>float</code> is
not called, and <code>C</code> is not initialized with a value.  In the except
block, the programmer can retrieve information about the exception and
perform statements to recover from the error. In our example, we know
what the error can be, and therefore we just print a message and abort
the program.

<p>
Suppose the user provides a command-line argument. Now, the <code>try</code>
block is executed successfully, and the program neglects the
<code>except</code> block and continues with the Fahrenheit conversion.
We can try out the last program in two cases:

<p>
<!-- begin verbatim block  sys-->
<pre><code>c2f_cml_except1.py
You failed to provide Celsius degrees as input on the command line!

c2f_cml_except1.py 21
21C is 69.8F
</code></pre>
<!-- end verbatim block -->
In the first case, the illegal index in <code>sys.argv[1]</code> causes
an exception to be raised, and we perform the steps in the <code>except</code>
block. In the second case, the <code>try</code> block executes successfully,
so we jump over the <code>except</code> block and continue with the computations
and the printout of results.

<p>
For a user of the program, it does not matter if the programmer applies
an <code>if</code> test or exception handling to recover
from a missing command-line argument. Nevertheless, exception handling
is considered a better programming solution because it allows more
advanced ways to abort or continue the execution. Therefore, we
adopt exception handling as our standard way of dealing with errors in
the rest of this document.

<h3>Testing for a specific exception  <a name="___sec39"></a></h3>

Consider the assignment

<p>
<!-- begin verbatim block  pycod-->
<pre><code>C = float(sys.argv[1])
</code></pre>
<!-- end verbatim block -->
There are two typical errors associated with this statement: i)
<code>sys.argv[1]</code> is illegal indexing because no command-line arguments
are provided, and ii) the content in the string <code>sys.argv[1]</code>
is not a pure number that can be converted to a <code>float</code> object.
Python detects both these errors and raises an
<code>IndexError</code> exception
in the first case and a <code>ValueError</code> in the second.
In the program above, we jump to the <code>except</code> block and issue
the same message regardless of what went wrong in the <code>try</code>
block. For example, when we indeed provide a command-line argument, but
write it on an illegal form (<code>21C</code>), the program jumps to the
<code>except</code> block and prints a misleading message:

<p>
<!-- begin verbatim block  sys-->
<pre><code>c2f_cml_except1.py 21C
You failed to provide Celsius degrees as input on the command line!
</code></pre>
<!-- end verbatim block -->
The solution to this problem is to branch into different
<code>except</code> blocks depending on what type of exception that
was raised in the <code>try</code> block (program
<a href="http://tinyurl.com/pwyasaa/input/c2f_cml_except2.py" target="_self"><tt>c2f_cml_except2.py</tt></a>):

<p>
<!-- begin verbatim block  pypro-->
<pre><code>import sys
try:
    C = float(sys.argv[1])
except IndexError:
    print 'Celsius degrees must be supplied on the command line'
    sys.exit(1)  # abort execution
except ValueError:
    print 'Celsius degrees must be a pure number, '\
          'not &quot;%s&quot;' % sys.argv[1]
    sys.exit(1)

F = 9.0*C/5 + 32
print '%gC is %.1fF' % (C, F)
</code></pre>
<!-- end verbatim block -->

<p>
Now, if we fail to provide a command-line argument, an <code>IndexError</code>
occurs and we tell the user to write the <code>C</code> value on the
command line. On the other hand, if the <code>float</code> conversion fails,
because the command-line argument has wrong syntax, a
<code>ValueError</code> exception is raised and we branch into the second
<code>except</code> block and explain that the form of the given number is
wrong:

<p>
<!-- begin verbatim block  sys-->
<pre><code>c2f_cml_except1.py 21C
Celsius degrees must be a pure number, not &quot;21C&quot;
</code></pre>
<!-- end verbatim block -->

<h3>Examples on exception types  <a name="___sec40"></a></h3>

List indices out of range lead to
<code>IndexError</code> exceptions:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; data = [1.0/i for i in range(1,10)]
&gt;&gt;&gt; data[9]
...
IndexError: list index out of range
</code></pre>
<!-- end verbatim block -->
Some programming languages (Fortran, C, C++, and Perl are examples)
allow list indices outside the legal index values, and such unnoticed
errors can be hard to find. Python always stops a program when an
invalid index is encountered, unless you handle the exception
explicitly as a programmer.

<p>
Converting a string to <code>float</code> is unsuccessful and gives
a <code>ValueError</code> if the string is not a
pure integer or real number:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; C = float('21 C')
...
ValueError: invalid literal for float(): 21 C
</code></pre>
<!-- end verbatim block -->
Trying to use a variable that is not initialized gives a
<code>NameError</code> exception:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; print a
...
NameError: name 'a' is not defined
</code></pre>
<!-- end verbatim block -->
Division by zero raises a <code>ZeroDivisionError</code> exception:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; 3.0/0
...
ZeroDivisionError: float division
</code></pre>
<!-- end verbatim block -->
Writing a Python keyword illegally or performing a Python grammar error
leads to a <code>SyntaxError</code> exception:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; forr d in data:
...
    forr d in data:
         ^
SyntaxError: invalid syntax
</code></pre>
<!-- end verbatim block -->
What if we try to multiply a string by a number?

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; 'a string'*3.14
...
TypeError: can't multiply sequence by non-int of type 'float'
</code></pre>
<!-- end verbatim block -->
The <code>TypeError</code> exception is raised because the
object types
involved in the multiplication are wrong (<code>str</code> and <code>float</code>).

<h3>Digression  <a name="___sec41"></a></h3>

It might come as a surprise, but multiplication of a string and a number
is legal if the number is an integer. The multiplication means that
the string should be repeated the specified number of times.
The same rule also applies to lists:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; '--'*10   # ten double dashes = 20 dashes
'--------------------'
&gt;&gt;&gt; n = 4
&gt;&gt;&gt; [1, 2, 3]*n
[1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]
&gt;&gt;&gt; [0]*n
[0, 0, 0, 0]
</code></pre>
<!-- end verbatim block -->
The latter construction is handy when we want to create a list of
<code>n</code> elements and later assign specific values to each element in a
<code>for</code> loop.

<h2>Raising exceptions  <a name="___sec42"></a></h2>

When an error occurs in your program, you may either print a message
and use <code>sys.exit(1)</code> to abort the program, or you may raise
an exception. The latter task is easy. You just write
<code>raise E(message)</code>,
where <code>E</code> can be a known exception type in Python
and <code>message</code> is a string explaining what is wrong.
Most often <code>E</code> means
<code>ValueError</code> if the value of some variable is illegal, or
<code>TypeError</code> if the type of a variable is wrong.
You can also define your own exception types.
An exception can be raised from any location in a program.

<h3>Example  <a name="___sec43"></a></h3>

In the program <code>c2f_cml_except2.py</code> from the section <a href="#sec:input:except:handling">Exception handling</a> we show how we can test for different
exceptions and abort the program.  Sometimes we see that an exception
may happen, but if it happens, we want a more precise error message to
help the user.  This can be done by raising a new exception in an
<code>except</code> block and provide the desired exception type and message.

<p>
Another application of raising exceptions with tailored error messages
arises when input data are invalid. The code below illustrates how to
raise exceptions in various cases.

<p>
We collect the reading of <code>C</code> and handling of errors a separate
function:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def read_C():
    try:
        C = float(sys.argv[1])
    except IndexError:
        raise IndexError\ 
        ('Celsius degrees must be supplied on the command line')
    except ValueError:
        raise ValueError\ 
        ('Celsius degrees must be a pure number, '\ 
        'not &quot;%s&quot;' % sys.argv[1])
    # C is read correctly as a number, but can have wrong value:
    if C &lt; -273.15:
        raise ValueError('C=%g is a non-physical value!' % C)
    return C
</code></pre>
<!-- end verbatim block -->
There are two ways of using the <code>read_C</code> function.
The simplest is to call the function,

<p>
<!-- begin verbatim block  pycod-->
<pre><code>C = read_C()
</code></pre>
<!-- end verbatim block -->
Wrong input will now lead to a raw dump of exceptions, e.g.,

<p>
<!-- begin verbatim block  sys-->
<pre><code>c2f_cml_v5.py
Traceback (most recent call last):
  File &quot;c2f_cml4.py&quot;, line 5, in ?
    raise IndexError\ 
IndexError: Celsius degrees must be supplied on the command line
</code></pre>
<!-- end verbatim block -->
New users of this program may become uncertain when
getting raw output from exceptions, because words like
<code>Traceback</code>, <code>raise</code>, and <code>IndexError</code> do not make much sense
unless you have some experience with Python.
A more user-friendly output can be obtained by calling
the <code>read_C</code> function inside a <code>try-except</code> block,
check for any exception (or better: check for <code>IndexError</code>
<em>or</em> <code>ValueError</code>), and write out the exception message in
a more nicely formatted form. In this way, the programmer takes
complete control of how the program behaves when errors are encountered:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>try:
    C = read_C()
except Exception as e:
    print e            # exception message
    sys.exit(1)        # terminate execution
</code></pre>
<!-- end verbatim block -->
<code>Exception</code> is the parent name of all exceptions, and <code>e</code> is an
exception object. Nice printout of the exception message follows from
a straight <code>print e</code>.  Instead of <code>Exception</code> we can write
<code>(ValueError, IndexError)</code> to test more specifically for two exception
types we can expect from the <code>read_C</code> function:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>try:
    C = read_C()
except (ValueError, IndexError) as e:
    print e            # exception message
    sys.exit(1)        # terminate execution
</code></pre>
<!-- end verbatim block -->
After the <code>try-except</code> block above, we can continue with
computing <code>F = 9*C/5 + 32</code> and print out <code>F</code>.
The complete program is found in the file
<a href="http://tinyurl.com/pwyasaa/input/c2f_cml.py" target="_self"><tt>c2f_cml.py</tt></a>.
We may now test the program's behavior when the input is wrong and right:

<p>
<!-- begin verbatim block  sys-->
<pre><code>c2f_cml.py
Celsius degrees must be supplied on the command line

c2f_cml.py 21C
Celsius degrees must be a pure number, not &quot;21C&quot;

c2f_cml.py -500
C=-500 is a non-physical value!

c2f_cml.py 21
21C is 69.8F
</code></pre>
<!-- end verbatim block -->
This program deals with wrong
input, writes an informative message, and terminates the execution without
annoying behavior.

<p>
Scattered <code>if</code> tests with <code>sys.exit</code> calls are considered
a bad programming style compared to the use of nested exception handling
as illustrated above.
You should abort execution in the main program only, not inside
functions. The reason is that the functions can be re-used in other
occasions where the error can be dealt with differently. For instance, one may
avoid abortion by using some suitable default data.

<p>
The programming style illustrated above is considered the
best way of dealing with errors, so
we suggest that you hereafter apply exceptions for handling potential
errors in the programs you make, simply because this is what
experienced programmers expect from your codes.

<h1>A glimpse of graphical user interfaces <a name="sec:input:GUI"></a></h1>

Maybe you find it somewhat strange that the usage of the
programs we have made so
far in this document - and the programs we will make in the rest of the
book - are less graphical and intuitive than the computer programs you are
used to from school or entertainment.  Those programs are operated
through some self-explaining graphics, and most of the things you
want to do involve pointing with the mouse, clicking on graphical
elements on the screen, and maybe filling in some text fields.
The programs in this document, on the other hand,  are run from the
command line in a terminal window or inside IPython,
and input is also given here in
form of plain text.

<p>
The reason why we do not equip the programs in this document with graphical
interfaces for providing input, is that such graphics is both complicated
and tedious to write. If the aim is to solve problems from mathematics
and science, we think it is better to focus on this part rather
than large amounts
of code that merely offers some &quot;expected&quot; graphical
cosmetics for putting data into the program.
Textual input from the command line is also quicker to provide.
Also remember that the computational functionality of a program
is obviously independent from the type of user interface, textual or
graphic.

<p>
As an illustration, we shall now show a Celsius to Fahrenheit
conversion program with a graphical user interface (often called a
GUI).  The GUI is shown in Figure <a href="#sec:input:fig1">1</a>. We encourage
you to try out the graphical interface - the name of the program is
<a href="http://tinyurl.com/pwyasaa/input/c2f_gui.py" target="_self"><tt>c2f_gui.py</tt></a>.  The complete program
text is listed below.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 1:  Screen dump of the graphical interface for a Celsius to Fahrenheit conversion program. The user can type in the temperature in Celsius degrees, and when clicking on the <em>is</em> button, the corresponding Fahrenheit  value is displayed. <a name="sec:input:fig1"></a> </p></center>
<p><img src="fig-input/c2f_gui.png" align="bottom" width=400></p>
</center>

<p>
<!-- begin verbatim block  pypro-->
<pre><code>from Tkinter import *
root = Tk()
C_entry = Entry(root, width=4)
C_entry.pack(side='left')
Cunit_label = Label(root, text='Celsius')
Cunit_label.pack(side='left')

def compute():
    C = float(C_entry.get())
    F = (9./5)*C + 32
    F_label.configure(text='%g' % F)

compute = Button(root, text=' is ', command=compute)
compute.pack(side='left', padx=4)

F_label = Label(root, width=4)
F_label.pack(side='left')
Funit_label = Label(root, text='Fahrenheit')
Funit_label.pack(side='left')

root.mainloop()
</code></pre>
<!-- end verbatim block -->

<p>
The goal of the forthcoming dissection of this program is to give a
taste of how graphical user interfaces are coded. The aim is not to
equip you with knowledge on how you can make such programs on your
own.

<p>
A GUI is built of many small graphical elements,
called <em>widgets</em>.
The graphical window generated by the program above and
shown in Figure <a href="#sec:input:fig1">1</a> has five such widgets.
To the left there is an <em>entry</em> widget where the user can write
in text. To the right of this entry widget is a <em>label</em> widget,
which just displays some text, here &quot;Celsius&quot;. Then we have
a <em>button</em> widget, which when being clicked leads to computations
in the program. The result of these computations is displayed as
text in a <em>label</em> widget to the right of the button widget.
Finally, to the right of this result text we have another <em>label</em> widget
displaying the text &quot;Fahrenheit&quot;.
The program must construct each widget and pack it correctly into the
complete window. In the present case, all widgets are packed from left
to right.

<p>
The first statement in the program imports functionality from the GUI
toolkit <code>Tkinter</code> to construct widgets. First, we need to make
a root widget that holds the complete window with all the other widgets.
This root widget is of type <code>Tk</code>. The first entry widget is
then made and referred to by a variable <code>C_entry</code>.
This widget is an object of type <code>Entry</code>, provided by the
<code>Tkinter</code> module. Widgets constructions follow the syntax

<p>
<!-- begin verbatim block  pycod-->
<pre><code>variable_name = Widget_type(parent_widget, option1, option2, ...)
variable_name.pack(side='left')
</code></pre>
<!-- end verbatim block -->
When creating a widget, we must bind it to a <em>parent widget</em>, which
is the graphical element in which this new widget is to be packed.
Our widgets in the present program have the <code>root</code> widget as
parent widget. Various widgets have different types of options
that we can set. For example, the <code>Entry</code> widget has a possibility
for setting the width of the text field, here <code>width=4</code> means that
the text field is 4 characters wide.
The pack statement is important to remember - without it,
the widget remains invisible.

<p>
The other widgets are constructed in similar ways. The next fundamental
feature of our program is how computations are tied to the event of
clicking the button <em>is</em>. The <code>Button</code> widget has naturally a text,
but more important, it binds the button to a function <code>compute</code>
through the <code>command=compute</code> option.
This means that when the user clicks the button <em>is</em>, the
function <code>compute</code> is called. Inside the <code>compute</code> function
we first fetch the Celsius value from the <code>C_entry</code> widget,
using this widget's <code>get</code> function, then we transform this string
(everything typed in by the user is interpreted as text and stored in
strings) to a <code>float</code> before we compute the corresponding
Fahrenheit value. Finally, we can update (<code>configure</code>) the text in
the <code>Label</code> widget <code>F_label</code> with a new text, namely the
computed degrees in Fahrenheit.

<p>
A program with a GUI behaves differently from the programs we construct
in this document. First, all the statements are executed from top to bottom,
as in all our other programs, but these statements just construct the
GUI and define functions.
No computations are performed. Then the program enters a so-called
<em>event loop</em>: <code>root.mainloop()</code>.
This is an infinite loop that &quot;listens&quot; to
user events, such as moving the mouse, clicking the mouse, typing characters
on the keyboard, etc. When an event is recorded, the program starts
performing associated actions.
In the present case, the program waits for only one event: clicking the
button <em>is</em>. As soon as we click on the button, the <code>compute</code>
function is called and the program starts doing mathematical work.
The GUI will appear on the screen
until we destroy the window by click on the X up in the
corner of the window decoration.
More complicated GUIs will normally have a special
<em>Quit</em> button to terminate the event loop.

<p>
In all GUI programs, we must first create a hierarchy of widgets to build up
all elements of the user interface. Then the program enters an event
loop and waits for user events. Lots of such events are registered
as actions in the program when creating the widgets,
so when the user clicks on buttons, move
the mouse into certain areas, etc., functions in the program are called
and &quot;things happen&quot;.

<p>
Many books explain how to make GUIs in Python programs, see for instance
<a href="#PythonTk">[3]</a> <a href="#QuickPython">[4]</a> <a href="#TCSE3">[5]</a> <a href="#PythonBook">[6]</a>.

<h1>Making modules <a name="sec:input:modules"></a></h1>

Sometimes you want to reuse a function from an old program in a new
program. The simplest way to do this is to copy and paste the old
source code into the new program.  However, this is not good
programming practice, because you then over time end up with multiple
identical versions of the same function. When you want to improve the
function or correct a bug, you need to remember to do the same update
in all files with a copy of the function, and in real life most
programmers fail to do so. You easily end up with a mess of different
versions with different quality of basically the same code.
Therefore, a golden
rule of programming is to have one and only one version of a piece of code.
All programs that want to use this piece of code must access
one and only one place where the source code is kept.
This principle is easy
to implement if we create a module containing the code we want to
reuse later in different programs.

<p>
When reading this, you probably know how to use a ready-made module.
For example, if you want to compute the factorial \( k!=k(k-1)(k-2)\cdots 1 \),
there is a function <code>factorial</code> in Python's <code>math</code> module that
can be help us out. The usage goes with the <code>math</code> prefix,

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import math
value = math.factorial(5)
</code></pre>
<!-- end verbatim block -->
or without,

<p>
<!-- begin verbatim block  pycod-->
<pre><code>from math import factorial
# or: from math import *
value = factorial(5)
</code></pre>
<!-- end verbatim block -->

<p>
Now you shall learn how to make your own Python modules.  There is
hardly anything to learn, because you just collect all the functions
that constitute the module in one file, say with name
<code>mymodule.py</code>. This file is automatically a module, with name
<code>mymodule</code>, and you can import functions from this module in the
standard way.  Let us make everything clear in detail by looking at an
example.

<h2>Example: Interest on bank deposits  <a name="___sec46"></a></h2>

The classical formula for the growth of money in a bank reads

$$
\begin{equation}
A = A_0\left( 1 + {p\over 360\cdot 100}\right)^n,
\tag{2}
\end{equation}
$$

where \( A_0 \) is the initial amount of money, and \( A \) is the present amount
after \( n \) days with \( p \) percent annual interest rate.
(The formula applies the convention that
the rate per day is computed as \( p/360 \), while \( n \) counts the actual
number of days the money is in the bank, see the Wikipedia entry
<a href="http://en.wikipedia.org/wiki/Day_count_convention" target="_self">Day count convention</a>
for explanation.
There is a handy Python module
<code>datetime</code> for
computing the number of days between two dates.)

<p>
Equation <a href="#mjx-eqn-2">(2)</a> involves four parameters: \( A \), \( A_0 \), \( p \), and
\( n \). We may solve for any of these, given the other three:

$$
\begin{align}
A_0 &= A\left( 1 + {p\over 360\cdot 100}\right)^{-n},
\tag{3}\\ 
n &= \frac{\ln {A\over A_0}}{\ln \left( 1 + {p\over 360\cdot 100}\right)} ,\\ 
p &= 360\cdot 100 \left(\left({A\over A_0}\right)^{1/n} - 1\right)\tp
\tag{4}
\end{align}
$$

Suppose we have implemented <a href="#mjx-eqn-2">(2)</a>-<a href="#mjx-eqn-4">(4)</a>
in four functions:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>from math import log as ln

def present_amount(A0, p, n):
    return A0*(1 + p/(360.0*100))**n

def initial_amount(A, p, n):
    return A*(1 + p/(360.0*100))**(-n)

def days(A0, A, p):
    return ln(A/A0)/ln(1 + p/(360.0*100))

def annual_rate(A0, A, n):
    return 360*100*((A/A0)**(1.0/n) - 1)
</code></pre>
<!-- end verbatim block -->

<p>
We want to make these functions available in a module, say with
name <code>interest</code>, so that we
can import functions and compute with them in a program. For example,

<p>
<!-- begin verbatim block  pypro-->
<pre><code>from interest import days
A0 = 1; A = 2; p = 5
n = days(A0, 2, p)
years = n/365.0
print 'Money has doubled after %.1f years' % years
</code></pre>
<!-- end verbatim block -->
How to make the <code>interest</code> module is described next.

<h2>Collecting functions in a module file <a name="sec:input:module:create"></a></h2>

To make a module of the four functions
<code>present_amount</code>,
<code>initial_amount</code>,
<code>days</code>, and
<code>annual_rate</code>,
we simply open an empty file in a text
editor and copy the program code for all the four functions over
to this file. This file is then automatically a Python module
provided we save the file under any valid filename.
The extension must be <code>.py</code>, but the module name is only the
base part of the filename. In our case, the filename
<code>interest.py</code> implies a module name
<code>interest</code>. To use the <code>annual_rate</code> function in another program
we simply write, in that program file,

<p>
<!-- begin verbatim block  pycod-->
<pre><code>from interest import annual_rate
</code></pre>
<!-- end verbatim block -->
or we can write

<p>
<!-- begin verbatim block  pycod-->
<pre><code>from interest import *
</code></pre>
<!-- end verbatim block -->
to import all four functions, or we can write

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import interest
</code></pre>
<!-- end verbatim block -->
and access individual functions as <code>interest.annual_rate</code> and so forth.

<h2>Test block <a name="sec:input:module:testblock"></a></h2>

It is recommended to only have functions and not any statements
outside functions in a module. The reason is that the module file is
executed from top to bottom during the import. With function
definitions only in the module file, and no main program, there will
be no calculations or output from the import, just definitions of
functions.  This is the desirable behavior.  However, it is often
convenient to have test or demonstrations in the module file, and then
there is need for a main program.  Python allows a very fortunate
construction to let the file act both as a module with function
definitions only (and no main program) <em>and</em> as an ordinary
program we can run, with functions and a main program.

<p>
This two-fold &quot;magic&quot; is realized by putting the main program after an
<code>if</code> test of the form

<p>
<!-- begin verbatim block  pycod-->
<pre><code>if __name__ == '__main__':
    &lt;block of statements&gt;
</code></pre>
<!-- end verbatim block -->
The <code>__name__</code> variable is automatically defined in any
module and equals the module name if the module file is imported
in another program, or <code>__name__</code> equals
the string <code>'__main__'</code> if the module file is run
as a program. This implies that the <code><block of statements></code> part
is executed if and only if
we run the module file as a program. We shall refer to
<code><block of statements></code> as the <em>test block</em> of a module.

<h3>Example on a test block in a minimalistic module  <a name="___sec49"></a></h3>

A very simple example will illustrate how this works. Consider a
file <code>mymod.py</code> with the content

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def add1(x):
    return x + 1

if __name__ == '__main__':
    print 'run as program'
    print add1(float(sys.argv[1]))
</code></pre>
<!-- end verbatim block -->
We can import <code>mymod</code> as a module and make use of the <code>add1</code>
function:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; import mymod
&gt;&gt;&gt; print mymod.add1(4)
5
</code></pre>
<!-- end verbatim block -->
During the import, the <code>if</code> test is false, and the only the function
definition is executed. However, if we run <code>mymod.py</code> as a program,

<p>
<!-- begin verbatim block  sys-->
<pre><code>mymod.py 5
run as program
6
</code></pre>
<!-- end verbatim block -->
the <code>if</code> test becomes true, and the <code>print</code> statements are
executed.

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Tip on easy creation of a module.</b>
<p>
If you have some functions and a main program in some program file,
just move the main program to the test block. Then the file can act
as a module, giving access to all the functions in other files,
or the file can be executed from the command line,
in the same way as the original program.
</div>


<h3>A test block in the <code>interest</code> module  <a name="___sec50"></a></h3>

Let us write a little main program  for demonstrating
the <code>interest</code> module in a test block.
We read \( p \) from the command line and write out how many years
it takes to double an amount with that interest rate:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>if __name__ == '__main__':
    import sys
    p = float(sys.argv[1])
    years = days(1, 2, p)
    print 'With p=%.2f it takes %.1 years to double' % (p, years)
</code></pre>
<!-- end verbatim block -->
Running the module file as a program gives this output:

<p>
<!-- begin verbatim block  sys-->
<pre><code>interest.py 2.45
With p=2.45 it takes 27.9 years to double
</code></pre>
<!-- end verbatim block -->

<p>
To test that the <code>interest.py</code> file also works as a module,
invoke a Python shell and try to
import a function and compute with it:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; from interest import present_amount
&gt;&gt;&gt; present_amount(2, 5, 730)
2.2133983053266699
</code></pre>
<!-- end verbatim block -->
We have hence demonstrated that
the file <code>interest.py</code> works both as a program and as a module.

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Recommended practice in a test block.</b>
<p>
It is a good programming habit to let the test block do one or more
of three things:

<ul>
  <li> provide information on how the module or program is used,</li>
  <li> test if the module functions work properly,</li>
  <li> offer interaction with users such that the module file
    can be applied as a useful program.</li>
</ul>

Instead of having a lot of statements in the test block, it is
better to collect the statements in separate functions, which then
are called from the test block.
</div>


<h2>Verification of the module code <a name="sec:input:modules:testfunc"></a></h2>

Functions that verify the implementation in a module should

<ul>
 <li> have names starting with <code>test_</code>,</li>
 <li> express the success or failure of a test through a boolean variable,
   say <code>success</code>,</li>
 <li> run <code>assert success, msg</code> to raise an <code>AssertionError</code>
   with an optional message <code>msg</code> in case the test fails.</li>
</ul>

Adopting this style makes it trivial to let the tools <em>pytest</em> or <em>nose</em>
automatically run through all our <code>test_*()</code> functions in all files
in a folder tree.
A very brief introduction to test functions compatible with
pytest and nose is provided in the section ref{sec:funcif:summary:ex}, while
The
document <a href="http://tcse6.on.net/nose" target="_self">Unit testing with pytest and nose</a>
<a href="#Langtangen_TCSE6_nose">[7]</a>
contains a more thorough introduction to the pytest and nose testing
frameworks for beginners.

<p>
A proper test function for verifying the functionality of the
<code>interest</code> module, written in a way that is compatible with the pytest
and nose testing frameworks, looks as follows:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def test_all_functions():
    # Compatible values
    A = 2.2133983053266699; A0 = 2.0; p = 5; n = 730
    # Given three of these, compute the remaining one
    # and compare with the correct value (in parenthesis)
    A_computed  = present_amount(A0, p, n)
    A0_computed = initial_amount(A, p, n)
    n_computed  = days(A0, A, p)
    p_computed  = annual_rate(A0, A, n)

    def float_eq(a, b, tolerance=1E-14):
        &quot;&quot;&quot;Return True if a == b within the tolerance.&quot;&quot;&quot;
        return abs(a - b) &lt; tolerance

    success = float_eq(A_computed,  A)  and \ 
              float_eq(A0_computed, A0) and \ 
              float_eq(p_computed,  p)  and \ 
              float_eq(n_computed,  n)
    msg = &quot;&quot;&quot;Computations failed (correct answers in parenthesis):
A=%g (%g)
A0=%g (%.1f)
n=%d (%d)
p=%g (%.1f)&quot;&quot;&quot; % (A_computed, A, A0_computed, A0,
                  n_computed, n, p_computed, p)
    assert success, msg
</code></pre>
<!-- end verbatim block -->

<p>
We may require a single command-line argument
<code>test</code> to run the verification. The test block can then be expressed as

<p>
<!-- begin verbatim block  pycod-->
<pre><code>if __name__ == '__main__':
    if len(sys.argv) == 2 and sys.argv[1] == 'test':
        test_all_functions()
</code></pre>
<!-- end verbatim block -->

<h2>Getting input data <a name="sec:input:modules:inputdata"></a></h2>

To make a useful program, we should allow setting three parameters
on the command line and let the program compute the remaining parameter.
For example, running the program as

<p>
<!-- begin verbatim block  sys-->
<pre><code>interest.py A0=2 A=1 n=1095
</code></pre>
<!-- end verbatim block -->
will lead to a computation of \( p \), in this case
for seeing the size of the annual
interest rate if the amount is to be doubled after three years.

<p>
How can we achieve the desired functionality? Since variables are already
introduced and &quot;initialized&quot; on the command line, we could grab this
text and execute it as Python code, either as three different lines or
with semicolon between each assignment. This is easy:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>init_code = ''
for statement in sys.argv[1:]:
    init_code += statement + '\n'
exec(init_code)
</code></pre>
<!-- end verbatim block -->
(We remark that an experienced Python programmer
would have created <code>init_code</code> by <code>'\n'.join(sys.argv[1:])</code>.)
For the sample run above with <code>A0=2 A=1 n=1095</code> on the command line,
<code>init_code</code> becomes the string

<p>
<!-- begin verbatim block  ccq-->
<pre><code>A0=2
A=1
n=1095
</code></pre>
<!-- end verbatim block -->
Note that one cannot have spaces around the equal signs on the command
line as this will break an assignment like <code>A0 = 2</code> into
three command-line arguments, which will give rise to a
<code>SyntaxError</code> in <code>exec(init_code)</code>.
To tell the user about such errors, we
execute <code>init_code</code> inside a <code>try-except</code>
block:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>try:
    exec(init_code)
except SyntaxError as e:
    print e
    print init_code
    sys.exit(1)
</code></pre>
<!-- end verbatim block -->

<p>
At this stage, our program has hopefully initialized three parameters in a
successful way, and it remains to detect the remaining parameter to
be computed. The following code does the work:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>if 'A=' not in init_code:
    print 'A =', present_amount(A0, p, n)
elif 'A0=' not in init_code:
    print 'A0 =', initial_amount(A, p, n)
elif 'n=' not in init_code:
    print 'n =', days(A0, A , p)
elif 'p=' not in init_code:
    print 'p =', annual_rate(A0, A, n)
</code></pre>
<!-- end verbatim block -->
It may happen that the user of the program assigns value to a parameter
with wrong name or forget a parameter. In those cases we call
one of our four functions with uninitialized arguments, and Python raises
an exception.
Therefore, we should embed the code above in a <code>try-except</code>
block. An uninitialized variable will lead to a <code>NameError</code> exception, while
another frequent error is illegal values in the computations, leading to
a <code>ValueError</code> exception.
It is also a good habit to collect
all the code related to computing the remaining, fourth parameter
in a function for separating this piece of code from other parts of
the module file:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def compute_missing_parameter(init_code):
    try:
        exec(init_code)
    except SyntaxError as e:
        print e
        print init_code
        sys.exit(1)
    # Find missing parameter
    try:
        if 'A=' not in init_code:
            print 'A =', present_amount(A0, p, n)
        elif 'A0=' not in init_code:
            print 'A0 =', initial_amount(A, p, n)
        elif 'n=' not in init_code:
            print 'n =', days(A0, A , p)
        elif 'p=' not in init_code:
            print 'p =', annual_rate(A0, A, n)
    except NameError as e:
        print e
        sys.exit(1)
    except ValueError:
        print 'Illegal values in input:', init_code
        sys.exit(1)
</code></pre>
<!-- end verbatim block -->

<p>
If the user of the program fails to give any command-line arguments,
we print a usage statement.
Otherwise, we run a verification if the first command-line
argument is <code>test</code>, and else we run the missing parameter
computation (i.e., the useful main program):

<p>
<!-- begin verbatim block  pycod-->
<pre><code>_filename = sys.argv[0]
_usage = &quot;&quot;&quot;
Usage: %s A=10 p=5 n=730
Program computes and prints the 4th parameter'
(A, A0, p, or n)&quot;&quot;&quot; % _filename

if __name__ == '__main__':
    if len(sys.argv) == 1:
        print _usage
    elif len(sys.argv) == 2 and sys.argv[1] == 'test':
        test_all_functions()
    else:
        init_code = ''
        for statement in sys.argv[1:]:
            init_code += statement + '\n'
        compute_missing_parameter(init_code)
</code></pre>
<!-- end verbatim block -->

<p>
<div class="alert alert-block alert-warning alert-text-normal">
<b>Executing user input can be dangerous.</b>
<p>
Some purists would never demonstrate <code>exec</code> the way we do above.
The reason is that our program tries to execute whatever the
user writes. Consider

<p>
<!-- begin verbatim block  sys-->
<pre><code>input.py 'import shutil; shutil.rmtree(&quot;/&quot;)'
</code></pre>
<!-- end verbatim block -->
This evil use of the program leads to an attempt to remove all
files on the computer system (the same as writing <code>rm -rf /</code>
in the terminal window!). However, for small private programs
helping the program writer out with mathematical calculations,
this potential dangerous misuse is not so much of a concern
(the user just does harm to his own computer anyway).
</div>


<h2>Doc strings in modules  <a name="___sec53"></a></h2>

It is also a good habit to include a doc string in the beginning of
the module file. This doc string explains the purpose and use of
the module:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>&quot;&quot;&quot;
Module for computing with interest rates.
Symbols: A is present amount, A0 is initial amount,
n counts days, and p is the interest rate per year.

Given three of these parameters, the fourth can be
computed as follows:

    A  = present_amount(A0, p, n)
    A0 = initial_amount(A, p, n)
    n  = days(A0, A, p)
    p  = annual_rate(A0, A, n)
&quot;&quot;&quot;
</code></pre>
<!-- end verbatim block -->
You can run the <code>pydoc</code> program to see a documentation of the new
module, containing the doc string above and a list of the functions
in the module: just write <code>pydoc interest</code> in a terminal window.

<p>
Now the reader is recommended to take a look at the actual file
<a href="http://tinyurl.com/pwyasaa/input/interest.py" target="_self"><tt>interest.py</tt></a> to see all elements
of a good module file at once: doc strings, a set of functions,
a test function, a function with the main program, a usage string,
and a test block.

<h2>Using modules <a name="sec:input:modules:usage"></a></h2>

Let us further demonstrate how to use the <code>interest.py</code> module in
programs. For illustration purposes, we make a separate program file,
say with name <code>doubling.py</code>, containing some computations:

<p>
<!-- begin verbatim block  pypro-->
<pre><code>from interest import days

# How many days does it take to double an amount when the
# interest rate is p=1,2,3,...14?
for p in range(1, 15):
    years = days(1, 2, p)/365.0
    print 'With p=%d%% it takes %.1f years to double the amount' %\ 
    (p, years)
</code></pre>
<!-- end verbatim block -->

<h3>What gets imported by various import statements?  <a name="___sec55"></a></h3>

There are different ways to import functions in a module, and let us
explore these in an interactive session. The function call <code>dir()</code>
will list all names we have defined, including imported names of
variables and functions. Calling <code>dir(m)</code> will print the names
defined inside a module with name <code>m</code>.
First we start an interactive shell and call <code>dir()</code>

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; dir()
['__builtins__', '__doc__', '__name__', '__package__']
</code></pre>
<!-- end verbatim block -->
These variables are always defined. Running the IPython shell
will introduce several
other standard variables too.
Doing

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; from interest import *
&gt;&gt;&gt; dir()
['__builtins__', '__doc__', '__name__', '__package__',
 'annual_rate', 'compute_missing_parameter', 'days',
 'initial_amount', 'ln', 'present_amount', 'sys',
 'test_all_functions']
</code></pre>
<!-- end verbatim block -->
shows that we get our four functions imported, along with
<code>ln</code> and <code>sys</code>. The latter two are needed in the
<code>interest</code> module, but not necessarily in our new program
<code>doubling.py</code>.

<p>
The alternative <code>import interest</code> actually gives us access to
more names in the module, namely also all variables and functions
that start with an underscore:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; import interest
&gt;&gt;&gt; dir(interest)
['__builtins__', '__doc__', '__file__', '__name__',
 '__package__', '_filename', '_usage', 'annual_rate',
 'compute_missing_parameter', 'days', 'initial_amount',
 'ln', 'present_amount', 'sys', 'test_all_functions']
</code></pre>
<!-- end verbatim block -->
It is a habit to use an underscore for all variables that
are not to be included in a <code>from interest import *</code> statement.
These variables can, however, be reached through <code>interest._filename</code>
and <code>interest._usage</code> in the present example.

<p>
It would be best that a statement <code>from interest import *</code> just
imported the four functions doing the computations of
general interest in other programs. This can be archived by
deleting all unwanted names (among those without an initial underscore)
at the very end of the module:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>del sys, ln, compute_missing_parameter, test_all_functions
</code></pre>
<!-- end verbatim block -->

<p>
Instead of deleting variables and using initial underscores in names,
it is in general better to specify the special variable <code>__all__</code>,
which is used by Python to select functions to be imported in
<code>from interest import *</code> statements. Here we can define
<code>__all__</code> to contain the four function of main interest:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>__all__ = ['annual_rate', 'days', 'initial_amount', 'present_amount']
</code></pre>
<!-- end verbatim block -->
Now we get

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; from interest import *
['__builtins__', '__doc__', '__name__', '__package__',
 'annual_rate', 'days', 'initial_amount', 'present_amount']
</code></pre>
<!-- end verbatim block -->

<h3>How to make Python find a module file  <a name="___sec56"></a></h3>

The <code>doubling.py</code> program works well as long as it is located in the
same folder as the <code>interest.py</code> module. However, if we
move <code>doubling.py</code> to another folder and run it, we get
an error:

<p>
<!-- begin verbatim block  sys-->
<pre><code>doubling.py
Traceback (most recent call last):
  File &quot;doubling.py&quot;, line 1, in &lt;module&gt;
    from interest import days
ImportError: No module named interest
</code></pre>
<!-- end verbatim block -->
Unless the module file resides in the same folder, we need to tell Python
where to find our module.
Python looks for modules in the folders contained
in the list <code>sys.path</code>.
A little program

<p>
<!-- begin verbatim block  pypro-->
<pre><code>import sys, pprint
pprint.pprint(sys.path)
</code></pre>
<!-- end verbatim block -->
prints out all these predefined module folders.
You can now do one of two things:

<ol>
 <li> Place the module file in one of the folders in <code>sys.path</code>.</li>
 <li> Include the folder containing the module file in <code>sys.path</code>.</li>
</ol>

There are two ways of doing the latter task. Alternative 1 is to
explicitly insert a new folder name in <code>sys.path</code> in
the program that uses the module:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>modulefolder = '../../pymodules'
sys.path.insert(0, modulefolder)
</code></pre>
<!-- end verbatim block -->
(In this sample path,
the slashes are Unix specific. On
Windows you must use backslashes and a raw string.
A better solution is to express the path as
<code>os.path.join(os.pardir, os.pardir, 'mymodules')</code>.
This will work on all platforms.)

<p>
Python searches the folders in the sequence they appear in the
<code>sys.path</code> list so by inserting the folder name as the
first list element we ensure that our module is found quickly,
and in case there are other modules with the same name in other
folders in <code>sys.path</code>, the one in <code>modulefolder</code> gets
imported.

<p>
Alternative 2 is to specify the folder name in the
<code>PYTHONPATH</code> environment variable. All folder names listed
in <code>PYTHONPATH</code> are automatically included in <code>sys.path</code>
when a Python program starts. On Mac and Linux systems, environment
variables like <code>PYTHONPATH</code> are set in the <code>.bashrc</code> file
in the home folder, typically as

<p>
<!-- begin verbatim block  pycod-->
<pre><code>export PYTHONPATH=$HOME/software/lib/pymodules:$PYTHONPATH
</code></pre>
<!-- end verbatim block -->
if <code>$HOME/software/lib/pymodules</code> is the folder containing
Python modules. On Windows, you launch
<em>Computer - Properties - Advanced System Settings - Environment Variables</em>,
click under <em>System Variable</em>, write in <code>PYTHONPATH</code> as
variable name and the relevant folder(s) as value.

<h3>How to make Python run the module file  <a name="___sec57"></a></h3>

The description above concerns importing the module in a program
located anywhere on the system. If we want to
run the module file as a program, anywhere on the system,
the operating system searches the <code>PATH</code> environment variable
for the program name <code>interst.py</code>. It is therefore necessary
to update <code>PATH</code> with the folder where <code>interest.py</code> resides.

<p>
On Mac and Linux system this is done in <code>.bashrc</code> in the same
way as for <code>PYTHONPATH</code>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>export PYTH=$HOME/software/lib/pymodules:$PATH
</code></pre>
<!-- end verbatim block -->
On Windows, launch the dialog for setting environment variables
as described above and find the <code>PATH</code> variable. It already
has much content, so you add your new folder value either at
the beginning or end, using a semicolon to separate the new
value from the existing ones.

<h2>Distributing modules <a name="sec:input:modules:setuppy"></a></h2>

Modules are usually useful pieces of software that others can take
advantage of. Even though our simple <code>interest</code> module is of less
interest to the world, we can illustrate how such a module is most
effectively distributed to other users. The standard in Python is to
distribute the module file together with a program called <code>setup.py</code>
such that any user can just do

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; sudo python setup.py install
</code></pre>
<!-- end verbatim block -->
to install the module in one of the directories in <code>sys.path</code> so
that the module is immediately accessible anywhere, both for
import in a Python program and for execution as a stand-alone program.

<p>
The <a href="http://tinyurl.com/pwyasaa/input/setup.py" target="_self"><tt>setup.py</tt></a> file is in the case of
one module file very short:

<p>
<!-- begin verbatim block  pypro-->
<pre><code>from distutils.core import setup
setup(name='interest',
      version='1.0',
      py_modules=['interest'],
      scripts=['interest.py'],
      )
</code></pre>
<!-- end verbatim block -->

<p>
The <code>scripts=</code> keyword argument can be dropped if the module is just
to be imported and not run as a program as well.
More module files can trivially be added to the list.

<p>
A user who runs <code>setup.py install</code> on an Ubuntu machine will see from
the output that <code>interest.py</code> is copied to the system
folders <code>/usr/local/lib/python2.7/dist-packages</code> and <code>/usr/local/bin</code>.
The former folder is for module files, the latter for executable
programs.

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Remark.</b>
<p>
Distributing a single module file can be done as shown, but if you
have two or more module files that belong together, you should
definitely create a <em>package</em> <a href="#PySetup:py">[8]</a>.
</div>


<h2>Making software available on the Internet  <a name="___sec59"></a></h2>

Distributing software today means making it available on one of the
major project hosting sites such as Googlecode, GitHub, or Bitbucket.
You will develop and maintain the project files on your own
computer(s), but frequently push the software out in the
cloud such that others also get your updates. The mentioned sites
have is very strong support for collaborative software development.

<p>
Since many already have a Gmail or Google account, we briefly describe
how you can make your software available at Googlecode.

<ol>
<li> Go to <code>http://googlecode.com</code>.</li>
<li> Sign in with your Gmail/Google username and password.</li>
<li> Click on <em>Create a new project</em>.</li>
<li> Fill in project name, summary, and description.</li>
<li> Choose a <em>version control system</em>. Git is recommended.</li>
<li> Select a license for the software. Notice that on Googlecode a
   software project must be available to the whole world as open source code.
   Other sites (Bitbucket and GitHub) allows private projects.</li>
<li> Press <em>Create project</em>.</li>
<li> Click on <em>Source</em> and then on <em>Checkout</em>.</li>
<li> Go to some appropriate place in your home folder tree where you want to
   store this Googlecode project.</li>
<li> Copy and paste the command under <em>Option 1</em> and run it in a
   terminal window (this requires that Git is installed on your system).</li>
</ol>

You now have a folder with the same name as the project name. Copy
<code>setup.py</code> and <code>interst.py</code> to the folder and move to the folder.
It is good to also write a short <code>README</code> file explaining what
the project is about. Alternatively, you can later extend the
description on the Googlecode web page for the project.
Run

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git add .
Terminal&gt; git commit -am 'First registration of project files'
Terminal&gt; git push origin master
</code></pre>
<!-- end verbatim block -->
You are now prompted for the <code>googlecode.com</code> password, which
you can click on right under the <em>Option 1</em> command on the
web page.

<p>
The above <code>git</code> commands look cryptic, but these commands plus
2-3 more are the essence of how programmers today work on
software projects, small or big. I strongly encourage you to
learn more about version control systems and project hosting
sites <a href="#Langtangen_bitgit">[9]</a>. The tools are in nature like Dropbox
and Google Drive, just much more powerful when you collaborate
with others.

<p>
Your project files are now stored in the cloud at
<a href="http://code.google.com/p/project-name" target="_self"><tt>http://code.google.com/p/project-name</tt></a>. Anyone can
get the software by the listed <code>git clone</code> command you used above,
or by clicking on the <code>zip</code> link under <em>Source</em> and <em>Browse</em> to
download a zip file.

<p>
Every time you update the project files, you need to register
the update at the Googlecode project site by

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git commit -am 'Description of the changes you made...'
Terminal&gt; git push origin master
</code></pre>
<!-- end verbatim block -->
The files at Googlecode are now synchronized with your local ones.

<p>
There is a bit more
to be said here to make you up and going with this style of
professional work <a href="#Langtangen_bitgit">[9]</a>, but the information above
gives you at least a glimpse of how to put your software project
in the cloud and opening it up for others.
The Googlecode address for the
particular <code>interest</code> module described above is
<a href="http://code.google.com/p/interest-primer" target="_self"><tt>http://code.google.com/p/interest-primer</tt></a>.

<h1>Summary <a name="sec:input:summary"></a></h1>

<h2>Chapter topics <a name="sec:input:summary:topics"></a></h2>

<h3>Question and answer input  <a name="___sec62"></a></h3>

Prompting the user and reading the answer back into a
variable is done by

<p>
<!-- begin verbatim block  pycod-->
<pre><code>var = raw_input('Give value: ')
</code></pre>
<!-- end verbatim block -->
The <code>raw_input</code> function returns a string containing the
characters that the user wrote on the keyboard before pressing the Return
key. It is necessary to convert <code>var</code> to an appropriate object
(<code>int</code> or <code>float</code>, for instance)
if we want to perform mathematical operations with <code>var</code>.
Sometimes

<p>
<!-- begin verbatim block  pycod-->
<pre><code>var = eval(raw_input('Give value: '))
</code></pre>
<!-- end verbatim block -->
is a flexible and easy way of
transforming the string to the right type of object (integer, real number,
list, tuple, and so on).
This last statement will not work, however, for strings unless the text is
surrounded by quotes when written on the keyboard.
A general conversion function that turns any text without quotes
into the right object is <code>scitools.misc.str2obj</code>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>from scitools.misc import str2obj
var = str2obj(raw_input('Give value: '))
</code></pre>
<!-- end verbatim block -->
Typing, for example, <code>3</code> makes <code>var</code> refer to an <code>int</code> object, <code>3.14</code>
results in a <code>float</code> object, <code>[-1,1]</code> results in a <code>list</code>, <code>(1,3,5,7)</code>
in a <code>tuple</code>, and <code>some text</code> in the string (<code>str</code>) object <code>'some
text'</code> (run the program <a href="http://tinyurl.com/pwyasaa/input/str2obj_demo.py" target="_self"><tt>str2obj_demo.py</tt></a> to see this functionality
demonstrated).

<h3>Getting command-line arguments  <a name="___sec63"></a></h3>

The <code>sys.argv[1:]</code> list contains all the command-line arguments
given to a program (<code>sys.argv[0]</code> contains the program name).
All elements in <code>sys.argv</code> are strings. A typical usage is

<p>
<!-- begin verbatim block  pycod-->
<pre><code>parameter1 = float(sys.argv[1])
parameter2 = int(sys.argv[2])
parameter3 = sys.argv[3]          # parameter3 can be string
</code></pre>
<!-- end verbatim block -->

<h3>Using option-value pairs  <a name="___sec64"></a></h3>

The <code>argparse</code> module is recommended for
interpreting command-line arguments of the form <code>--option value</code>.
A simple recipe with <code>argparse</code> reads

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import argparse
parser = argparse.ArgumentParser()
parser.add_argument('--p1', '--parameter_1', type=float,
                    default=0.0, help='1st parameter')
parser.add_argument('--p2', type=float,
                    default=0.0, help='2nd parameter')

args = parser.parse_args()
p1 = args.p1
p2 = args.p2
</code></pre>
<!-- end verbatim block -->
On the command line we can provide any or all of these options:

<p>
<!-- begin verbatim block  ccq-->
<pre><code>--parameter_1 --p1 --p2
</code></pre>
<!-- end verbatim block -->
where each option must be succeeded by a suitable value.
However, <code>argparse</code> is very flexible can easily handle options
without values or command-line arguments without any
option specifications.

<h3>Generating code on the fly  <a name="___sec65"></a></h3>

Calling <code>eval(s)</code> turns a string <code>s</code>, containing a Python
expression, into code as if the contents of the string were written
directly into the program code. The result of the following
<code>eval</code> call is a <code>float</code> object holding the number 21.1:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; x = 20
&gt;&gt;&gt; r = eval('x + 1.1')
&gt;&gt;&gt; r
21.1
&gt;&gt;&gt; type(r)
&lt;type 'float'&gt;
</code></pre>
<!-- end verbatim block -->
The <code>exec</code> function takes a string with arbitrary Python code
as argument and executes the code. For example, writing

<p>
<!-- begin verbatim block  pycod-->
<pre><code>exec(&quot;&quot;&quot;
def f(x):
    return %s
&quot;&quot;&quot; % sys.argv[1])
</code></pre>
<!-- end verbatim block -->
is the same as if we had hardcoded the (for the programmer unknown)
contents of <code>sys.argv[1]</code>
into a function definition in the program.

<h3>Turning string formulas into Python functions  <a name="___sec66"></a></h3>

Given a mathematical formula as a string, <code>s</code>, we can turn this
formula into a callable Python function <code>f(x)</code> by

<p>
<!-- begin verbatim block  pycod-->
<pre><code>from scitools.std import StringFunction

f = StringFunction(s)
</code></pre>
<!-- end verbatim block -->
The string formula can contain parameters and an independent variable
with another name than <code>x</code>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>Q_formula = 'amplitude*sin(w*t-phaseshift)'
Q = StringFunction(Q_formula, independent_variable='t',
                   amplitude=1.5, w=pi, phaseshift=0)
values1 = [Q(i*0.1) for t in range(10)]
Q.set_parameters(phaseshift=pi/4, amplitude=1)
values2 = [Q(i*0.1) for t in range(10)]
</code></pre>
<!-- end verbatim block -->
Functions of several independent variables are also supported:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>f = StringFunction('x+y**2+A', independent_variables=('x', 'y'),
                   A=0.2)
x = 1; y = 0.5
print f(x, y)
</code></pre>
<!-- end verbatim block -->

<h3>File operations  <a name="___sec67"></a></h3>

Reading from or writing to a file first requires that the file
is opened, either for reading, writing, or appending:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>infile  = open(filename, 'r')   # read
outfile = open(filename, 'w')   # write
outfile = open(filename, 'a')   # append
</code></pre>
<!-- end verbatim block -->
or using <code>with</code>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>with open(filename, 'r') as infile:   # read
with open(filename, 'w') as outfile:  # write
with open(filename, 'a') as outfile:  # append
</code></pre>
<!-- end verbatim block -->
There are four basic reading commands:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>line    = infile.readline()   # read the next line
filestr = infile.read()       # read rest of file into string
lines   = infile.readlines()  # read rest of file into list
for line in infile:           # read rest of file line by line
</code></pre>
<!-- end verbatim block -->
File writing is usually about repeatedly using the command

<p>
<!-- begin verbatim block  pycod-->
<pre><code>outfile.write(s)
</code></pre>
<!-- end verbatim block -->
where <code>s</code> is a string. Contrary to <code>print s</code>,
no newline is added to <code>s</code> in <code>outfile.write(s)</code>.

<p>
After reading or writing is finished, the file must be closed:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>somefile.close()
</code></pre>
<!-- end verbatim block -->
However, closing the file is not necessary if we employ the <code>with</code> statement for
reading or writing files:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>with open(filename, 'w') as outfile:
    for var1, var2 in data:
        outfile.write('%5.2f %g\n' % (var1, var2))
# outfile is closed
</code></pre>
<!-- end verbatim block -->

<h3>Handling exceptions  <a name="___sec68"></a></h3>

Testing for potential errors is done with <code>try-except</code> blocks:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>try:
    &lt;statements&gt;
except ExceptionType1:
    &lt;provide a remedy for ExceptionType1 errors&gt;
except ExceptionType2, ExceptionType3, ExceptionType4:
    &lt;provide a remedy for three other types of errors&gt;
except:
    &lt;provide a remedy for any other errors&gt;
...
</code></pre>
<!-- end verbatim block -->
The most common exception types are
<code>NameError</code> for an undefined variable, <code>TypeError</code> for an
illegal value
in an operation, and <code>IndexError</code> for a list index out of bounds.

<h3>Raising exceptions  <a name="___sec69"></a></h3>

When some error is encountered in a program, the programmer can
raise an exception:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>if z &lt; 0:
    raise ValueError('z=%s is negative - cannot do log(z)' % z)
r = log(z)
</code></pre>
<!-- end verbatim block -->

<h3>Modules  <a name="___sec70"></a></h3>

A module is created by putting a set of functions
in a file. The filename (minus the required extension <code>.py</code>)
is the name of the module.
Other programs can import the module only if it resides in the
same folder or in a folder contained in the <code>sys.path</code>
list (see the section <a href="#sec:input:modules:usage">Using modules</a> for how to
deal with this potential problem).
Optionally, the module file can have a special <code>if</code> construct
at the end, called test block, which tests the module or demonstrates
its usage. The test block does not get executed when the module is
imported in another program, only when the module file is run as
a program.

<h3>Terminology  <a name="___sec71"></a></h3>

The important computer science topics and Python tools in this document are

<ul>
 <li> command line</li>
 <li> <code>sys.argv</code></li>
 <li> <code>raw_input</code></li>
 <li> <code>eval</code> and <code>exec</code></li>
 <li> file reading and writing</li>
 <li> handling and raising exceptions</li>
 <li> module</li>
 <li> test block</li>
</ul>

<h2>Example: Bisection root finding <a name="sec:input:summarizingex"></a></h2>

<h3>Problem  <a name="___sec73"></a></h3>

The summarizing example of this document concerns the implementation
of the Bisection method for solving nonlinear equations of the
form \( f(x)=0 \) with respect to \( x \). For example, the equation

$$
\begin{equation*} x = 1 + \sin x\end{equation*}
$$

can be cast in the form \( f(x)=0 \) if we move all terms to the
left-hand side and define
\( f(x)=x-1-\sin x \). We say that \( x \) is a <em>root</em> of the equation
\( f(x)=0 \) if \( x \) is a solution of this equation. Nonlinear equations
\( f(x)=0 \) can have zero, one, several, or infinitely many roots.

<p>
Numerical methods for computing roots normally lead to approximate
results only, i.e., \( f(x) \) is not made exactly zero, but very close to
zero.  More precisely, an approximate root \( x \) fulfills
\( |f(x)|\leq\epsilon \), where \( \epsilon \) is a small number.  Methods for
finding roots are of an iterative nature: we start with a rough
approximation to a root and perform a repetitive set of steps that aim
to improve the approximation.  Our particular method for computing
roots, the Bisection method, guarantees to find an
approximate root, while other methods, such as the widely used
Newton's
method (see the section ref{sec:diffeq:Newtonsmethod:sec}),
can fail to find roots.

<p>
The idea of the Bisection method is to start with an interval \( [a,b] \)
that contains a root of \( f(x) \). The interval is halved at \( m=(a+b)/2 \),
and if \( f(x) \)
changes sign in the left half interval \( [a,m] \), one continues with that
interval, otherwise one continues with the right half interval \( [m,b] \).
This procedure is repeated, say \( n \) times, and the root is then
guaranteed to be inside an interval of length \( 2^{-n}(b-a) \).
The task is to write a program that implements the Bisection method
and verify the implementation.

<h3>Solution  <a name="___sec74"></a></h3>

To implement the Bisection method, we need to translate the description in
the previous paragraph to a precise algorithm that can be almost directly
translated to computer code. Since the halving of the interval is
repeated many times, it is natural to do this inside a loop. We
start with the interval \( [a,b] \), and adjust \( a \) to \( m \) if the root must
be in the right half of the interval, or we adjust \( b \) to \( m \) if the
root must be in the left half. In a language close to computer code
we can express the algorithm precisely as follows:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>for i = 0,1,2, ..., n:
    m = (a + b)/2
    if f(a)*f(m) &lt;= 0:
        b = m  # root is in left half
    else:
        a = m  # root is in right half

# f(x) has a root in [a,b]
</code></pre>
<!-- end verbatim block -->

<p>
Figure <a href="#fig:plot:bisection:iter">2</a> displays graphically
the first four steps of
this algorithm for solving the equation \( \cos (\pi x)=0 \), starting
with the interval \( [0, 0.82] \). The graphs are automatically produced
by the program <code>bisection_movie.py</code>, which was run as follows
for this particular example:

<p>
<!-- begin verbatim block  sys-->
<pre><code>bisection_movie.py 'cos(pi*x)' 0 0.82
</code></pre>
<!-- end verbatim block -->
The first command-line argument is the formula for \( f(x) \), the next is
\( a \), and the final is \( b \).

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 2:  Illustration of the first four iterations of the Bisection algorithm for solving \( \cos (\pi x) =0 \). The vertical lines correspond to the current value of \( a \) and \( b \). <a name="fig:plot:bisection:iter"></a> </p></center>
<p><img src="fig-input/bisection_iter.png" align="bottom" width=400></p>
</center>

<p>
In the algorithm listed above,
we recompute \( f(a) \) in each <code>if</code>-test, but this is
not necessary if \( a \) has not changed since the last \( f(a) \) computations.
It is a good habit in numerical programming to avoid
redundant work.
On modern computers the Bisection algorithm normally runs so fast that
we can afford to do more work than necessary. However, if \( f(x) \) is not
a simple formula, but computed by comprehensive calculations in a
program, the evaluation of \( f \) might take minutes or even hours, and
reducing the number of evaluations in the Bisection algorithm is then
very important. We will therefore introduce extra variables in the
algorithm above to save an \( f(m) \) evaluation in each iteration in the
<code>for</code> loop:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>f_a = f(a)
for i = 0,1,2, ..., n:
    m = (a + b)/2
    f_m = f(m)
    if f_a*f_m &lt;= 0:
        b = m   # root is in left half
    else:
        a = m   # root is in right half
        f_a = f_m

# f(x) has a root in [a,b]
</code></pre>
<!-- end verbatim block -->

<p>
To execute the algorithm above, we need to specify \( n \). Say we want
to be sure that the root lies in an interval of maximum extent \( \epsilon \).
After \( n \) iterations the length of our current interval is
\( 2^{-n}(b-a) \), if \( [a,b] \) is the initial interval. The current interval
is sufficiently small if

$$
\begin{equation*} 2^{-n}(b-a) = \epsilon,\end{equation*}
$$

which implies

$$
\begin{equation} n = - {\ln\epsilon -\ln (b-a)\over\ln 2}\tp\end{equation}
$$


<p>
Instead of calculating this \( n \), we may simply stop the iterations when
the length of the current interval is less than \( \epsilon \). The loop
is then naturally implemented as a <code>while</code> loop testing on
whether \( b-a \leq\epsilon \). To make the algorithm more foolproof,
we also insert a test to ensure that \( f(x) \) really changes sign
in the initial interval. This guarantees a root
in \( [a,b] \). (However, \( f(a)f(b) < 0 \) is not a necessary condition
if there is an even number of roots in the initial interval.)

<p>
Our final version of the Bisection algorithm now becomes

<p>
<!-- begin verbatim block  pycod-->
<pre><code>f_a=f(a)
if f_a*f(b) &gt; 0:
    # error: f does not change sign in [a,b]

i = 0
while b-a &gt; epsilon:
    i = i + 1
    m = (a + b)/2
    f_m = f(m)
    if f_a*f_m &lt;= 0:
        b = m  # root is in left half
    else:
        a = m  # root is in right half
        f_a = f_m

# if x is the real root, |x-m| &lt; epsilon
</code></pre>
<!-- end verbatim block -->
This is the algorithm we aim to implement in a Python program.

<p>
<!-- === A Simple Program === -->

<p>
A direct translation of the previous algorithm to a valid
Python program is a matter of some minor edits:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>eps = 1E-5
a, b = 0, 10

fa = f(a)
if fa*f(b) &gt; 0:
    print 'f(x) does not change sign in [%g,%g].' % (a, b)
    sys.exit(1)

i = 0   # iteration counter
while b-a &gt; eps:
    i += 1
    m = (a + b)/2.0
    fm = f(m)
    if fa*fm &lt;= 0:
        b = m  # root is in left half of [a,b]
    else:
        a = m  # root is in right half of [a,b]
        fa = fm
    print 'Iteration %d: interval=[%g, %g]' % (i, a, b)
    
x = m          # this is the approximate root
print 'The root is', x, 'found in', i, 'iterations'
print 'f(%g)=%g' % (x, f(x))
</code></pre>
<!-- end verbatim block -->
This program is found in the file
<a href="http://tinyurl.com/pwyasaa/input/bisection_v1.py" target="_self"><tt>bisection_v1.py</tt></a>.

<h3>Verification  <a name="___sec75"></a></h3>

To verify the implementation in <code>bisection_v1.py</code> we choose a very
simple \( f(x) \) where we know the exact root. One suitable example is a linear
function, \( f(x)=2x-3 \) such that \( x=3/2 \)
is the root of \( f \). As can be seen from the source code above,
we have inserted a <code>print</code> statement inside the
<code>while</code> loop to control that the program really does the right
things.
Running the program yields the output

<p>
<!-- begin verbatim block  ccq-->
<pre><code>Iteration 1: interval=[0, 5]
Iteration 2: interval=[0, 2.5]
Iteration 3: interval=[1.25, 2.5]
Iteration 4: interval=[1.25, 1.875]
...
Iteration 19: interval=[1.5, 1.50002]
Iteration 20: interval=[1.5, 1.50001]
The root is 1.50000572205 found in 20 iterations
f(1.50001)=1.14441e-05
</code></pre>
<!-- end verbatim block -->
It seems that the implementation works. Further checks should include
hand calculations for the first (say) three iterations and comparison
of the results with the program.

<h3>Making a function  <a name="___sec76"></a></h3>

The previous implementation of the bisection algorithm is fine for
many purposes. To solve a new problem \( f(x)=0 \) it is just necessary
to change the <code>f(x)</code> function in the program. However, if we
encounter solving \( f(x)=0 \) in another program in another context,
we must put the bisection algorithm into that program in the right
place. This is simple in practice, but it requires some careful work,
and it is easy to make errors. The task of solving \( f(x)=0 \) by
the bisection algorithm is much simpler and safer if we have that
algorithm available as a function in a module. Then we can just
import the function and call it. This requires a minimum of writing
in later programs.

<p>
When you have a &quot;flat&quot; program as shown above, without basic steps
in the program collected in functions, you should always consider
dividing the code into functions. The reason is that parts of the
program will be much easier to reuse in other programs.
You save coding, and that is a good rule! A program with functions
is also easier to understand, because statements are collected into
logical, separate units, which is another good rule! In a mathematical
context, functions are particularly important since they naturally
split the code into general algorithms (like the bisection algorithm)
and a problem-specific part (like a special choice of \( f(x) \)).

<p>
Shuffling statements in a program around to form a new and better
designed version of the program is called <em>refactoring</em>.
We shall now refactor the <code>bisection_v1.py</code> program by putting
the statements in the bisection algorithm in a function
<code>bisection</code>. This function naturally takes \( f(x) \), \( a \), \( b \), and
\( \epsilon \) as parameters and returns the found root, perhaps together
with the number of iterations required:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def bisection(f, a, b, eps):
    fa = f(a)
    if fa*f(b) &gt; 0:
        return None, 0

    i = 0   # iteration counter
    while b-a &gt; eps:
        i += 1
        m = (a + b)/2.0
        fm = f(m)
        if fa*fm &lt;= 0:
            b = m  # root is in left half of [a,b]
        else:
            a = m  # root is in right half of [a,b]
            fa = fm
    return m, i
</code></pre>
<!-- end verbatim block -->
After this function we can have a test program:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def f(x):
    return 2*x - 3   # one root x=1.5

x, iter = bisection(f, a=0, b=10, eps=1E-5)
if x is None:
    print 'f(x) does not change sign in [%g,%g].' % (a, b)
else:
    print 'The root is', x, 'found in', iter, 'iterations'
    print 'f(%g)=%g' % (x, f(x))
</code></pre>
<!-- end verbatim block -->
The complete code is found in file
<a href="http://tinyurl.com/pwyasaa/input/bisection_v2.py" target="_self"><tt>bisection_v2.py</tt></a>.

<h3>Making a test function  <a name="___sec77"></a></h3>

Rather than having a main program as above for verifying the
implementation, we should make a test function <code>test_bisection</code> as
described in the section <a href="#sec:input:modules:testfunc">Verification of the module code</a>. To this end, we
move the statements above inside a function, drop the output, but
instead make a boolean variable <code>success</code> that is <code>True</code> if the test
is passed and <code>False</code> otherwise. Then we do <code>assert success, msg</code>,
which will abort the program if the test fails. The <code>msg</code> variable is
a string with more explanation of what went wrong the test fails.
A test function with this structure is easy to integrate
into the widely used testing frameworks nose and pytest, and there are no good
reasons for not adopting this structure.  The code checking that
the root is within a distance \( \epsilon \) to the exact root becomes

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def test_bisection():
    def f(x):
        return 2*x - 3   # one root x=1.5

    x, iter = bisection(f, a=0, b=10, eps=1E-5)
    success = abs(x - 1.5) &lt; 1E-5  # test within eps tolerance
    assert success, 'found x=%g != 1.5' % x
</code></pre>
<!-- end verbatim block -->

<h3>Making a module  <a name="___sec78"></a></h3>

A motivating factor for implementing the bisection algorithm as a function
<code>bisection</code> was that we could import this function in other
programs to solve \( f(x)=0 \) equations. We therefore need to make a module
file <code>bisection.py</code> such that we can do, e.g.,

<p>
<!-- begin verbatim block  pycod-->
<pre><code>from bisection import bisection
x, iter = bisection(lambda x: x**3 + 2*x -1, -10, 10, 1E-5)
</code></pre>
<!-- end verbatim block -->
A module file should not execute a main program, but just
define functions, import modules, and define global variables.
Any execution of a main program must take place in the test
block, otherwise the <code>import</code> statement will start executing
the main program, resulting in very
disturbing statements for another program that
wants to solve a different \( f(x)=0 \) equation.

<p>
The <code>bisection_v2.py</code> file had a main program that was just a
simple test for checking that the <code>bisection</code> algorithm works
for a linear function. We took this main program and wrapped
in a test function <code>test_bisection</code> above. To run the test,
we make the call to this function from the test block:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>if __name__ == '__main__':
    test_bisection()
</code></pre>
<!-- end verbatim block -->
This is all that is demanded to turn the file <code>bisection_v2.py</code>
into a proper module file <code>bisection.py</code>.

<h3>Defining a user interface  <a name="___sec79"></a></h3>

It is nice to have our <code>bisection</code> module do more than just test
itself: there should be a user interface such that we can
solve real problems \( f(x)=0 \), where \( f(x) \), \( a \), \( b \), and \( \epsilon \)
are defined on the command line by the user. A dedicated function
can read from the command line and return the data as Python
object. For reading the function \( f(x) \) we can either apply
<code>eval</code> on the command-line argument, or use the more sophisticated
<code>StringFunction</code> tool from the section <a href="#sec:input:StringFunction">Turning string expressions into functions</a>.
With <code>eval</code> we need to import functions from the <code>math</code> module in
case the user have such functions in the expression for \( f(x) \).
With <code>StringFunction</code> this is not necessary.

<p>
A <code>get_input()</code> for getting input from the command line can be
implemented as

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def get_input():
    &quot;&quot;&quot;Get f, a, b, eps from the command line.&quot;&quot;&quot;
    from scitools.std import StringFunction
    try:
        f = StringFunction(sys.argv[1])
        a = float(sys.argv[2])
        b = float(sys.argv[3])
        eps = float(sys.argv[4])
    except IndexError:
        print 'Usage %s: f a b eps' % sys.argv[0]
        sys.exit(1)
    return f, a, b, eps
</code></pre>
<!-- end verbatim block -->
To solve the corresponding \( f(x)=0 \) problem, we simply add a branch
in the <code>if</code> test in the test block:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>if __name__ == '__main__':
    import sys
    if len(sys.argv) &gt;= 2 and sys.argv[1] == 'test':
        test_bisection()
    else:
        f, a, b, eps = get_input()
        x, iter = bisection(f, a, b, eps)
        print 'Found root x=%g in %d iterations' % (x, iter)
</code></pre>
<!-- end verbatim block -->

<p>
<div class="alert alert-block alert-summary alert-text-normal">
<b>Desired properties of a module.</b>
<p>
Our <a href="http://tinyurl.com/pwyasaa/input/bisection.py" target="_self"><tt>bisection.py</tt></a> code is
a complete module file with the following generally desired features
of Python modules:

<ul>
 <li> other programs can import the <code>bisection</code> function,</li>
 <li> the module can test itself (with a pytest/nose-compatible test function),</li>
 <li> the module file can be run as a program with a user interface
   where a general rooting finding problem can be specified in
   terms of a formula for \( f(x) \) along with the parameters \( a \), \( b \),
   and \( \epsilon \).</li>
</ul>
</div>


<h3>Using the module  <a name="___sec80"></a></h3>

Suppose you want to solve \( x/(x-1)=\sin x \) using the <code>bisection</code> module.
What do you have to do? First, you must reformulate the equation as
\( f(x)=0 \), i.e., \( x/(x-1)-\sin x = 0 \), or maybe multiply by
\( x-1 \) to get \( f(x)=x-(x-1)\sin x \).

<p>
It is required to identify an interval for the root. By evaluating \( f(x) \)
for some points \( x \) one can be trial and error locate an interval.
A more convenient approach is to plot
the function \( f(x) \) and visually inspect where a root is.
The chapter ref{ch:plot} describes the techniques, but here we simply
state the recipe.
We start <code>ipython --pylab</code> and write
<!-- begin verbatim block  ipy-->
<pre><code>In [1]: x = linspace(-3, 3, 50)  # generate 50 coordinates in [-3,3]

In [2]: y = x - (x-1)*sin(x)

In [3]: plot(x, y)
</code></pre>
<!-- end verbatim block -->
Figure <a href="#fig:plot:bisection:xsinx">3</a> shows \( f(x) \) and we clearly see
that, e.g., \( [-2, 1] \) is an appropriate interval.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 3:  Plot of \( f(x)=x - \sin (x) \). <a name="fig:plot:bisection:xsinx"></a> </p></center>
<p><img src="fig-input/f_x_xm1sinx.png" align="bottom" width=500></p>
</center>

<p>
The next step is to run the Bisection algorithm.
There are two possibilities:

<ul>
 <li> make a program where you code \( f(x) \) and run the <code>bisection</code> function, or</li>
 <li> run the <code>bisection.py</code> program directly.</li>
</ul>

The latter approach is the simplest:

<p>
<!-- begin verbatim block  sys-->
<pre><code>bisection.py &quot;x - (x-1)*sin(x)&quot; -2 1 1E-5
Found root x=-1.90735e-06 in 19 iterations
</code></pre>
<!-- end verbatim block -->

<p>
The alternative approach is to make a program:

<p>
<!-- begin verbatim block  pypro-->
<pre><code>from bisection import bisection
from math import sin

def f(x):
    return x - (x-1)*sin(x)

x, iter = bisection(f, a=-2, b=1, eps=1E-5)
print x, iter
</code></pre>
<!-- end verbatim block -->

<h3>Potential problems with the software  <a name="___sec81"></a></h3>

Let us solve

<ul>
  <li> \( x = \tanh x \) with start interval \( [-10,10] \) and \( \epsilon=10^{-6} \),</li>
  <li> \( x^5 = \tanh (x^5) \) with start interval \( [-10,10] \) and \( \epsilon=10^{-6} \).</li>
</ul>

Both equations have one root \( x=0 \).

<p>
<!-- begin verbatim block  sys-->
<pre><code>bisection.py &quot;x-tanh(x)&quot; -10 10
Found root x=-5.96046e-07 in 25 iterations

bisection.py &quot;x**5-tanh(x**5)&quot; -10 10
Found root x=-0.0266892 in 25 iterations
</code></pre>
<!-- end verbatim block -->
These results look strange. In both cases we halve the start
interval \( [-10,10] \) 25 times, but in the second case we end
up with a much less accurate root although the value of \( \epsilon \)
is the same. A closer inspection of what goes on in the bisection
algorithm reveals that the inaccuracy is caused by round-off
errors. As \( a, b, m\rightarrow 0 \), raising a small number to the
fifth power in the expression for \( f(x) \) yields a much smaller result.
Subtracting a very small number \( \tanh x^5 \) from another
very small number \( x^5 \) may result in a small number with wrong
sign, and the sign of \( f \) is essential in the bisection algorithm.
We encourage the reader to graphically inspect this behavior by
running these two examples with the
<a href="http://tinyurl.com/pwyasaa/input/bisection_plot.py" target="_self"><tt>bisection_plot.py</tt></a> program
using a smaller interval \( [-1,1] \) to better see what is going on.
The command-line arguments for the <code>bisection_plot.py</code> program
are <code>'x-tanh(x)' -1 1</code> and <code>'x**5-tanh(x**5)' -1 1</code>.
The very flat area, in the latter case, where \( f(x)\approx 0 \) for
\( x\in [-1/2, 1/2] \) illustrates
well that it is difficult to locate an exact root.

<h3>Distributing the bisection module to others  <a name="___sec82"></a></h3>

The Python standard for installing software is to run a <code>setup.py</code> program,

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; sudo python setup.py install
</code></pre>
<!-- end verbatim block -->
to install the system. The relevant <code>setup.py</code> for the <code>bisection</code>
module arises from substituting the name <code>interest</code> by <code>bisection</code>
in the <code>setup.py</code> file listed in
the section <a href="#sec:input:modules:setuppy">Distributing modules</a>. You can then distribute
<code>bisection.py</code> and <code>setup.py</code> together.

<h1>Exercises  <a name="___sec83"></a></h1>

<!-- --- begin exercise --- -->

<h2>Exercise 1: Make an interactive program <a name="sec:input:ex24"></a></h2>

Make a program that asks the user for a temperature
in Fahrenheit degrees and reads the number; computes the corresponding
temperature in Celsius degrees; and prints out the temperature
in the Celsius scale.
Filename: <code>f2c_qa.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 2: Read a number from the command line <a name="sec:input:ex24b"></a></h2>

Modify the program from <a href="#sec:input:ex24">Exercise 1: Make an interactive program</a> such that
the Fahrenheit temperature is read from the command line.
Filename: <code>f2c_cml.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 3: Read a number from a file <a name="sec:input:ex24bfile"></a></h2>

Modify the program from <a href="#sec:input:ex24">Exercise 1: Make an interactive program</a> such that
the Fahrenheit temperature is read from a file with the following
content:

<p>
<!-- begin verbatim block  dat-->
<pre><code>Temperature data
----------------

Fahrenheit degrees: 67.2
</code></pre>
<!-- end verbatim block -->

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Create a sample file manually. In the program,
skip the first three lines, split the fourth line into words and
grab the third word.

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>f2c_file_read.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 4: Read and write several numbers from and to file <a name="sec:input:ex24bfile2"></a></h2>

This is a variant of <a href="#sec:input:ex24bfile">Exercise 3: Read a number from a file</a> where
we have several Fahrenheit degrees in a file and want to read
all of them into a list and convert the numbers to Celsius
degrees. Thereafter, we want to write out a file with
two columns, the left with the Fahrenheit degrees and the
right with the Celsius degrees.

<p>
An example on the input file format looks like

<p>
<!-- begin verbatim block  dat-->
<pre><code>Temperature data
----------------

Fahrenheit degrees: 67.2
Fahrenheit degrees: 66.0
Fahrenheit degrees: 78.9
Fahrenheit degrees: 102.1
Fahrenheit degrees: 32.0
Fahrenheit degrees: 87.8
</code></pre>
<!-- end verbatim block -->
A sample file
is <a href="http://tinyurl.com/pwyasaa/input/Fdeg.dat" target="_self"><tt>Fdeg.dat</tt></a>.
Filename: <code>f2c_file_read_write.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 5: Use exceptions to handle wrong input <a name="sec:input:ex24c"></a></h2>

Extend the program from <a href="#sec:input:ex24b">Exercise 2: Read a number from the command line</a> with a
<code>try-except</code> block to handle the potential error that the
Fahrenheit temperature is missing on the command line.
Filename: <code>f2c_cml_exc.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 6: Read input from the keyboard <a name="sec:input:ex25"></a></h2>

Make a program that asks for input from the user, applies
<code>eval</code> to this input, and prints out the type of the resulting
object and its value. Test the program by providing five
types of input: an integer, a real number, a complex number,
a list, and a tuple.
Filename: <code>objects_qa.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 7: Read input from the command line <a name="sec:input:ex26"></a></h2>

<b>a)</b>
Let a program store the result of applying
the <code>eval</code> function to the first command-line
argument. Print out the resulting object and its type.

<p>
<b>b)</b>
Run the program with different input: an integer,
a real number, a list, and a tuple.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
On Unix systems
you need to surround the
tuple expressions in quotes on the command line to avoid error message
from the Unix shell.

<p>
<!-- --- end hint in exercise --- -->

<p>
<b>c)</b>
Try the string
<code>"this is a string"</code> as a command-line argument. Why does this string
cause problems and what is the remedy?

<p>
Filename: <code>objects_cml.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 8: Try MSWord or LibreOffice to write a program <a name="sec:files:ex7"></a></h2>

The purpose of this exercise is to tell you how hard it may be to
write Python programs in the standard programs that most people
use for writing text.

<p>
<b>a)</b>
Type the following one-line program in either MSWord or
LibreOffice:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>print &quot;Hello, World!&quot;
</code></pre>
<!-- end verbatim block -->
Both Word and LibreOffice are so &quot;smart&quot; that they
automatically edit &quot;print&quot; to &quot;Print&quot; since a sentence should
always start with a capital. This is just an example that
word processors are made for writing documents,
not computer programs.

<p>
<b>b)</b>
Save the program as a <code>.docx</code> (Word) or <code>.odt</code> (LibreOffice) file.
Now try to run this file as a Python program. What kind of error
message do you get? Can you explain why?

<p>
<b>c)</b>
Save the program as a <code>.txt</code> file in Word or LibreOffice and
run the file as a Python program. What happened now?
Try to find out what the problem is.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 9: Prompt the user for input to a formula <a name="sec:input:ex6"></a></h2>

Consider the simplest program for evaluating the formula
\( y(t)=v_0t - \frac{1}{2}gt^2 \):

<p>
<!-- begin verbatim block  pypro-->
<pre><code>v0 = 3; g = 9.81; t = 0.6
y = v0*t - 0.5*g*t**2
print y
</code></pre>
<!-- end verbatim block -->
Modify this code so that
the program asks the user questions <code>t=?</code> and <code>v0=?</code>, and then
gets <code>t</code> and <code>v0</code> from the user's input through the keyboard.
Filename: <code>ball_qa.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 10: Read parameters in a formula from the command line <a name="sec:input:ex5"></a></h2>

Modify the program listed in <a href="#sec:input:ex6">Exercise 9: Prompt the user for input to a formula</a> such that
<code>v0</code> and <code>t</code> are read from the command line.
Filename: <code>ball_cml.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 11: Use exceptions to handle wrong input <a name="sec:input:ex8b"></a></h2>

The program from <a href="#sec:input:ex5">Exercise 10: Read parameters in a formula from the command line</a> reads input from the
command line. Extend that program with exception handling such that
missing command-line arguments are detected. In the <code>except IndexError</code>
block, use the <code>raw_input</code> function to ask the user for missing input
data.
Filename: <code>ball_cml_qa.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 12: Test validity of input data <a name="sec:input:ex7"></a></h2>

Test if the <code>t</code> value read in the program from
<a href="#sec:input:ex5">Exercise 10: Read parameters in a formula from the command line</a> lies between \( 0 \) and \( 2v_0/g \).
If not, print a message and abort the execution.
Filename: <code>ball_cml_tcheck.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 13: Raise an exception in case of wrong input <a name="sec:input:ex8"></a></h2>

Instead of printing an error message and aborting the program explicitly,
raise a <code>ValueError</code> exception in the <code>if</code> test on legal
<code>t</code> values in
the program from <a href="#sec:input:ex7">Exercise 12: Test validity of input data</a>.
Notify the user about the legal interval for \( t \) in the exception message.
Filename: <code>ball_cml_ValueError.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 14: Evaluate a formula for data in a file <a name="sec:input:ex:ball:file"></a></h2>

We consider the formula \( y(t)=v_0t - 0.5gt^2 \) and want to evaluate \( y \) for
a range of \( t \) values found in a file with format

<p>
<!-- begin verbatim block  dat-->
<pre><code>v0: 3.00
t:
0.15592  0.28075   0.36807889 0.35 0.57681501876
0.21342619  0.0519085  0.042  0.27  0.50620017 0.528
0.2094294  0.1117  0.53012  0.3729850  0.39325246
0.21385894  0.3464815 0.57982969 0.10262264
0.29584013  0.17383923
</code></pre>
<!-- end verbatim block -->
More precisely, the first two lines are always present, while the next
lines contain an arbitrary number of \( t \) values on each line, separated
by one or more spaces.

<p>
<b>a)</b>
Write a function that reads the input file and returns \( v_0 \) and
a list with the \( t \) values.

<p>
<b>b)</b>
Write a function that creates a file with two nicely formatted
columns containing the \( t \)
values to the left and the corresponding \( y \) values to the right.
Let the \( t \) values appear in increasing order (note that the
input file does not necessarily have the \( t \) values sorted).

<p>
<b>c)</b>
Make a test function that generates an input file, calls the
function for reading the file, and checks that the returned
data objects are correct.

<p>
Filename: <code>ball_file_read_write.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 15: Compute the distance it takes to stop a car <a name="sec:input:ex21"></a></h2>

A car driver, driving at velocity \( v_0 \), suddenly puts on the brake.
What braking distance \( d \) is needed to stop the car?
One can derive, using Newton's second law of motion or
a corresponding energy equation, that

$$
\begin{equation}
d = \frac{1}{2}{v_0^2\over \mu g}\tp
\tag{5}
\end{equation}
$$


<p>
Make a program for computing \( d \) in <a href="#mjx-eqn-5">(5)</a>
when the initial car velocity \( v_0 \) and
the friction coefficient \( \mu \) are given on the command line.
Run the program for two cases: \( v_0=120 \) and \( v_0=50 \) km/h, both
with \( \mu=0.3 \)
(\( \mu \) is dimensionless).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Remember to convert the velocity from km/h to m/s before inserting the
value in the formula.

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>stopping_length.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 16: Look up calendar functionality <a name="sec:input:ex48"></a></h2>

The purpose of this exercise is to make a program that takes a date,
consisting of year (4 digits), month (2 digits), and day (1-31) on the
command line and prints the corresponding name of the weekday (Monday,
Tuesday, etc.).  Python has a module <code>calendar</code>, which makes it easy
to solve the exercise, but the task is to find out how to use this
module.
Filename: <code>weekday.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 17: Use the StringFunction tool <a name="sec:input:ex28b"></a></h2>

Make the program <code>user_formula.py</code> from the section <a href="#sec:input:exec">The magic exec function</a>
shorter by using the convenient <code>StringFunction</code> tool from
the section <a href="#sec:input:StringFunction">Turning string expressions into functions</a>.
Filename: <code>user_formula2.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 18: Why we test for specific exception types <a name="sec:input:ex11"></a></h2>

The simplest way of writing a <code>try-except</code> block is to test
for <em>any</em> exception, for example,

<p>
<!-- begin verbatim block  pycod-->
<pre><code>try:
    C = float(sys.arg[1])
except:
    print 'C must be provided as command-line argument'
    sys.exit(1)
</code></pre>
<!-- end verbatim block -->
Write the above statements in a program and test the program. What is
the problem?

<p>
The fact that a user can forget to supply a command-line argument when
running the program was the
original reason for using a <code>try</code> block. Find out what kind of
exception that is relevant for this error and test for this specific
exception and re-run the program. What is the problem now?
Correct the program.
Filename: <code>unnamed_exception.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 19: Make a complete module <a name="sec:input:ex27"></a></h2>

<b>a)</b>
Make six conversion functions between temperatures in Celsius, Kelvin,
and Fahrenheit: <code>C2F</code>, <code>F2C</code>, <code>C2K</code>, <code>K2C</code>, <code>F2K</code>,
and <code>K2F</code>.

<p>
<b>b)</b>
Collect these functions in a module <code>convert_temp</code>.

<p>
<b>c)</b>
Import the module in an interactive Python shell and
demonstrate some sample calls on temperature conversions.

<p>
<b>d)</b>
Insert the session from c) in a triple quoted string at the top of
the module file as a doc string for demonstrating the usage.

<p>
<b>e)</b>
Write a function <code>test_conversion()</code> that verifies the implementation.
Call this function from the test block if the first command-line
argument is <code>verify</code>.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Check that <code>C2F(F2C(f))</code> is <code>f</code>, <code>K2C(C2K(c))</code> is <code>c</code>, and
<code>K2F(F2K(f))</code> is <code>f</code> - with tolerance. Follow the conventions
for test functions outlined in the sections <a href="#sec:input:modules:testfunc">Verification of the module code</a>
and <a href="#sec:input:summarizingex">Example: Bisection root finding</a> with a boolean variable that
is <code>False</code> if a test failed, and <code>True</code> if all test are passed, and
then an <code>assert</code> statement to abort the program  when any test fails.

<p>
<!-- --- end hint in exercise --- -->

<p>
<b>f)</b>
Add a user interface to the module such that the user can write a
temperature as the first command-line argument and the corresponding
temperature scale as the second command-line argument, and then get
the temperature in the two other scales as output.  For example, <code>21.3
C</code> on the command line results in the output <code>70.3 F 294.4 K</code>.
Encapsulate the user interface in a function, which is called from the
test block.

<p>
Filename: <code>convert_temp.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 20: Make a module <a name="sec:input:ex17"></a></h2>

Collect the <code>f</code> and <code>S</code> functions in the program from
ref{sec:formula:ex10}
in a separate file such that this file becomes a module.
Put the statements making the table (i.e., the
main program from ref{sec:formula:ex10})
in a separate function <code>table(n_values, alpha_values, T)</code>.
Make a test block in the module to read
\( T \) and a series of \( n \) and \( \alpha \) values from the command line
and make a corresponding call to <code>table</code>.
Filename: <code>sinesum2.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 21: Read options and values from the command line <a name="sec:input:ex19"></a></h2>

Let the input to the program in <a href="#sec:input:ex17">Exercise 20: Make a module</a> be
option-value pairs with the options
<code>--n</code>, <code>--alpha</code>, and <code>--T</code>. Provide sensible default values
in the module file.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Apply the <code>argparse</code> module to read the command-line arguments.
Do not copy code from the <code>sinesum2</code> module, but make a new file
for reading option-value pairs from the command and import the
<code>table</code> function from the <code>sinesum2</code> module.

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>sinesum3.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 22: Check if mathematical identities hold <a name="sec:input:ex2"></a></h2>

Because of round-off errors, it could happen that a mathematical rule
like \( (ab)^3 = a^3b^3 \) does not hold exactly on a computer.
The idea of testing this potential problem
is to check such identities for a large number of
random numbers. We can make random numbers using the <code>random</code> module
in Python:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import random
a = random.uniform(A, B)
b = random.uniform(A, B)
</code></pre>
<!-- end verbatim block -->
Here, <code>a</code> and <code>b</code>
will be random numbers, which are always larger than or equal to <code>A</code>
and smaller than <code>B</code>.

<p>
<b>a)</b>
Make a function <code>power3_identity(A=-100, B=100, n=1000)</code>
that tests the identity <code>(a*b)**3 == a**3*b**3</code> a large number
of times, <code>n</code>. Return the fraction of failures.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Inside the loop over <code>n</code>, draw
random numbers <code>a</code> and <code>b</code> as described above and count the
number of times the test is <code>True</code>.

<p>
<!-- --- end hint in exercise --- -->

<p>
<b>b)</b>
We shall now parameterize the expressions to be tested.
Make a function

<p>
<!-- begin verbatim block  ccq-->
<pre><code>equal(expr1, expr2, A=-100, B=100, n=500)
</code></pre>
<!-- end verbatim block -->
where <code>expr1</code> and <code>expr2</code> are strings containing the two
mathematical expressions to be tested. More precisely, the
function draws random numbers <code>a</code> and <code>b</code> between <code>A</code> and <code>B</code>
and tests if <code>eval(expr1) == eval(expr2)</code>.
Return the fraction of failures.

<p>
Test the function on the identities \( (ab)^3 = a^3b^3 \),
\( e^{a+b}=e^ae^b \), and \( \ln a^b = b\ln a \).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Make the <code>equal</code> function robust enough to handle illegal \( a \) and
\( b \) values in the mathematical expressions (e.g., \( a\leq 0 \) in
\( \ln a \)).

<p>
<!-- --- end hint in exercise --- -->

<p>
<b>c)</b>
We want to test the validity of the following set of identities
on a computer:

<ul>
  <li> \( a-b \) and \( -(b-a) \)</li>
  <li> \( a/b \) and \( 1/(b/a) \)</li>
  <li> \( (ab)^4 \) and \( a^4b^4 \)</li>
  <li> \( (a+b)^2 \) and \( a^2 + 2ab + b^2 \)</li>
  <li> \( (a+b)(a-b) \) and \( a^2 - b^2 \)</li>
  <li> \( e^{a+b} \) and \( e^ae^b \)</li>
  <li> \( \ln a^b \) and \( b\ln a \)</li>
  <li> \( \ln ab \) and \( \ln a + \ln b \)</li>
  <li> \( ab \) and \( e^{\ln a + \ln b} \)</li>
  <li> \( 1/(1/a + 1/b) \) and \( ab/(a+b) \)</li>
  <li> \( a(\sin^2 b + \cos^2 b) \) and \( a \)</li>
  <li> \( \sinh (a+b) \) and \( (e^ae^b - e^{-a}e^{-b})/2 \)</li>
  <li> \( \tan (a+b) \) and \( \sin (a+b)/\cos(a+b) \)</li>
  <li> \( \sin (a+b) \) and \( \sin a\cos b + \sin b\cos a \)</li>
</ul>

Store all the expressions in a list of 2-tuples, where each 2-tuple
contains two mathematically equivalent expressions as strings, which
can be sent to the <code>equal</code> function.  Make a nicely formatted table
with a pair of equivalent expressions at each line followed by the
failure rate. Write this table to a file.  Try out <code>A=1</code> and <code>B=2</code> as
well as <code>A=1</code> and <code>B=100</code>.  Does the failure rate seem to depend on
the magnitude of the numbers \( a \) and \( b \)?

<p>
Filename: <code>math_identities_failures.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 23: Compute probabilities with the binomial distribution <a name="sec:input:ex15"></a></h2>

Consider an uncertain event where there are two outcomes only,
typically success or failure. Flipping a coin is an example: the
outcome is uncertain and of two types, either head (can be considered
as success) or tail (failure).  Throwing a die can be another example,
if (e.g.) getting a six is considered success and all other outcomes
represent failure. Such experiments are called <em>Bernoulli trials</em>.

<p>
Let the probability of success be \( p \) and that of failure \( 1-p \).  If
we perform \( n \) experiments, where the outcome of each experiment does
not depend on the outcome of previous experiments, the probability of
getting success \( x \) times, and consequently failure \( n-x \) times, is given by

$$
\begin{equation}
B(x,n,p) = {n!\over x! (n-x)!} p^x(1-p)^{n-x}\tp
\tag{6}
\end{equation}
$$

This formula <a href="#mjx-eqn-6">(6)</a> is called the binomial
distribution.  The expression \( x! \) is the factorial of \( x \):
\( x!=x(x-1)(x-2)\cdots 1 \) and <code>math.factorial</code> can do this computation.

<p>
<b>a)</b>
Implement <a href="#mjx-eqn-6">(6)</a> in a function <code>binomial(x, n, p)</code>.

<p>
<b>b)</b>
What is the probability of getting two heads when flipping a coin five times?  This probability corresponds to \( n=5 \) events, where the success of an event means getting head, which has probability \( p=1/2 \), and we look for \( x=2 \) successes.

<p>
<b>c)</b>
What is the probability of getting four ones in a row when throwing a die?  This probability corresponds to \( n=4 \) events, success is getting one and has probability \( p=1/6 \), and we look for \( x=4 \) successful events.

<p>
<b>d)</b>
Suppose cross country skiers typically experience one ski break in one out of 120 competitions. Hence, the probability of breaking a ski can be set to \( p=1/120 \). What is the probability \( b \) that a skier will experience a ski break during five competitions in a world championship?

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
This question is a bit more demanding than the other two. We are looking for the probability of 1, 2, 3, 4 or 5 ski breaks, so it is simpler to ask for the probability \( c \) of <em>not</em> breaking a ski, and then compute \( b=1-c \). Define <em>success</em> as breaking a ski. We then look for \( x=0 \) successes out of \( n=5 \) trials, with \( p=1/120 \) for each trial. Compute \( b \).

<p>
<!-- --- end hint in exercise --- -->

<p>
Filename: <code>Bernoulli_trials.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 24: Compute probabilities with the Poisson distribution <a name="sec:input:ex16"></a></h2>

Suppose that over a period of \( t_m \) time units,
a particular uncertain event happens (on average) \( \nu t_m \) times.
The probability that there will be \( x \) such events in a time period \( t \)
is approximately given by the formula

$$
\begin{equation}
P(x,t, \nu) = {(\nu t)^x\over x!}e^{-\nu t}\tp
\tag{7}
\end{equation}
$$

This formula is known as the Poisson distribution. (It can be shown
that <a href="#mjx-eqn-7">(7)</a> arises from
<a href="#mjx-eqn-6">(6)</a> when the probability \( p \) of experiencing the
event in a small time interval \( t/n \) is \( p=\nu t/n \) and we let
\( n\rightarrow\infty \).) An important assumption is that all events are
independent of each other and that the probability of experiencing an
event does not change significantly over time. This is known as a
<em>Poisson process</em> in probability theory.

<p>
<b>a)</b>
Implement <a href="#mjx-eqn-7">(7)</a> in a function <code>Poisson(x, t,
nu)</code>, and make a program that reads \( x \), \( t \), and \( \nu \) from the
command line and writes out the probability \( P(x,t,\nu) \).  Use this
program to solve the problems below.

<p>
<b>b)</b>
Suppose you are waiting for a taxi in a certain street at night. On
average, 5 taxis pass this street every hour at this time of the
night. What is the probability of not getting a taxi after having
waited 30 minutes?  Since we have 5 events in a time period of \( t_m=1 \)
hour, \( \nu t_m= \nu = 5 \). The sought probability is then \( P(0, 1/2,
5) \). Compute this number. What is the probability of having to wait
two hours for a taxi?  If 8 people need two taxis, that is the
probability that two taxis arrive in a period of 20 minutes?

<p>
<b>c)</b>
In a certain location, 10 earthquakes have been recorded during the
last 50 years. What is the probability of experiencing exactly three
earthquakes over a period of 10 years in this area? What is the
probability that a visitor for one week does not experience any
earthquake?  With 10 events over 50 years we have \( \nu t_m = \nu \cdot
50 \hbox{ years} = 10 \hbox{ events} \), which implies \( \nu = 1/5 \) event
per year. The answer to the first question of having \( x=3 \) events in a
period of \( t=10 \) years is given directly by
<a href="#mjx-eqn-7">(7)</a>. The second question asks for \( x=0 \)
events in a time period of 1 week, i.e., \( t=1/52 \) years, so the answer
is \( P(0,1/52,1/5) \).

<p>
<b>d)</b>
Suppose that you count the number of misprints in the first versions
of the reports you write and that this number shows an average of six
misprints per page. What is the probability that a reader of a first
draft of one of your reports reads six pages without hitting a
misprint?  Assuming that the Poisson distribution can be applied to
this problem, we have &quot;time&quot; \( t_m \) as 1 page and \( \nu \cdot 1 = 6 \),
i.e., \( \nu=6 \) events (misprints) per page. The probability of no
events in a &quot;period&quot; of six pages is \( P(0,6,6) \).

<p>
Filename: <code>Poisson_processes.py</code>.

<p>
<!-- --- end exercise --- -->

<h1>References  <a name="___sec108"></a></h1>

<!-- begin bibliography -->

<ol>
 <li> <a name="Langtangen_TCSE6_class"></a> <b>H. P. Langtangen</b>. 
    Introduction to classes in Python,
    <a href="http://tcse6.on.net/class" target="_self"><tt>http://tcse6.on.net/class</tt></a>.</li>
 <li> <a name="Langtangen_TCSE6_oo"></a> <b>H. P. Langtangen</b>. 
    Object-oriented programming,
    <a href="http://tcse6.on.net/oo" target="_self"><tt>http://tcse6.on.net/oo</tt></a>.</li>
 <li> <a name="PythonTk"></a> <b>J. E. Grayson</b>. 
    <em>Python and Tkinter Programming</em>,
    Manning,
    2000.</li>
 <li> <a name="QuickPython"></a> <b>D. Harms and K. McDonald</b>. 
    <em>The Quick Python Book</em>,
    Manning,
    1999.</li>
 <li> <a name="TCSE3"></a> <b>H. P. Langtangen</b>. 
    <em>Python Scripting for Computational Science</em>,
    Springer,
    2009.</li>
 <li> <a name="PythonBook"></a> <b>M. Lutz</b>. 
    <em>Programming Python</em>,
    O'Reilly,
    2011.</li>
 <li> <a name="Langtangen_TCSE6_nose"></a> <b>H. P. Langtangen</b>. 
    Unit testing with nose,
    <a href="http://tcse6.on.net/nose" target="_self"><tt>http://tcse6.on.net/nose</tt></a>.</li>
 <li> <a name="PySetup:py"></a> <b>G. Ward and A. Baxter</b>. 
    Distributing Python Modules,
    <a href="http://docs.python.org/2/distutils/" target="_self"><tt>http://docs.python.org/2/distutils/</tt></a>.</li>
 <li> <a name="Langtangen_bitgit"></a> <b>H. P. Langtangen</b>. 
    Quick Intro to Version Control Systems and Project Hosting Sites,
    <a href="http://hplgit.github.io/teamods/bitgit/html/" target="_self"><tt>http://hplgit.github.io/teamods/bitgit/html/</tt></a>.</li>
</ol>

<!-- end bibliography -->

<p>
<!-- begin bottom navigation -->
<table style="width: 100%"><tr><td>
</td><td>
</td></tr></table>
<!-- end bottom navigation -->
</p>

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

